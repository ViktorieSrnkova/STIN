
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for plugins/@yarnpkg/plugin-production-install.cjs</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../index.html">All files</a> / <a href="index.html">plugins/@yarnpkg</a> plugin-production-install.cjs</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">15.13% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>537/3549</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">3.32% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>99/2973</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">12.79% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>136/1063</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>9/9</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a>
<a name='L37'></a><a href='#L37'>37</a>
<a name='L38'></a><a href='#L38'>38</a>
<a name='L39'></a><a href='#L39'>39</a>
<a name='L40'></a><a href='#L40'>40</a>
<a name='L41'></a><a href='#L41'>41</a>
<a name='L42'></a><a href='#L42'>42</a>
<a name='L43'></a><a href='#L43'>43</a>
<a name='L44'></a><a href='#L44'>44</a>
<a name='L45'></a><a href='#L45'>45</a>
<a name='L46'></a><a href='#L46'>46</a>
<a name='L47'></a><a href='#L47'>47</a>
<a name='L48'></a><a href='#L48'>48</a>
<a name='L49'></a><a href='#L49'>49</a>
<a name='L50'></a><a href='#L50'>50</a>
<a name='L51'></a><a href='#L51'>51</a>
<a name='L52'></a><a href='#L52'>52</a>
<a name='L53'></a><a href='#L53'>53</a>
<a name='L54'></a><a href='#L54'>54</a>
<a name='L55'></a><a href='#L55'>55</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">88x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">32x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">4x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">16x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">370x</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-production-install",
factory: function (require) {
var plugin;plugin=(()=&gt;{var e={7847:(e,t,r)=&gt;{"use strict";r.r(t),r.d(t,{default:()=&gt;m});function n(e,t,r,n){var s,o=arguments.length,i=o&lt;3?<span class="branch-0 cbranch-no" title="branch not covered" >t:</span>null===n?n=Object.getOwnPropertyDescriptor(t,r):n;<span class="missing-if-branch" title="if path not taken" >I</span>if("object"==typeof Reflect&amp;&amp;"function"==typeof Reflect.decorate)<span class="cstat-no" title="statement not covered" >i=Reflect.decorate(e,t,r,n);e</span>lse for(var a=e.length-1;a&gt;=0;a--)(s=e[a])&amp;&amp;(i=(o&lt;3?<span class="branch-0 cbranch-no" title="branch not covered" >s(i):</span>o&gt;3?s(t,r,i):<span class="branch-1 cbranch-no" title="branch not covered" >s(t,r))</span>||i);return o&gt;3&amp;&amp;i&amp;&amp;Object.defineProperty(t,r,i),i}Object.create;Object.create;const s=require("@yarnpkg/core");var o=r(484),i=r(2770);const a=require("@yarnpkg/cli");var c=r(4688);const u=require("@yarnpkg/plugin-patch"),l=require("@yarnpkg/plugin-pack");var p=r(8042);async function <span class="fstat-no" title="function not covered" >f(</span>e,t){const r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const n of e.storedPackages.values())<span class="cstat-no" title="statement not covered" >for(const s of n.dependencies.values()){<span class="cstat-no" title="statement not covered" >if(e.storedResolutions.get(s.descriptorHash)===t.locatorHash){<span class="cstat-no" title="statement not covered" >r.push(n);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn r}</span>async function <span class="fstat-no" title="function not covered" >h(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return await c.xfs.mkdirpPromise(c.ppath.dirname(c.ppath.resolve(t,r))),c.xfs.copyFilePromise(c.ppath.resolve(e,r),c.ppath.resolve(t,r))}</span>async function <span class="fstat-no" title="function not covered" >d(</span>e,t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >[])</span>{<span class="cstat-no" title="statement not covered" >return async function <span class="fstat-no" title="function not covered" >e(</span>t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >[])</span>{<span class="cstat-no" title="statement not covered" >if(!(await c.xfs.lstatPromise(t)).isDirectory())<span class="cstat-no" title="statement not covered" >throw new Error("src not a folder");{<span class="cstat-no" title="statement not covered" ></span></span>await c.xfs.existsPromise(r)||await c.xfs.mkdirpPromise(r);c</span>onst s=<span class="cstat-no" title="statement not covered" >await c.xfs.readdirPromise(t);<span class="cstat-no" title="statement not covered" ></span>for(const o of s){const s=<span class="cstat-no" title="statement not covered" >c.ppath.resolve(t,o),</span>i=<span class="cstat-no" title="statement not covered" >c.ppath.resolve(r,o);<span class="cstat-no" title="statement not covered" ></span>(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(const e of n)<span class="cstat-no" title="statement not covered" >if(s.endsWith(e))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}</span>)()||((await c.xfs.lstatPromise(s)).isDirectory()?await e(s,i,n):await c.xfs.copyFilePromise(s,i))}</span>}</span>}(c.ppath.resolve(e,r),c.ppath.resolve(t,r),n)}</span>class g{<span class="fstat-no" title="function not covered" >co</span>nstructor({fetcher:e,project:t,cache:r}){<span class="cstat-no" title="statement not covered" >this.fetcher=e,this.project=t,this.cache=r}<span class="fstat-no" title="function not covered" ></span>su</span>pports(e,t){<span class="cstat-no" title="statement not covered" >return this.fetcher.supports(e,t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tLocalPath(e,t){<span class="cstat-no" title="statement not covered" >return e.reference.startsWith(s.WorkspaceResolver.protocol)&amp;&amp;e.reference!==s.WorkspaceResolver.protocol+"."?null:this.fetcher.getLocalPath(e,t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync fetch(e,t){const r=<span class="cstat-no" title="statement not covered" >t.checksums.get(e.locatorHash)||null;<span class="cstat-no" title="statement not covered" ></span>if(e.reference.startsWith(s.WorkspaceResolver.protocol)&amp;&amp;e.reference!==s.WorkspaceResolver.protocol+"."){const n=<span class="cstat-no" title="statement not covered" >await this.makeTemporaryCache(t.cache),</span>[o,i,a]=<span class="cstat-no" title="statement not covered" >await n.fetchPackageFromCache(e,r,{onHit:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.report.reportCacheHit(e),</span>onMiss:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.report.reportCacheMiss(e,s.structUtils.prettyLocator(t.project.configuration,e)+" can't be found in the cache and will be packed from disk."),</span>loader:<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;<span class="cstat-no" title="statement not covered" >this.packWorkspace(e,t),</span>skipIntegrityCheck:t.skipIntegrityCheck});<span class="cstat-no" title="statement not covered" ></span>return n.markedFiles.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.cache.markedFiles.add(e))</span>,{packageFs:o,releaseFs:i,prefixPath:s.structUtils.getIdentVendorPath(e),checksum:null!=r?r:a}}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.reference.startsWith("npm:")){const n=<span class="cstat-no" title="statement not covered" >this.cache.getLocatorPath(e,r),</span>o=<span class="cstat-no" title="statement not covered" >t.cache.getLocatorPath(e,r);<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;await c.xfs.existsPromise(n)&amp;&amp;o&amp;&amp;!await c.xfs.existsPromise(o))<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await c.xfs.linkPromise(n,o)}</span>catch(e){<span class="cstat-no" title="statement not covered" >await c.xfs.existsPromise(o)||t.report.reportError(s.MessageName.FETCH_FAILED,e)}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this.fetcher.fetch(e,t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync packWorkspace(e,{report:t}){const{configuration:r}=<span class="cstat-no" title="statement not covered" >this.project,</span>n=<span class="cstat-no" title="statement not covered" >this.project.getWorkspaceByLocator(e);<span class="cstat-no" title="statement not covered" ></span>return c.xfs.mktempPromise(<span class="fstat-no" title="function not covered" >as</span>ync o=&gt;{const i=<span class="cstat-no" title="statement not covered" >s.structUtils.slugifyLocator(e),</span>a=<span class="cstat-no" title="statement not covered" >c.ppath.join(o,(0,c.toFilename)(i+"-pack.log")),</span>u=<span class="cstat-no" title="statement not covered" >`# This file contains the result of Yarn calling packing "${i}" ("${n.cwd}")\n`,</span>{stdout:p,stderr:f}=<span class="cstat-no" title="statement not covered" >r.getSubprocessStreams(a,{report:t,prefix:s.structUtils.prettyLocator(r,n.anchoredLocator),header:u}),</span>h=<span class="cstat-no" title="statement not covered" >await s.StreamReport.start({configuration:r,stdout:p},<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{});<span class="cstat-no" title="statement not covered" ></span>try{let t;<span class="cstat-no" title="statement not covered" >return await l.packUtils.prepareForPack(n,{report:h},<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >h.reportJson({base:n.cwd});c</span>onst e=<span class="cstat-no" title="statement not covered" >await l.packUtils.genPackList(n);<span class="cstat-no" title="statement not covered" ></span>for(const t of e)<span class="cstat-no" title="statement not covered" >h.reportInfo(null,t),h.reportJson({location:t});c</span></span>onst r=<span class="cstat-no" title="statement not covered" >await l.packUtils.genPackStream(n,e);<span class="cstat-no" title="statement not covered" ></span>t=await s.miscUtils.bufferStream(r)}</span>),await s.tgzUtils.convertToZip(t,{stripComponents:1,prefixPath:s.structUtils.getIdentVendorPath(e)})}</span>catch(e){<span class="cstat-no" title="statement not covered" >throw c.xfs.detachTemp(o),h.reportExceptionOnce(e),new s.ReportError(s.MessageName.LIFECYCLE_SCRIPT,`Packing ${i} failed, logs can be found here: ${s.formatUtils.pretty(r,a,s.formatUtils.Type.PATH)}); run ${s.formatUtils.pretty(r,`yarn ${c.ppath.relative(this.project.cwd,n.cwd)} pack`,s.formatUtils.Type.CODE)} to investigate`)}</span>finally{<span class="cstat-no" title="statement not covered" >await h.finalize(),p.end(),f.end()}</span>}</span>)}<span class="fstat-no" title="function not covered" ></span>as</span>ync makeTemporaryCache(e){const{configuration:{startingCwd:t,plugins:r},check:n,immutable:o,cwd:i}=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >s.Configuration.create(t,r);<span class="cstat-no" title="statement not covered" ></span>return a.useWithSource(t,{enableMirror:!1},t,{overwrite:!0}),new s.Cache(i,{configuration:a,check:n,immutable:o})}</span>}class y{<span class="fstat-no" title="function not covered" >co</span>nstructor({resolver:e,project:t,stripTypes:r=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>){<span class="cstat-no" title="statement not covered" >this.resolver=e,this.project=t,this.stripTypes=r}<span class="fstat-no" title="function not covered" ></span>su</span>pportsDescriptor(e,t){<span class="cstat-no" title="statement not covered" >return this.resolver.supportsDescriptor(e,t)}<span class="fstat-no" title="function not covered" ></span>su</span>pportsLocator(e,t){<span class="cstat-no" title="statement not covered" >return this.resolver.supportsLocator(e,t)}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldPersistResolution(e,t){<span class="cstat-no" title="statement not covered" >return!e.reference.startsWith(s.WorkspaceResolver.protocol)&amp;&amp;this.resolver.shouldPersistResolution(e,t)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndDescriptor(e,t,r){<span class="cstat-no" title="statement not covered" >return this.resolver.bindDescriptor(e,t,r)}<span class="fstat-no" title="function not covered" ></span>ge</span>tResolutionDependencies(e,t){<span class="cstat-no" title="statement not covered" >return this.resolver.getResolutionDependencies(e,t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getCandidates(e,t,r){<span class="cstat-no" title="statement not covered" >if(e.range.startsWith(s.WorkspaceResolver.protocol)&amp;&amp;e.range!==s.WorkspaceResolver.protocol+"."){<span class="cstat-no" title="statement not covered" >return[this.project.getWorkspaceByDescriptor(e).anchoredLocator]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.resolver.getCandidates(e,t,r)}<span class="fstat-no" title="function not covered" ></span>as</span>ync resolve(e,t){const r=<span class="cstat-no" title="statement not covered" >await(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >if(e.reference.startsWith(s.WorkspaceResolver.protocol)&amp;&amp;e.reference!==s.WorkspaceResolver.protocol+"."){const t=<span class="cstat-no" title="statement not covered" >this.project.getWorkspaceByLocator(e);<span class="cstat-no" title="statement not covered" ></span>return{...e,version:t.manifest.version||"0.0.0",languageName:"unknown",linkType:s.LinkType.SOFT,dependencies:new Map([...t.manifest.dependencies]),peerDependencies:new Map([...t.manifest.peerDependencies]),dependenciesMeta:t.manifest.dependenciesMeta,peerDependenciesMeta:t.manifest.peerDependenciesMeta,bin:t.manifest.bin}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.resolver.resolve(e,t)}</span>)(),</span>n=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>for(const[e,t]of r.dependencies.entries())<span class="cstat-no" title="statement not covered" >this.stripTypes&amp;&amp;"types"===t.scope||n.set(e,t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{...r,dependencies:n}}<span class="fstat-no" title="function not covered" ></span>as</span>ync getSatisfying(e,t,r){<span class="cstat-no" title="statement not covered" >return null}</span>}const _=(0,c.toFilename)("package.json");class E extends p.Command{constructor(){super(...arguments),this.json=!1,this.noStripTypes=!1,this.pack=!1,this.silent=!1}<span class="fstat-no" title="function not covered" >as</span>ync execute(){const e=<span class="cstat-no" title="statement not covered" >await s.Configuration.find(this.context.cwd,this.context.plugins),</span>{project:t,workspace:r}=<span class="cstat-no" title="statement not covered" >await s.Project.find(e,this.context.cwd);<span class="cstat-no" title="statement not covered" ></span>if(await t.restoreInstallState(),!r)<span class="cstat-no" title="statement not covered" >throw new a.WorkspaceRequiredError(t.cwd,this.context.cwd);c</span></span>onst n=<span class="cstat-no" title="statement not covered" >await s.Cache.find(e,{immutable:!0,check:!1}),</span>u=<span class="cstat-no" title="statement not covered" >t.topLevelWorkspace.cwd,</span>p=<span class="cstat-no" title="statement not covered" >c.ppath.isAbsolute(this.outDirectory)?this.outDirectory:c.ppath.join(r.cwd,this.outDirectory);<span class="cstat-no" title="statement not covered" ></span>return(await s.StreamReport.start({configuration:e,json:this.json,stdout:this.context.stdout},<span class="fstat-no" title="function not covered" >as</span>ync f=&gt;{<span class="cstat-no" title="statement not covered" >await f.startTimerPromise("Setting up production directory",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >await c.xfs.mkdirpPromise(p),await h(u,p,e.get("lockfileFilename")),await h(u,p,e.get("rcFilename")),await h(r.cwd,p,_);c</span>onst n=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >e.get(t)&amp;&amp;n.push(e.get(t))}</span>catch(e){}}</span>;<span class="cstat-no" title="statement not covered" ></span>s("bstatePath"),s("installStatePath"),s("cacheFolder"),s("deferredVersionFolder"),await e.triggerHook(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.populateYarnPaths,</span>t,<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e&amp;&amp;n.push(e)}</span>),await d(u,p,".yarn",n)}</span>),await f.startTimerPromise("Installing production version",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{const r=<span class="cstat-no" title="statement not covered" >await s.Configuration.find(p,this.context.plugins);<span class="cstat-no" title="statement not covered" ></span>if(!this.noStripTypes)<span class="cstat-no" title="statement not covered" >for(const[e,t]of r.packageExtensions.entries()){const n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const[e,r]of t)<span class="cstat-no" title="statement not covered" >n.push([e,r.filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;{var t;<span class="cstat-no" title="statement not covered" >return"types"!==(null===(t=null==e?void 0:e.descriptor)||void 0===t?void 0:t.scope)}</span>)]);<span class="cstat-no" title="statement not covered" >r</span></span>.packageExtensions.set(e,n)}</span>c</span></span>onst{project:u,workspace:l}=<span class="cstat-no" title="statement not covered" >await s.Project.find(r,p);<span class="cstat-no" title="statement not covered" ></span>if(!l)<span class="cstat-no" title="statement not covered" >throw new a.WorkspaceRequiredError(t.cwd,this.context.cwd);<span class="cstat-no" title="statement not covered" >l</span></span>.manifest.devDependencies.clear();c</span>onst h=<span class="cstat-no" title="statement not covered" >await s.Cache.find(r,{immutable:!1,check:!1}),</span>d=<span class="cstat-no" title="statement not covered" >e.makeFetcher(),</span>_=<span class="cstat-no" title="statement not covered" >new o.B([new i.C,e.makeResolver()]),</span>E=<span class="cstat-no" title="statement not covered" >new y({project:t,resolver:_,stripTypes:!this.noStripTypes}),</span>m=<span class="cstat-no" title="statement not covered" >new g({cache:n,fetcher:d,project:t});<span class="cstat-no" title="statement not covered" ></span>await this.modifyOriginalResolutions(u,E,{project:u,fetchOptions:{cache:h,project:u,fetcher:m,checksums:u.storedChecksums,report:f},resolver:E,report:f}),await u.install({cache:h,report:f,immutable:!1,fetcher:m,resolver:E}),await f.startTimerPromise("Cleaning up unused dependencies",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{const e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e.push(...await this.getPatchSourcesToRemove(u,h));<span class="cstat-no" title="statement not covered" >f</span>or(const t of e)<span class="cstat-no" title="statement not covered" >await c.xfs.existsPromise(t)&amp;&amp;(f.reportInfo(s.MessageName.UNUSED_CACHE_ENTRY,c.ppath.basename(t)+" appears to be unused - removing"),await c.xfs.removePromise(t))}</span></span>)}</span>),this.pack&amp;&amp;await f.startTimerPromise("Packing workspace ",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >await l.packUtils.prepareForPack(r,{report:f},<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >f.reportJson({base:r.cwd});c</span>onst e=<span class="cstat-no" title="statement not covered" >await l.packUtils.genPackList(r);<span class="cstat-no" title="statement not covered" ></span>for(const t of e)<span class="cstat-no" title="statement not covered" >if(f.reportInfo(null,t),f.reportJson({location:t}),t.endsWith(_)){const e=<span class="cstat-no" title="statement not covered" >await l.packUtils.genPackageManifest(r);<span class="cstat-no" title="statement not covered" ></span>await c.xfs.writeJsonPromise(c.ppath.resolve(p,t),e)}</span>else <span class="cstat-no" title="statement not covered" >await h(r.cwd,p,t)}</span></span></span>)}</span>)}</span>)).exitCode()}<span class="fstat-no" title="function not covered" ></span>as</span>ync getPatchSourcesToRemove(e,t){var r;const n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e.storedPackages.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.reference.startsWith("patch:")&amp;&amp;n.push(e)}</span>);c</span>onst s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const o of n){const{sourceLocator:n}=<span class="cstat-no" title="statement not covered" >u.patchUtils.parseLocator(o),</span>i=<span class="cstat-no" title="statement not covered" >e.storedPackages.get(n.locatorHash);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>f((await f(e,i)).filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.locatorHash!==o.locatorHash)</span>.length&gt;0){const o=<span class="cstat-no" title="statement not covered" >t.getLocatorPath(n,null!==(r=e.storedChecksums.get(n.locatorHash))&amp;&amp;void 0!==r?r:null);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;s.push(o)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>as</span>ync modifyOriginalResolutions(e,t,r){<span class="cstat-no" title="statement not covered" >await r.report.startTimerPromise("Modifying original install state",<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{<span class="cstat-no" title="statement not covered" >for(const[n,s]of e.originalPackages.entries()){const o=<span class="cstat-no" title="statement not covered" >await t.resolve(s,r);<span class="cstat-no" title="statement not covered" ></span>e.originalPackages.set(n,o)}</span>}</span>)}</span>}E.usage=p.Command.Usage({description:"INSTALL!",details:"prod only install",examples:[["Install the project with only prod dependencies","$0 prod-install"]]}),n([p.Command.String()],E.prototype,"outDirectory",void 0),n([p.Command.Boolean("--json")],E.prototype,"json",void 0),n([p.Command.Boolean("--no-strip-types")],E.prototype,"noStripTypes",void 0),n([p.Command.Boolean("--pack")],E.prototype,"pack",void 0),n([p.Command.Boolean("--silent",{hidden:!0})],E.prototype,"silent",void 0),n([p.Command.Path("prod-install")],E.prototype,"execute",null);const m={commands:[E]}},6117:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5747);t.FILE_SYSTEM_ADAPTER={lstat:n.lstat,stat:n.stat,lstatSync:n.lstatSync,statSync:n.statSync,readdir:n.readdir,readdirSync:n.readdirSync},t.createFileSystemAdapter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0===e?t.FILE_SYSTEM_ADAPTER:Object.assign(Object.assign({},t.FILE_SYSTEM_ADAPTER),e)}</span>},9774:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const r=process.versions.node.split("."),n=parseInt(r[0],10),s=parseInt(r[1],10),o=n&gt;10,i=10===n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >s&gt;=10;</span>t.IS_SUPPORT_READDIR_WITH_FILE_TYPES=o||<span class="branch-1 cbranch-no" title="branch not covered" >i}</span>,5670:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1020),s=r(5516),o=r(8844);function <span class="fstat-no" title="function not covered" >i(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return e instanceof o.default?e:new o.default(e)}</span>t.Settings=o.default,t.scandir=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if("function"==typeof t)<span class="cstat-no" title="statement not covered" >return n.read(e,i(),t);<span class="cstat-no" title="statement not covered" >n</span></span>.read(e,i(t),r)}</span>,t.scandirSync=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const r=<span class="cstat-no" title="statement not covered" >i(t);<span class="cstat-no" title="statement not covered" ></span>return s.read(e,r)}</span>},1020:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(3403),s=r(9078),o=r(9774),i=r(5225);function <span class="fstat-no" title="function not covered" >a(</span>e,t,r){<span class="cstat-no" title="statement not covered" >t.fs.readdir(e,{withFileTypes:!0},<span class="fstat-no" title="function not covered" >(n</span>,o)=&gt;{<span class="cstat-no" title="statement not covered" >if(null!==n)<span class="cstat-no" title="statement not covered" >return u(r,n);c</span></span>onst a=<span class="cstat-no" title="statement not covered" >o.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;(<span class="cstat-no" title="statement not covered" >{dirent:r,name:r.name,path:`${e}${t.pathSegmentSeparator}${r.name}`})</span>);<span class="cstat-no" title="statement not covered" ></span>if(!t.followSymbolicLinks)<span class="cstat-no" title="statement not covered" >return l(r,a);c</span></span>onst c=<span class="cstat-no" title="statement not covered" >a.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e.dirent.isSymbolicLink())<span class="cstat-no" title="statement not covered" >return r(null,e);<span class="cstat-no" title="statement not covered" >t</span></span>.fs.stat(e.path,<span class="fstat-no" title="function not covered" >(n</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >null!==n?t.throwErrorOnBrokenSymbolicLink?r(n):r(null,e):(e.dirent=i.fs.createDirentFromStats(e.name,s),r(null,e)))</span>}</span>}</span>(e,t))</span>;<span class="cstat-no" title="statement not covered" ></span>s(c,<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(null!==e)<span class="cstat-no" title="statement not covered" >return u(r,e);<span class="cstat-no" title="statement not covered" >l</span></span>(r,t)}</span>)}</span>)}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,t,r){<span class="cstat-no" title="statement not covered" >t.fs.readdir(e,<span class="fstat-no" title="function not covered" >(o</span>,a)=&gt;{<span class="cstat-no" title="statement not covered" >if(null!==o)<span class="cstat-no" title="statement not covered" >return u(r,o);c</span></span>onst c=<span class="cstat-no" title="statement not covered" >a.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >`${e}${t.pathSegmentSeparator}${r}`)</span>,</span>p=<span class="cstat-no" title="statement not covered" >c.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >n.stat(e,t.fsStatSettings,r))</span></span>;<span class="cstat-no" title="statement not covered" ></span>s(p,<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >if(null!==e)<span class="cstat-no" title="statement not covered" >return u(r,e);c</span></span>onst s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>a.forEach(<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{const o=<span class="cstat-no" title="statement not covered" >n[r],</span>a=<span class="cstat-no" title="statement not covered" >{name:e,path:c[r],dirent:i.fs.createDirentFromStats(e,o)};<span class="cstat-no" title="statement not covered" ></span>t.stats&amp;&amp;(a.stats=o),s.push(a)}</span>),l(r,s)}</span>)}</span>)}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t){<span class="cstat-no" title="statement not covered" >e(t)}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,t){<span class="cstat-no" title="statement not covered" >e(null,t)}</span>t.read=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >return!t.stats&amp;&amp;o.IS_SUPPORT_READDIR_WITH_FILE_TYPES?a(e,t,r):c(e,t,r)}</span>,t.readdirWithFileTypes=a,t.readdir=c},5516:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(3403),s=r(9774),o=r(5225);function <span class="fstat-no" title="function not covered" >i(</span>e,t){<span class="cstat-no" title="statement not covered" >return t.fs.readdirSync(e,{withFileTypes:!0}).map(<span class="fstat-no" title="function not covered" >r=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >{dirent:r,name:r.name,path:`${e}${t.pathSegmentSeparator}${r.name}`};<span class="cstat-no" title="statement not covered" ></span>if(n.dirent.isSymbolicLink()&amp;&amp;t.followSymbolicLinks)<span class="cstat-no" title="statement not covered" >try{const e=<span class="cstat-no" title="statement not covered" >t.fs.statSync(n.path);<span class="cstat-no" title="statement not covered" ></span>n.dirent=o.fs.createDirentFromStats(n.name,e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(t.throwErrorOnBrokenSymbolicLink)<span class="cstat-no" title="statement not covered" >throw e}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn n}</span>)}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t){<span class="cstat-no" title="statement not covered" >return t.fs.readdirSync(e).map(<span class="fstat-no" title="function not covered" >r=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >`${e}${t.pathSegmentSeparator}${r}`,</span>i=<span class="cstat-no" title="statement not covered" >n.statSync(s,t.fsStatSettings),</span>a=<span class="cstat-no" title="statement not covered" >{name:r,path:s,dirent:o.fs.createDirentFromStats(r,i)};<span class="cstat-no" title="statement not covered" ></span>return t.stats&amp;&amp;(a.stats=i),a}</span>)}</span>t.read=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return!t.stats&amp;&amp;s.IS_SUPPORT_READDIR_WITH_FILE_TYPES?i(e,t):a(e,t)}</span>,t.readdirWithFileTypes=i,t.readdir=a},8844:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5622),s=r(3403),o=r(6117);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this._options=e,this.followSymbolicLinks=this._getValue(this._options.followSymbolicLinks,!1),this.fs=o.createFileSystemAdapter(this._options.fs),this.pathSegmentSeparator=this._getValue(this._options.pathSegmentSeparator,n.sep),this.stats=this._getValue(this._options.stats,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!0),this.fsStatSettings=new s.Settings({followSymbolicLink:this.followSymbolicLinks,fs:this.fs,throwErrorOnBrokenSymbolicLink:this.throwErrorOnBrokenSymbolicLink})}<span class="fstat-no" title="function not covered" ></span>_g</span>etValue(e,t){<span class="cstat-no" title="statement not covered" >return void 0===e?t:e}</span>}},2156:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});class r{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this.name=e,this.isBlockDevice=t.isBlockDevice.bind(t),this.isCharacterDevice=t.isCharacterDevice.bind(t),this.isDirectory=t.isDirectory.bind(t),this.isFIFO=t.isFIFO.bind(t),this.isFile=t.isFile.bind(t),this.isSocket=t.isSocket.bind(t),this.isSymbolicLink=t.isSymbolicLink.bind(t)}</span>}t.createDirentFromStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return new r(e,t)}</span>},5225:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2156);t.fs=n},1208:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5747);t.FILE_SYSTEM_ADAPTER={lstat:n.lstat,stat:n.stat,lstatSync:n.lstatSync,statSync:n.statSync},t.createFileSystemAdapter=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0===e?t.FILE_SYSTEM_ADAPTER:Object.assign(Object.assign({},t.FILE_SYSTEM_ADAPTER),e)}</span>},3403:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(7790),s=r(4846),o=r(2687);function <span class="fstat-no" title="function not covered" >i(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return e instanceof o.default?e:new o.default(e)}</span>t.Settings=o.default,t.stat=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if("function"==typeof t)<span class="cstat-no" title="statement not covered" >return n.read(e,i(),t);<span class="cstat-no" title="statement not covered" >n</span></span>.read(e,i(t),r)}</span>,t.statSync=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const r=<span class="cstat-no" title="statement not covered" >i(t);<span class="cstat-no" title="statement not covered" ></span>return s.read(e,r)}</span>},7790:(e,t)=&gt;{"use strict";function <span class="fstat-no" title="function not covered" >r(</span>e,t){<span class="cstat-no" title="statement not covered" >e(t)}</span>function <span class="fstat-no" title="function not covered" >n(</span>e,t){<span class="cstat-no" title="statement not covered" >e(null,t)}</span>Object.defineProperty(t,"__esModule",{value:!0}),t.read=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,s){<span class="cstat-no" title="statement not covered" >t.fs.lstat(e,<span class="fstat-no" title="function not covered" >(o</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >null!==o?r(s,o):i.isSymbolicLink()&amp;&amp;t.followSymbolicLink?void t.fs.stat(e,<span class="fstat-no" title="function not covered" >(e</span>,o)=&gt;{<span class="cstat-no" title="statement not covered" >if(null!==e)<span class="cstat-no" title="statement not covered" >return t.throwErrorOnBrokenSymbolicLink?r(s,e):n(s,i);<span class="cstat-no" title="statement not covered" >t</span></span>.markSymbolicLink&amp;&amp;(o.isSymbolicLink=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!0)</span>,n(s,o)}</span>):n(s,i))</span>}</span>},4846:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.read=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const r=<span class="cstat-no" title="statement not covered" >t.fs.lstatSync(e);<span class="cstat-no" title="statement not covered" ></span>if(!r.isSymbolicLink()||!t.followSymbolicLink)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >t</span></span>ry{const r=<span class="cstat-no" title="statement not covered" >t.fs.statSync(e);<span class="cstat-no" title="statement not covered" ></span>return t.markSymbolicLink&amp;&amp;(r.isSymbolicLink=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!0)</span>,r}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(!t.throwErrorOnBrokenSymbolicLink)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >t</span></span>hrow e}</span>}</span>},2687:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1208);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this._options=e,this.followSymbolicLink=this._getValue(this._options.followSymbolicLink,!0),this.fs=n.createFileSystemAdapter(this._options.fs),this.markSymbolicLink=this._getValue(this._options.markSymbolicLink,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!0)}<span class="fstat-no" title="function not covered" ></span>_g</span>etValue(e,t){<span class="cstat-no" title="statement not covered" >return void 0===e?t:e}</span>}},3011:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2369),s=r(7696),o=r(2111),i=r(4954);function <span class="fstat-no" title="function not covered" >a(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return e instanceof i.default?e:new i.default(e)}</span>t.Settings=i.default,t.walk=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >if("function"==typeof t)<span class="cstat-no" title="statement not covered" >return new n.default(e,a()).read(t);<span class="cstat-no" title="statement not covered" >n</span></span>ew n.default(e,a(t)).read(r)}</span>,t.walkSync=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const r=<span class="cstat-no" title="statement not covered" >a(t);<span class="cstat-no" title="statement not covered" ></span>return new o.default(e,r).read()}</span>,t.walkStream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const r=<span class="cstat-no" title="statement not covered" >a(t);<span class="cstat-no" title="statement not covered" ></span>return new s.default(e,r).read()}</span>},2369:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(8566);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this._root=e,this._settings=t,this._reader=new n.default(this._root,this._settings),this._storage=new Set}<span class="fstat-no" title="function not covered" ></span>re</span>ad(e){<span class="cstat-no" title="statement not covered" >this._reader.onError(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e(t)}</span>(e,t)}</span>),this._reader.onEntry(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._storage.add(e)}</span>),this._reader.onEnd(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e(null,t)}</span>(e,[...this._storage])}</span>),this._reader.read()}</span>}},7696:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2413),s=r(8566);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this._root=e,this._settings=t,this._reader=new s.default(this._root,this._settings),this._stream=new n.Readable({objectMode:!0,read:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},destroy:this._reader.destroy.bind(this._reader)})}<span class="fstat-no" title="function not covered" ></span>re</span>ad(){<span class="cstat-no" title="statement not covered" >return this._reader.onError(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._stream.emit("error",e)}</span>),this._reader.onEntry(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this._stream.push(e)}</span>),this._reader.onEnd(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._stream.push(null)}</span>),this._reader.read(),this._stream}</span>}},2111:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(7835);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this._root=e,this._settings=t,this._reader=new n.default(this._root,this._settings)}<span class="fstat-no" title="function not covered" ></span>re</span>ad(){<span class="cstat-no" title="statement not covered" >return this._reader.read()}</span>}},8566:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(8614),s=r(5670),o=r(1391),i=r(750),a=r(5504);class c extends a.default{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >super(e,t),this._settings=t,this._scandir=s.scandir,this._emitter=new n.EventEmitter,this._queue=o(this._worker.bind(this),this._settings.concurrency),this._isFatalError=!1,this._isDestroyed=!1,this._queue.drain=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._isFatalError||this._emitter.emit("end")}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>ad(){<span class="cstat-no" title="statement not covered" >return this._isFatalError=!1,this._isDestroyed=!1,setImmediate(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._pushToQueue(this._root,this._settings.basePath)}</span>),this._emitter}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >if(this._isDestroyed)<span class="cstat-no" title="statement not covered" >throw new Error("The reader is already destroyed");<span class="cstat-no" title="statement not covered" >t</span></span>his._isDestroyed=!0,this._queue.killAndDrain()}<span class="fstat-no" title="function not covered" ></span>on</span>Entry(e){<span class="cstat-no" title="statement not covered" >this._emitter.on("entry",e)}<span class="fstat-no" title="function not covered" ></span>on</span>Error(e){<span class="cstat-no" title="statement not covered" >this._emitter.once("error",e)}<span class="fstat-no" title="function not covered" ></span>on</span>End(e){<span class="cstat-no" title="statement not covered" >this._emitter.once("end",e)}<span class="fstat-no" title="function not covered" ></span>_p</span>ushToQueue(e,t){const r=<span class="cstat-no" title="statement not covered" >{directory:e,base:t};<span class="cstat-no" title="statement not covered" ></span>this._queue.push(r,<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >null!==e&amp;&amp;this._handleError(e)}</span>)}<span class="fstat-no" title="function not covered" ></span>_w</span>orker(e,t){<span class="cstat-no" title="statement not covered" >this._scandir(e.directory,this._settings.fsScandirSettings,<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >if(null!==r)<span class="cstat-no" title="statement not covered" >return t(r,void 0);<span class="cstat-no" title="statement not covered" >f</span></span>or(const t of n)<span class="cstat-no" title="statement not covered" >this._handleEntry(t,e.base);<span class="cstat-no" title="statement not covered" >t</span></span>(null,void 0)}</span>)}<span class="fstat-no" title="function not covered" ></span>_h</span>andleError(e){<span class="cstat-no" title="statement not covered" >i.isFatalError(this._settings,e)&amp;&amp;(this._isFatalError=!0,this._isDestroyed=!0,this._emitter.emit("error",e))}<span class="fstat-no" title="function not covered" ></span>_h</span>andleEntry(e,t){<span class="cstat-no" title="statement not covered" >if(this._isDestroyed||this._isFatalError)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >e.path;<span class="cstat-no" title="statement not covered" ></span>void 0!==t&amp;&amp;(e.path=i.joinPathSegments(t,e.name,this._settings.pathSegmentSeparator)),i.isAppliedFilter(this._settings.entryFilter,e)&amp;&amp;this._emitEntry(e),e.dirent.isDirectory()&amp;&amp;i.isAppliedFilter(this._settings.deepFilter,e)&amp;&amp;this._pushToQueue(r,e.path)}<span class="fstat-no" title="function not covered" ></span>_e</span>mitEntry(e){<span class="cstat-no" title="statement not covered" >this._emitter.emit("entry",e)}</span>}t.default=c},750:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isFatalError=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return null===e.errorFilter||!e.errorFilter(t)}</span>,t.isAppliedFilter=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return null===e||e(t)}</span>,t.replacePathSegmentSeparator=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.split(/[\\/]/).join(t)}</span>,t.joinPathSegments=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >return""===e?t:e+r+t}</span>},5504:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(750);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this._root=e,this._settings=t,this._root=n.replacePathSegmentSeparator(e,t.pathSegmentSeparator)}</span>}},7835:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5670),s=r(750),o=r(5504);class i extends o.default{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this._scandir=n.scandirSync,this._storage=new Set,this._queue=new Set}<span class="fstat-no" title="function not covered" ></span>re</span>ad(){<span class="cstat-no" title="statement not covered" >return this._pushToQueue(this._root,this._settings.basePath),this._handleQueue(),[...this._storage]}<span class="fstat-no" title="function not covered" ></span>_p</span>ushToQueue(e,t){<span class="cstat-no" title="statement not covered" >this._queue.add({directory:e,base:t})}<span class="fstat-no" title="function not covered" ></span>_h</span>andleQueue(){<span class="cstat-no" title="statement not covered" >for(const e of this._queue.values())<span class="cstat-no" title="statement not covered" >this._handleDirectory(e.directory,e.base)}<span class="fstat-no" title="function not covered" ></span></span>_h</span>andleDirectory(e,t){<span class="cstat-no" title="statement not covered" >try{const r=<span class="cstat-no" title="statement not covered" >this._scandir(e,this._settings.fsScandirSettings);<span class="cstat-no" title="statement not covered" ></span>for(const e of r)<span class="cstat-no" title="statement not covered" >this._handleEntry(e,t)}</span></span>catch(e){<span class="cstat-no" title="statement not covered" >this._handleError(e)}</span>}<span class="fstat-no" title="function not covered" ></span>_h</span>andleError(e){<span class="cstat-no" title="statement not covered" >if(s.isFatalError(this._settings,e))<span class="cstat-no" title="statement not covered" >throw e}<span class="fstat-no" title="function not covered" ></span></span>_h</span>andleEntry(e,t){const r=<span class="cstat-no" title="statement not covered" >e.path;<span class="cstat-no" title="statement not covered" ></span>void 0!==t&amp;&amp;(e.path=s.joinPathSegments(t,e.name,this._settings.pathSegmentSeparator)),s.isAppliedFilter(this._settings.entryFilter,e)&amp;&amp;this._pushToStorage(e),e.dirent.isDirectory()&amp;&amp;s.isAppliedFilter(this._settings.deepFilter,e)&amp;&amp;this._pushToQueue(r,e.path)}<span class="fstat-no" title="function not covered" ></span>_p</span>ushToStorage(e){<span class="cstat-no" title="statement not covered" >this._storage.add(e)}</span>}t.default=i},4954:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5622),s=r(5670);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this._options=e,this.basePath=this._getValue(this._options.basePath,void 0),this.concurrency=this._getValue(this._options.concurrency,1/0),this.deepFilter=this._getValue(this._options.deepFilter,null),this.entryFilter=this._getValue(this._options.entryFilter,null),this.errorFilter=this._getValue(this._options.errorFilter,null),this.pathSegmentSeparator=this._getValue(this._options.pathSegmentSeparator,n.sep),this.fsScandirSettings=new s.Settings({followSymbolicLinks:this._options.followSymbolicLinks,fs:this._options.fs,pathSegmentSeparator:this._options.pathSegmentSeparator,stats:this._options.stats,throwErrorOnBrokenSymbolicLink:this._options.throwErrorOnBrokenSymbolicLink})}<span class="fstat-no" title="function not covered" ></span>_g</span>etValue(e,t){<span class="cstat-no" title="statement not covered" >return void 0===e?t:e}</span>}},2770:(e,t,r)=&gt;{"use strict";t.C=void 0;const n=r(6370).__importStar(r(6743));t.C=class{<span class="fstat-no" title="function not covered" >su</span>pportsDescriptor(e,t){<span class="cstat-no" title="statement not covered" >return!!t.project.storedResolutions.get(e.descriptorHash)||!!t.project.originalPackages.has(n.convertDescriptorToLocator(e).locatorHash)}<span class="fstat-no" title="function not covered" ></span>su</span>pportsLocator(e,t){<span class="cstat-no" title="statement not covered" >return!!t.project.originalPackages.has(e.locatorHash)}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldPersistResolution(e,t){<span class="cstat-no" title="statement not covered" >throw new Error("The shouldPersistResolution method shouldn't be called on the lockfile resolver, which would always answer yes")}<span class="fstat-no" title="function not covered" ></span>bi</span>ndDescriptor(e,t,r){<span class="cstat-no" title="statement not covered" >return e}<span class="fstat-no" title="function not covered" ></span>ge</span>tResolutionDependencies(e,t){<span class="cstat-no" title="statement not covered" >return[]}<span class="fstat-no" title="function not covered" ></span>as</span>ync getCandidates(e,t,r){let s=<span class="cstat-no" title="statement not covered" >r.project.originalPackages.get(n.convertDescriptorToLocator(e).locatorHash);<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return[s];c</span></span>onst o=<span class="cstat-no" title="statement not covered" >r.project.storedResolutions.get(e.descriptorHash);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >throw new Error("Expected the resolution to have been successful - resolution not found");<span class="cstat-no" title="statement not covered" >i</span></span>f(s=r.project.originalPackages.get(o),!s)<span class="cstat-no" title="statement not covered" >throw new Error("Expected the resolution to have been successful - package not found");<span class="cstat-no" title="statement not covered" >r</span></span>eturn[s]}<span class="fstat-no" title="function not covered" ></span>as</span>ync getSatisfying(e,t,r){<span class="cstat-no" title="statement not covered" >return null}<span class="fstat-no" title="function not covered" ></span>as</span>ync resolve(e,t){const r=<span class="cstat-no" title="statement not covered" >t.project.originalPackages.get(e.locatorHash);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw new Error("The lockfile resolver isn't meant to resolve packages - they should already have been stored into a cache");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>}},5579:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.stringifyMessageName=t.MessageName=void 0,function(e){e[e.UNNAMED=0]="UNNAMED",e[e.EXCEPTION=1]="EXCEPTION",e[e.MISSING_PEER_DEPENDENCY=2]="MISSING_PEER_DEPENDENCY",e[e.CYCLIC_DEPENDENCIES=3]="CYCLIC_DEPENDENCIES",e[e.DISABLED_BUILD_SCRIPTS=4]="DISABLED_BUILD_SCRIPTS",e[e.BUILD_DISABLED=5]="BUILD_DISABLED",e[e.SOFT_LINK_BUILD=6]="SOFT_LINK_BUILD",e[e.MUST_BUILD=7]="MUST_BUILD",e[e.MUST_REBUILD=8]="MUST_REBUILD",e[e.BUILD_FAILED=9]="BUILD_FAILED",e[e.RESOLVER_NOT_FOUND=10]="RESOLVER_NOT_FOUND",e[e.FETCHER_NOT_FOUND=11]="FETCHER_NOT_FOUND",e[e.LINKER_NOT_FOUND=12]="LINKER_NOT_FOUND",e[e.FETCH_NOT_CACHED=13]="FETCH_NOT_CACHED",e[e.YARN_IMPORT_FAILED=14]="YARN_IMPORT_FAILED",e[e.REMOTE_INVALID=15]="REMOTE_INVALID",e[e.REMOTE_NOT_FOUND=16]="REMOTE_NOT_FOUND",e[e.RESOLUTION_PACK=17]="RESOLUTION_PACK",e[e.CACHE_CHECKSUM_MISMATCH=18]="CACHE_CHECKSUM_MISMATCH",e[e.UNUSED_CACHE_ENTRY=19]="UNUSED_CACHE_ENTRY",e[e.MISSING_LOCKFILE_ENTRY=20]="MISSING_LOCKFILE_ENTRY",e[e.WORKSPACE_NOT_FOUND=21]="WORKSPACE_NOT_FOUND",e[e.TOO_MANY_MATCHING_WORKSPACES=22]="TOO_MANY_MATCHING_WORKSPACES",e[e.CONSTRAINTS_MISSING_DEPENDENCY=23]="CONSTRAINTS_MISSING_DEPENDENCY",e[e.CONSTRAINTS_INCOMPATIBLE_DEPENDENCY=24]="CONSTRAINTS_INCOMPATIBLE_DEPENDENCY",e[e.CONSTRAINTS_EXTRANEOUS_DEPENDENCY=25]="CONSTRAINTS_EXTRANEOUS_DEPENDENCY",e[e.CONSTRAINTS_INVALID_DEPENDENCY=26]="CONSTRAINTS_INVALID_DEPENDENCY",e[e.CANT_SUGGEST_RESOLUTIONS=27]="CANT_SUGGEST_RESOLUTIONS",e[e.FROZEN_LOCKFILE_EXCEPTION=28]="FROZEN_LOCKFILE_EXCEPTION",e[e.CROSS_DRIVE_VIRTUAL_LOCAL=29]="CROSS_DRIVE_VIRTUAL_LOCAL",e[e.FETCH_FAILED=30]="FETCH_FAILED",e[e.DANGEROUS_NODE_MODULES=31]="DANGEROUS_NODE_MODULES",e[e.NODE_GYP_INJECTED=32]="NODE_GYP_INJECTED",e[e.AUTHENTICATION_NOT_FOUND=33]="AUTHENTICATION_NOT_FOUND",e[e.INVALID_CONFIGURATION_KEY=34]="INVALID_CONFIGURATION_KEY",e[e.NETWORK_ERROR=35]="NETWORK_ERROR",e[e.LIFECYCLE_SCRIPT=36]="LIFECYCLE_SCRIPT",e[e.CONSTRAINTS_MISSING_FIELD=37]="CONSTRAINTS_MISSING_FIELD",e[e.CONSTRAINTS_INCOMPATIBLE_FIELD=38]="CONSTRAINTS_INCOMPATIBLE_FIELD",e[e.CONSTRAINTS_EXTRANEOUS_FIELD=39]="CONSTRAINTS_EXTRANEOUS_FIELD",e[e.CONSTRAINTS_INVALID_FIELD=40]="CONSTRAINTS_INVALID_FIELD",e[e.AUTHENTICATION_INVALID=41]="AUTHENTICATION_INVALID",e[e.PROLOG_UNKNOWN_ERROR=42]="PROLOG_UNKNOWN_ERROR",e[e.PROLOG_SYNTAX_ERROR=43]="PROLOG_SYNTAX_ERROR",e[e.PROLOG_EXISTENCE_ERROR=44]="PROLOG_EXISTENCE_ERROR",e[e.STACK_OVERFLOW_RESOLUTION=45]="STACK_OVERFLOW_RESOLUTION",e[e.AUTOMERGE_FAILED_TO_PARSE=46]="AUTOMERGE_FAILED_TO_PARSE",e[e.AUTOMERGE_IMMUTABLE=47]="AUTOMERGE_IMMUTABLE",e[e.AUTOMERGE_SUCCESS=48]="AUTOMERGE_SUCCESS",e[e.AUTOMERGE_REQUIRED=49]="AUTOMERGE_REQUIRED",e[e.DEPRECATED_CLI_SETTINGS=50]="DEPRECATED_CLI_SETTINGS",e[e.PLUGIN_NAME_NOT_FOUND=51]="PLUGIN_NAME_NOT_FOUND",e[e.INVALID_PLUGIN_REFERENCE=52]="INVALID_PLUGIN_REFERENCE",e[e.CONSTRAINTS_AMBIGUITY=53]="CONSTRAINTS_AMBIGUITY",e[e.CACHE_OUTSIDE_PROJECT=54]="CACHE_OUTSIDE_PROJECT",e[e.IMMUTABLE_INSTALL=55]="IMMUTABLE_INSTALL",e[e.IMMUTABLE_CACHE=56]="IMMUTABLE_CACHE",e[e.INVALID_MANIFEST=57]="INVALID_MANIFEST",e[e.PACKAGE_PREPARATION_FAILED=58]="PACKAGE_PREPARATION_FAILED",e[e.INVALID_RANGE_PEER_DEPENDENCY=59]="INVALID_RANGE_PEER_DEPENDENCY",e[e.INCOMPATIBLE_PEER_DEPENDENCY=60]="INCOMPATIBLE_PEER_DEPENDENCY",e[e.DEPRECATED_PACKAGE=61]="DEPRECATED_PACKAGE",e[e.INCOMPATIBLE_OS=62]="INCOMPATIBLE_OS",e[e.INCOMPATIBLE_CPU=63]="INCOMPATIBLE_CPU",e[e.FROZEN_ARTIFACT_EXCEPTION=64]="FROZEN_ARTIFACT_EXCEPTION",e[e.TELEMETRY_NOTICE=65]="TELEMETRY_NOTICE",e[e.PATCH_HUNK_FAILED=66]="PATCH_HUNK_FAILED",e[e.INVALID_CONFIGURATION_VALUE=67]="INVALID_CONFIGURATION_VALUE",e[e.UNUSED_PACKAGE_EXTENSION=68]="UNUSED_PACKAGE_EXTENSION",e[e.REDUNDANT_PACKAGE_EXTENSION=69]="REDUNDANT_PACKAGE_EXTENSION"}(t.MessageName||(t.MessageName={})),t.stringifyMessageName=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"YN"+e.toString(10).padStart(4,"0")}</span>},484:(e,t,r)=&gt;{"use strict";t.B=void 0;const n=r(6370).__importStar(r(6743));t.B=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this.resolvers=e.filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e)</span>}<span class="fstat-no" title="function not covered" ></span>su</span>pportsDescriptor(e,t){<span class="cstat-no" title="statement not covered" >return!!this.tryResolverByDescriptor(e,t)}<span class="fstat-no" title="function not covered" ></span>su</span>pportsLocator(e,t){<span class="cstat-no" title="statement not covered" >return!!this.tryResolverByLocator(e,t)}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldPersistResolution(e,t){<span class="cstat-no" title="statement not covered" >return this.getResolverByLocator(e,t).shouldPersistResolution(e,t)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndDescriptor(e,t,r){<span class="cstat-no" title="statement not covered" >return this.getResolverByDescriptor(e,r).bindDescriptor(e,t,r)}<span class="fstat-no" title="function not covered" ></span>ge</span>tResolutionDependencies(e,t){<span class="cstat-no" title="statement not covered" >return this.getResolverByDescriptor(e,t).getResolutionDependencies(e,t)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getCandidates(e,t,r){const n=<span class="cstat-no" title="statement not covered" >this.getResolverByDescriptor(e,r);<span class="cstat-no" title="statement not covered" ></span>return await n.getCandidates(e,t,r)}<span class="fstat-no" title="function not covered" ></span>as</span>ync getSatisfying(e,t,r){<span class="cstat-no" title="statement not covered" >return this.getResolverByDescriptor(e,r).getSatisfying(e,t,r)}<span class="fstat-no" title="function not covered" ></span>as</span>ync resolve(e,t){const r=<span class="cstat-no" title="statement not covered" >this.getResolverByLocator(e,t);<span class="cstat-no" title="statement not covered" ></span>return await r.resolve(e,t)}<span class="fstat-no" title="function not covered" ></span>tr</span>yResolverByDescriptor(e,t){const r=<span class="cstat-no" title="statement not covered" >this.resolvers.find(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.supportsDescriptor(e,t))</span>;<span class="cstat-no" title="statement not covered" ></span>return r||null}<span class="fstat-no" title="function not covered" ></span>ge</span>tResolverByDescriptor(e,t){const r=<span class="cstat-no" title="statement not covered" >this.resolvers.find(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.supportsDescriptor(e,t))</span>;<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw new Error(n.prettyDescriptor(t.project.configuration,e)+" isn't supported by any available resolver");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="fstat-no" title="function not covered" ></span>tr</span>yResolverByLocator(e,t){const r=<span class="cstat-no" title="statement not covered" >this.resolvers.find(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.supportsLocator(e,t))</span>;<span class="cstat-no" title="statement not covered" ></span>return r||null}<span class="fstat-no" title="function not covered" ></span>ge</span>tResolverByLocator(e,t){const r=<span class="cstat-no" title="statement not covered" >this.resolvers.find(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.supportsLocator(e,t))</span>;<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw new Error(n.prettyLocator(t.project.configuration,e)+" isn't supported by any available resolver");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>}},697:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.addLogFilterSupport=t.LogLevel=t.mark=t.json=t.prettyList=t.pretty=t.applyColor=t.applyStyle=t.tuple=t.supportsHyperlinks=t.supportsColor=t.Style=t.Type=void 0;const n=r(6370),s=r(4688),o=n.__importDefault(r(5882)),i=r(5579),a=n.__importStar(r(7654)),c=n.__importStar(r(6743)),u=r(3851);var l,p;!function(e){e.NO_HINT="NO_HINT",e.NULL="NULL",e.SCOPE="SCOPE",e.NAME="NAME",e.RANGE="RANGE",e.REFERENCE="REFERENCE",e.NUMBER="NUMBER",e.PATH="PATH",e.URL="URL",e.ADDED="ADDED",e.REMOVED="REMOVED",e.CODE="CODE",e.DURATION="DURATION",e.SIZE="SIZE",e.IDENT="IDENT",e.DESCRIPTOR="DESCRIPTOR",e.LOCATOR="LOCATOR",e.RESOLUTION="RESOLUTION",e.DEPENDENT="DEPENDENT",e.PACKAGE_EXTENSION="PACKAGE_EXTENSION"}(l=t.Type||(t.Type={})),function(e){e[e.BOLD=2]="BOLD"}(p=t.Style||(t.Style={}));const f=process.env.GITHUB_ACTIONS?<span class="branch-0 cbranch-no" title="branch not covered" >{level:2}:</span>o.default.supportsColor?{level:o.default.supportsColor.level}:<span class="branch-1 cbranch-no" title="branch not covered" >{level:0};</span>t.supportsColor=0!==f.level,t.supportsHyperlinks=t.supportsColor&amp;&amp;!process.env.GITHUB_ACTIONS;const h=new o.default.Instance(f),d=new Map([[l.NO_HINT,null],[l.NULL,["#a853b5",129]],[l.SCOPE,["#d75f00",166]],[l.NAME,["#d7875f",173]],[l.RANGE,["#00afaf",37]],[l.REFERENCE,["#87afff",111]],[l.NUMBER,["#ffd700",220]],[l.PATH,["#d75fd7",170]],[l.URL,["#d75fd7",170]],[l.ADDED,["#5faf00",70]],[l.REMOVED,["#d70000",160]],[l.CODE,["#87afff",111]],[l.SIZE,["#ffd700",220]]]),g={[l.NUMBER]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >""+t,</span>json:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e}</span>,[l.IDENT]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >c.prettyIdent(e,t),</span>json:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c.stringifyIdent(e)}</span>,[l.LOCATOR]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >c.prettyLocator(e,t),</span>json:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c.stringifyLocator(e)}</span>,[l.DESCRIPTOR]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >c.prettyDescriptor(e,t),</span>json:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c.stringifyDescriptor(e)}</span>,[l.RESOLUTION]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,{descriptor:t,locator:r})=&gt;<span class="cstat-no" title="statement not covered" >c.prettyResolution(e,t,r),</span>json:<span class="fstat-no" title="function not covered" >({</span>descriptor:e,locator:t})=&gt;(<span class="cstat-no" title="statement not covered" >{descriptor:c.stringifyDescriptor(e),locator:null!==t?c.stringifyLocator(t):null})</span>},[l.DEPENDENT]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,{locator:t,descriptor:r})=&gt;<span class="cstat-no" title="statement not covered" >c.prettyDependent(e,t,r),</span>json:<span class="fstat-no" title="function not covered" >({</span>locator:e,descriptor:t})=&gt;(<span class="cstat-no" title="statement not covered" >{locator:c.stringifyLocator(e),descriptor:c.stringifyDescriptor(t)})</span>},[l.PACKAGE_EXTENSION]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >switch(t.type){case u.PackageExtensionType.Dependency:<span class="cstat-no" title="statement not covered" >return`${c.prettyIdent(e,t.parentDescriptor)} ➤ ${y(e,"dependencies",l.CODE)} ➤ ${c.prettyIdent(e,t.descriptor)}`;c</span>ase u.PackageExtensionType.PeerDependency:<span class="cstat-no" title="statement not covered" >return`${c.prettyIdent(e,t.parentDescriptor)} ➤ ${y(e,"peerDependencies",l.CODE)} ➤ ${c.prettyIdent(e,t.descriptor)}`;c</span>ase u.PackageExtensionType.PeerDependencyMeta:<span class="cstat-no" title="statement not covered" >return`${c.prettyIdent(e,t.parentDescriptor)} ➤ ${y(e,"peerDependenciesMeta",l.CODE)} ➤ ${c.prettyIdent(e,c.parseIdent(t.selector))} ➤ ${y(e,t.key,l.CODE)}`;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Assertion failed: Unsupported package extension type: "+t.type)}</span>}</span>,json:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >switch(e.type){case u.PackageExtensionType.Dependency:<span class="cstat-no" title="statement not covered" >return`${c.stringifyIdent(e.parentDescriptor)} &gt; ${c.stringifyIdent(e.descriptor)}`;c</span>ase u.PackageExtensionType.PeerDependency:<span class="cstat-no" title="statement not covered" >return`${c.stringifyIdent(e.parentDescriptor)} &gt;&gt; ${c.stringifyIdent(e.descriptor)}`;c</span>ase u.PackageExtensionType.PeerDependencyMeta:<span class="cstat-no" title="statement not covered" >return`${c.stringifyIdent(e.parentDescriptor)} &gt;&gt; ${e.selector} / ${e.key}`;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Assertion failed: Unsupported package extension type: "+e.type)}</span>}</span>},[l.DURATION]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(t&gt;6e4){const e=<span class="cstat-no" title="statement not covered" >Math.floor(t/1e3/60),</span>r=<span class="cstat-no" title="statement not covered" >Math.ceil((t-60*e*1e3)/1e3);<span class="cstat-no" title="statement not covered" ></span>return 0===r?e+"m":`${e}m ${r}s`}</span>{</span>const e=<span class="cstat-no" title="statement not covered" >Math.floor(t/1e3),</span>r=<span class="cstat-no" title="statement not covered" >t-1e3*e;<span class="cstat-no" title="statement not covered" ></span>return 0===r?e+"s":`${e}s ${r}ms`}</span>},json:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e}</span>,[l.SIZE]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >["KB","MB","GB","TB"];</span>let n=<span class="cstat-no" title="statement not covered" >r.length;<span class="cstat-no" title="statement not covered" ></span>for(;n&gt;1&amp;&amp;t&lt;1024**n;)<span class="cstat-no" title="statement not covered" >n-=1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >1024**n;<span class="cstat-no" title="statement not covered" ></span>return y(e,`${Math.floor(100*t/s)/100} ${r[n-1]}`,l.NUMBER)}</span>,json:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e}</span>,[l.PATH]:{pretty:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >y(e,s.npath.fromPortablePath(t),l.PATH),</span>json:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >s.npath.fromPortablePath(e)}</span>};function <span class="fstat-no" title="function not covered" >y(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(!e.get("enableColors"))<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >d.get(r);<span class="cstat-no" title="statement not covered" ></span>if(null===n)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >void 0===n?r:f.level&gt;=3?n[0]:n[1],</span>o=<span class="cstat-no" title="statement not covered" >"number"==typeof s?h.ansi256(s):s.startsWith("#")?h.hex(s):h[s];<span class="cstat-no" title="statement not covered" ></span>if("function"!=typeof o)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid format type "+s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o(t)}</span>function <span class="fstat-no" title="function not covered" >_(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(null===t)<span class="cstat-no" title="statement not covered" >return y(e,"null",l.NULL);<span class="cstat-no" title="statement not covered" >i</span></span>f(Object.prototype.hasOwnProperty.call(g,r)){<span class="cstat-no" title="statement not covered" >return g[r].pretty(e,t)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("string"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new Error("Assertion failed: Expected the value to be a string, got "+typeof t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn y(e,t,r)}</span>var E;t.tuple=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return[t,e]}</span>,t.applyStyle=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >return e.get("enableColors")?(r&amp;p.BOLD&amp;&amp;(t=o.default.bold(t)),t):t}</span>,t.applyColor=y,t.pretty=_,t.prettyList=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,{separator:n=<span class="branch-0 cbranch-no" title="branch not covered" >", "}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return[...t].map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >_(e,t,r))</span>.join(n)}</span>,t.json=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(null===e)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >i</span></span>f(Object.prototype.hasOwnProperty.call(g,t))<span class="cstat-no" title="statement not covered" >return a.overrideType(t),g[t].json(e);<span class="cstat-no" title="statement not covered" >i</span></span>f("string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new Error("Assertion failed: Expected the value to be a string, got "+typeof e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,t.mark=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{Check:y(e,"✓","green"),Cross:y(e,"✘","red"),Question:y(e,"?","cyan")}}</span>,function(e){e.Error="error",e.Warning="warning",e.Info="info",e.Discard="discard"}(E=t.LogLevel||(t.LogLevel={})),t.addLogFilterSupport=<span class="fstat-no" title="function not covered" >fu</span>nction(e,{configuration:t}){const r=<span class="cstat-no" title="statement not covered" >t.get("logFilters"),</span>n=<span class="cstat-no" title="statement not covered" >new Map,</span>s=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>for(const e of r){const t=<span class="cstat-no" title="statement not covered" >e.get("level");<span class="cstat-no" title="statement not covered" ></span>if(void 0===t)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >e.get("code");<span class="cstat-no" title="statement not covered" ></span>void 0!==r&amp;&amp;n.set(r,t);c</span>onst o=<span class="cstat-no" title="statement not covered" >e.get("text");<span class="cstat-no" title="statement not covered" ></span>void 0!==o&amp;&amp;s.set(o,t)}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >e.reportInfo,</span>c=<span class="cstat-no" title="statement not covered" >e.reportWarning,</span>u=<span class="cstat-no" title="statement not covered" >e.reportError,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,l){<span class="cstat-no" title="statement not covered" >switch((<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(null===e||e===i.MessageName.UNNAMED)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >i</span></span>f(s.size&gt;0){const e=<span class="cstat-no" title="statement not covered" >s.get(o.default.reset(t));<span class="cstat-no" title="statement not covered" ></span>if(void 0!==e)<span class="cstat-no" title="statement not covered" >return null!=e?e:r}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(n.size&gt;0){const t=<span class="cstat-no" title="statement not covered" >n.get(i.stringifyMessageName(e));<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t)<span class="cstat-no" title="statement not covered" >return null!=t?t:r}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>)(t,r,l)){case E.Info:<span class="cstat-no" title="statement not covered" >a.call(e,t,r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase E.Warning:<span class="cstat-no" title="statement not covered" >c.call(e,null!=t?t:i.MessageName.UNNAMED,r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase E.Error:<span class="cstat-no" title="statement not covered" >u.call(e,null!=t?t:i.MessageName.UNNAMED,r)}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>e.reportInfo=<span class="fstat-no" title="function not covered" >fu</span>nction(...e){<span class="cstat-no" title="statement not covered" >return l(this,...e,E.Info)}</span>,e.reportWarning=<span class="fstat-no" title="function not covered" >fu</span>nction(...e){<span class="cstat-no" title="statement not covered" >return l(this,...e,E.Warning)}</span>,e.reportError=<span class="fstat-no" title="function not covered" >fu</span>nction(...e){<span class="cstat-no" title="statement not covered" >return l(this,...e,E.Error)}</span>}</span>},1995:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.checksumPattern=t.checksumFile=t.makeHash=void 0;const n=r(6370),s=r(4688),o=r(6417),i=n.__importDefault(r(8592));t.makeHash=<span class="fstat-no" title="function not covered" >fu</span>nction(...e){const t=<span class="cstat-no" title="statement not covered" >o.createHash("sha512");<span class="cstat-no" title="statement not covered" ></span>for(const r of e)<span class="cstat-no" title="statement not covered" >t.update(r||"");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.digest("hex")}</span>,t.checksumFile=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >o.createHash("sha512"),</span>i=<span class="cstat-no" title="statement not covered" >s.xfs.createReadStream(e);<span class="cstat-no" title="statement not covered" ></span>i.on("data",<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.update(e)}</span>),i.on("error",<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r(e)}</span>),i.on("end",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t(n.digest("hex"))}</span>)}</span>)}</span>,t.checksumPattern=<span class="fstat-no" title="function not covered" >as</span>ync function(e,{cwd:t}){const r=<span class="cstat-no" title="statement not covered" >(await i.default(e,{cwd:s.npath.fromPortablePath(t),expandDirectories:!1,onlyDirectories:!0,unique:!0})).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e+"/**/*")</span>,</span>n=<span class="cstat-no" title="statement not covered" >await i.default([e,...r],{cwd:s.npath.fromPortablePath(t),expandDirectories:!1,onlyFiles:!1,unique:!0});<span class="cstat-no" title="statement not covered" ></span>n.sort();c</span>onst a=<span class="cstat-no" title="statement not covered" >await Promise.all(n.map(<span class="fstat-no" title="function not covered" >as</span>ync e=&gt;{const t=<span class="cstat-no" title="statement not covered" >[Buffer.from(e)],</span>r=<span class="cstat-no" title="statement not covered" >s.npath.toPortablePath(e),</span>n=<span class="cstat-no" title="statement not covered" >await s.xfs.lstatPromise(r);<span class="cstat-no" title="statement not covered" ></span>return n.isSymbolicLink()?t.push(Buffer.from(await s.xfs.readlinkPromise(r))):n.isFile()&amp;&amp;t.push(await s.xfs.readFilePromise(r)),t.join("\0")}</span>)),</span>c=<span class="cstat-no" title="statement not covered" >o.createHash("sha512");<span class="cstat-no" title="statement not covered" ></span>for(const e of a)<span class="cstat-no" title="statement not covered" >c.update(e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn c.digest("hex")}</span>},7654:(e,t,r)=&gt;{"use strict";e=r.nmd(e),Object.defineProperty(t,"__esModule",{value:!0}),t.tryParseOptionalBoolean=t.parseOptionalBoolean=t.parseBoolean=t.replaceEnvVariables=t.buildIgnorePattern=t.sortMap=t.dynamicRequireNoCache=t.dynamicRequire=t.DefaultStream=t.BufferStream=t.bufferStream=t.prettifySyncErrors=t.prettifyAsyncErrors=t.releaseAfterUseAsync=t.getMapWithDefault=t.getSetWithDefault=t.getArrayWithDefault=t.getFactoryWithDefault=t.convertMapsToIndexableObjects=t.isIndexableObject=t.mapAndFind=t.mapAndFilter=t.validateEnum=t.assertNever=t.overrideType=t.escapeRegExp=void 0;const n=r(6370),s=r(4688),o=r(8042),i=n.__importDefault(r(2401)),a=r(2413);function <span class="fstat-no" title="function not covered" >c(</span>e,t){const r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const n of e){const e=<span class="cstat-no" title="statement not covered" >t(n);<span class="cstat-no" title="statement not covered" ></span>e!==u&amp;&amp;r.push(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>t.escapeRegExp=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&amp;")}</span>,t.overrideType=<span class="fstat-no" title="function not covered" >fu</span>nction(e){},t.assertNever=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >throw new Error(`Assertion failed: Unexpected object '${e}'`)}</span>,t.validateEnum=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(!Object.values(e).includes(t))<span class="cstat-no" title="statement not covered" >throw new Error("Assertion failed: Invalid value for enumeration");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,t.mapAndFilter=c;const u=Symbol();function <span class="fstat-no" title="function not covered" >l(</span>e,t){<span class="cstat-no" title="statement not covered" >for(const r of e){const e=<span class="cstat-no" title="statement not covered" >t(r);<span class="cstat-no" title="statement not covered" ></span>if(e!==p)<span class="cstat-no" title="statement not covered" >return e}</span></span>}</span>c.skip=u,t.mapAndFind=l;const p=Symbol();function <span class="fstat-no" title="function not covered" >f(</span>e){<span class="cstat-no" title="statement not covered" >return"object"==typeof e&amp;&amp;null!==e}</span>l.skip=p,t.isIndexableObject=f,t.convertMapsToIndexableObjects=function <span class="fstat-no" title="function not covered" >e(</span>t){<span class="cstat-no" title="statement not covered" >if(t instanceof Map&amp;&amp;(t=Object.fromEntries(t)),f(t))<span class="cstat-no" title="statement not covered" >for(const r of Object.keys(t)){const n=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>f(n)&amp;&amp;(t[r]=e(n))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn t}</span>,t.getFactoryWithDefault=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){let n=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>return void 0===n&amp;&amp;e.set(t,n=r()),n}</span>,t.getArrayWithDefault=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let r=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>return void 0===r&amp;&amp;e.set(t,r=[]),r}</span>,t.getSetWithDefault=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let r=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>return void 0===r&amp;&amp;e.set(t,r=new Set),r}</span>,t.getMapWithDefault=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let r=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>return void 0===r&amp;&amp;e.set(t,r=new Map),r}</span>,t.releaseAfterUseAsync=<span class="fstat-no" title="function not covered" >as</span>ync function(e,t){<span class="cstat-no" title="statement not covered" >if(null==t)<span class="cstat-no" title="statement not covered" >return await e();<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return await e()}</span>finally{<span class="cstat-no" title="statement not covered" >await t()}</span>}</span>,t.prettifyAsyncErrors=<span class="fstat-no" title="function not covered" >as</span>ync function(e,t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await e()}</span>catch(e){<span class="cstat-no" title="statement not covered" >throw e.message=t(e.message),e}</span>}</span>,t.prettifySyncErrors=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return e()}</span>catch(e){<span class="cstat-no" title="statement not covered" >throw e.message=t(e.message),e}</span>}</span>,t.bufferStream=<span class="fstat-no" title="function not covered" >as</span>ync function(e){<span class="cstat-no" title="statement not covered" >return await new Promise(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e.on("error",<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r(e)}</span>),e.on("data",<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.push(e)}</span>),e.on("end",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t(Buffer.concat(n))}</span>)}</span>)}</span>;class h extends a.Transform{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this.chunks=[]}<span class="fstat-no" title="function not covered" ></span>_t</span>ransform(e,t,r){<span class="cstat-no" title="statement not covered" >if("buffer"!==t||!Buffer.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new Error("Assertion failed: BufferStream only accept buffers");<span class="cstat-no" title="statement not covered" >t</span></span>his.chunks.push(e),r(null,null)}<span class="fstat-no" title="function not covered" ></span>_f</span>lush(e){<span class="cstat-no" title="statement not covered" >e(null,Buffer.concat(this.chunks))}</span>}t.BufferStream=h;class d extends a.Transform{<span class="fstat-no" title="function not covered" >co</span>nstructor(e=<span class="branch-0 cbranch-no" title="branch not covered" >Buffer.alloc(0))</span>{<span class="cstat-no" title="statement not covered" >super(),this.active=!0,this.ifEmpty=e}<span class="fstat-no" title="function not covered" ></span>_t</span>ransform(e,t,r){<span class="cstat-no" title="statement not covered" >if("buffer"!==t||!Buffer.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new Error("Assertion failed: DefaultStream only accept buffers");<span class="cstat-no" title="statement not covered" >t</span></span>his.active=!1,r(null,e)}<span class="fstat-no" title="function not covered" ></span>_f</span>lush(e){<span class="cstat-no" title="statement not covered" >this.active&amp;&amp;this.ifEmpty.length&gt;0&amp;&amp;e(null,this.ifEmpty)}</span>}function <span class="fstat-no" title="function not covered" >g(</span>e){<span class="cstat-no" title="statement not covered" >return"undefined"!=typeof require?require(e):r(449)(e)}</span>function <span class="fstat-no" title="function not covered" >y(</span>e){<span class="cstat-no" title="statement not covered" >switch(e){case"true":case"1":case 1:case!0:<span class="cstat-no" title="statement not covered" >return!0;c</span>ase"false":case"0":case 0:case!1:<span class="cstat-no" title="statement not covered" >return!1;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error(`Couldn't parse "${e}" as a boolean`)}</span>}</span>function <span class="fstat-no" title="function not covered" >_(</span>e){<span class="cstat-no" title="statement not covered" >return void 0===e?e:y(e)}</span>t.DefaultStream=d,t.dynamicRequire=g,t.dynamicRequireNoCache=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const n=<span class="cstat-no" title="statement not covered" >s.npath.fromPortablePath(t),</span>o=<span class="cstat-no" title="statement not covered" >r.c[n];</span>let i;<span class="cstat-no" title="statement not covered" >delete r.c[n];<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >i=g(n);c</span>onst t=<span class="cstat-no" title="statement not covered" >r.c[n],</span>s=<span class="cstat-no" title="statement not covered" >e.children.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>-1!==s&amp;&amp;e.children.splice(s,1)}</span>finally{<span class="cstat-no" title="statement not covered" >r.c[n]=o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>,t.sortMap=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const r=<span class="cstat-no" title="statement not covered" >Array.from(e);<span class="cstat-no" title="statement not covered" ></span>Array.isArray(t)||(t=[t]);c</span>onst n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const e of t)<span class="cstat-no" title="statement not covered" >n.push(r.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e(t))</span>);c</span></span>onst s=<span class="cstat-no" title="statement not covered" >r.map(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >t)</span>;<span class="cstat-no" title="statement not covered" ></span>return s.sort(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >for(const r of n){const n=<span class="cstat-no" title="statement not covered" >r[e]&lt;r[t]?-1:r[e]&gt;r[t]?1:0;<span class="cstat-no" title="statement not covered" ></span>if(0!==n)<span class="cstat-no" title="statement not covered" >return n}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn 0}</span>),s.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >r[e])</span>}</span>,t.buildIgnorePattern=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0===e.length?null:e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >`(${i.default.makeRe(e,{windows:!1}).source})`)</span>.join("|")}</span>,t.replaceEnvVariables=<span class="fstat-no" title="function not covered" >fu</span>nction(e,{env:t}){<span class="cstat-no" title="statement not covered" >return e.replace(/\${(?&lt;variableName&gt;[\d\w_]+)(?&lt;colon&gt;:)?(?:-(?&lt;fallback&gt;[^}]*))?}/g,<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;{const{variableName:r,colon:n,fallback:s}=<span class="cstat-no" title="statement not covered" >e[e.length-1],</span>i=<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,r),</span>a=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >i</span></span>f(i&amp;&amp;!n)<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >i</span></span>f(null!=s)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >t</span></span>hrow new o.UsageError(`Environment variable not found (${r})`)}</span>)}</span>,t.parseBoolean=y,t.parseOptionalBoolean=_,t.tryParseOptionalBoolean=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return _(e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return null}</span>}</span>},6743:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getIdentVendorPath=t.prettyDependent=t.prettyResolution=t.prettyWorkspace=t.sortDescriptors=t.prettyLocatorNoColors=t.prettyLocator=t.prettyReference=t.prettyDescriptor=t.prettyRange=t.prettyIdent=t.slugifyLocator=t.slugifyIdent=t.stringifyLocator=t.stringifyDescriptor=t.stringifyIdent=t.requirableIdent=t.convertToManifestRange=t.makeRange=t.parseFileStyleRange=t.parseRange=t.tryParseLocator=t.parseLocator=t.tryParseDescriptor=t.parseDescriptor=t.tryParseIdent=t.parseIdent=t.areVirtualPackagesEquivalent=t.areLocatorsEqual=t.areDescriptorsEqual=t.areIdentsEqual=t.bindLocator=t.bindDescriptor=t.devirtualizeLocator=t.devirtualizeDescriptor=t.isVirtualLocator=t.isVirtualDescriptor=t.virtualizePackage=t.virtualizeDescriptor=t.copyPackage=t.renamePackage=t.convertPackageToLocator=t.convertLocatorToDescriptor=t.convertDescriptorToLocator=t.convertToIdent=t.makeLocator=t.makeDescriptor=t.makeIdent=void 0;const n=r(6370),s=r(4688),o=n.__importDefault(r(1191)),i=n.__importDefault(r(9513)),a=n.__importStar(r(697)),c=n.__importStar(r(1995)),u=n.__importStar(r(7654)),l=n.__importStar(r(6743));function <span class="fstat-no" title="function not covered" >p(</span>e,t){<span class="cstat-no" title="statement not covered" >if(null==e?void 0:e.startsWith("@"))<span class="cstat-no" title="statement not covered" >throw new Error("Invalid scope: don't prefix it with '@'");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{identHash:c.makeHash(e,t),scope:e,name:t}}</span>function <span class="fstat-no" title="function not covered" >f(</span>e,t){<span class="cstat-no" title="statement not covered" >return{identHash:e.identHash,scope:e.scope,name:e.name,descriptorHash:c.makeHash(e.identHash,t),range:t}}</span>function <span class="fstat-no" title="function not covered" >h(</span>e,t){<span class="cstat-no" title="statement not covered" >return{identHash:e.identHash,scope:e.scope,name:e.name,locatorHash:c.makeHash(e.identHash,t),reference:t}}</span>function <span class="fstat-no" title="function not covered" >d(</span>e,t){<span class="cstat-no" title="statement not covered" >return{identHash:t.identHash,scope:t.scope,name:t.name,locatorHash:t.locatorHash,reference:t.reference,version:e.version,languageName:e.languageName,linkType:e.linkType,dependencies:new Map(e.dependencies),peerDependencies:new Map(e.peerDependencies),dependenciesMeta:new Map(e.dependenciesMeta),peerDependenciesMeta:new Map(e.peerDependenciesMeta),bin:new Map(e.bin)}}</span>function <span class="fstat-no" title="function not covered" >g(</span>e){<span class="cstat-no" title="statement not covered" >return e.range.startsWith("virtual:")}</span>function <span class="fstat-no" title="function not covered" >y(</span>e){<span class="cstat-no" title="statement not covered" >return e.reference.startsWith("virtual:")}</span>function <span class="fstat-no" title="function not covered" >_(</span>e){<span class="cstat-no" title="statement not covered" >if(!g(e))<span class="cstat-no" title="statement not covered" >throw new Error("Not a virtual descriptor");<span class="cstat-no" title="statement not covered" >r</span></span>eturn f(e,e.range.replace(/^[^#]*#/,""))}</span>function <span class="fstat-no" title="function not covered" >E(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.identHash===t.identHash}</span>function <span class="fstat-no" title="function not covered" >m(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.descriptorHash===t.descriptorHash}</span>function <span class="fstat-no" title="function not covered" >b(</span>e){const t=<span class="cstat-no" title="statement not covered" >e.match(/^(?:@([^/]+?)\/)?([^/]+)$/);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst[,r,n]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return p(void 0!==r?r:null,n)}</span>function <span class="fstat-no" title="function not covered" >v(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{const r=<span class="cstat-no" title="statement not covered" >t?e.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/):e.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst[,n,s,o]=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>if("unknown"===o)<span class="cstat-no" title="statement not covered" >throw new Error(`Invalid range (${e})`);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >void 0!==o?o:"unknown";<span class="cstat-no" title="statement not covered" ></span>return f(p(void 0!==n?n:null,s),i)}</span>function <span class="fstat-no" title="function not covered" >S(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{const r=<span class="cstat-no" title="statement not covered" >R(e,t);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw new Error(`Invalid locator (${e})`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >R(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{const r=<span class="cstat-no" title="statement not covered" >t?e.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))$/):e.match(/^(?:@([^/]+?)\/)?([^/]+?)(?:@(.+))?$/);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst[,n,s,o]=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>if("unknown"===o)<span class="cstat-no" title="statement not covered" >throw new Error(`Invalid reference (${e})`);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >void 0!==o?o:"unknown";<span class="cstat-no" title="statement not covered" ></span>return h(p(void 0!==n?n:null,s),i)}</span>function <span class="fstat-no" title="function not covered" >A(</span>e,t){const r=<span class="cstat-no" title="statement not covered" >e.match(/^([^#:]*:)?((?:(?!::)[^#])*)(?:#((?:(?!::).)*))?(?:::(.*))?$/);<span class="cstat-no" title="statement not covered" ></span>if(null===r)<span class="cstat-no" title="statement not covered" >throw new Error(`Invalid range (${e})`);c</span></span>onst n=<span class="cstat-no" title="statement not covered" >void 0!==r[1]?r[1]:null;<span class="cstat-no" title="statement not covered" ></span>if("string"==typeof(null==t?void 0:t.requireProtocol)&amp;&amp;n!==t.requireProtocol)<span class="cstat-no" title="statement not covered" >throw new Error(`Invalid protocol (${n})`);<span class="cstat-no" title="statement not covered" >i</span></span>f((null==t?void 0:t.requireProtocol)&amp;&amp;null===n)<span class="cstat-no" title="statement not covered" >throw new Error(`Missing protocol (${n})`);c</span></span>onst s=<span class="cstat-no" title="statement not covered" >void 0!==r[3]?decodeURIComponent(r[2]):null;<span class="cstat-no" title="statement not covered" ></span>if((null==t?void 0:t.requireSource)&amp;&amp;null===s)<span class="cstat-no" title="statement not covered" >throw new Error(`Missing source (${e})`);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >void 0!==r[3]?decodeURIComponent(r[3]):decodeURIComponent(r[2]);<span class="cstat-no" title="statement not covered" ></span>return{protocol:n,source:s,selector:(null==t?void 0:t.parseSelector)?o.default.parse(i):i,params:void 0!==r[4]?o.default.parse(r[4]):null}}</span>function <span class="fstat-no" title="function not covered" >w(</span>e){<span class="cstat-no" title="statement not covered" >return e=(e=(e=e.replace(/%/g,"%25")).replace(/:/g,"%3A")).replace(/#/g,"%23")}</span>function <span class="fstat-no" title="function not covered" >O(</span>{protocol:e,source:t,selector:r,params:n}){let s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return null!==e&amp;&amp;(s+=""+e),null!==t&amp;&amp;(s+=w(t)+"#"),s+=w(r),<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null!==e&amp;&amp;Object.entries(e).length&gt;0}</span>(n)&amp;&amp;(s+="::"+o.default.stringify(n)),s}</span>function <span class="fstat-no" title="function not covered" >T(</span>e){<span class="cstat-no" title="statement not covered" >return e.scope?`@${e.scope}/${e.name}`:""+e.name}</span>function <span class="fstat-no" title="function not covered" >C(</span>e){<span class="cstat-no" title="statement not covered" >return e.scope?`@${e.scope}/${e.name}`:""+e.name}</span>function <span class="fstat-no" title="function not covered" >P(</span>e){<span class="cstat-no" title="statement not covered" >return null!==e.scope?`@${e.scope}-${e.name}`:e.name}</span>function <span class="fstat-no" title="function not covered" >k(</span>e,t){<span class="cstat-no" title="statement not covered" >return t.scope?`${a.pretty(e,`@${t.scope}/`,a.Type.SCOPE)}${a.pretty(e,t.name,a.Type.NAME)}`:""+a.pretty(e,t.name,a.Type.NAME)}</span>function <span class="fstat-no" title="function not covered" >x(</span>e){<span class="cstat-no" title="statement not covered" >if(e.startsWith("virtual:")){<span class="cstat-no" title="statement not covered" >return`${x(e.substr(e.indexOf("#")+1))} [${e.substr("virtual:".length,5)}]`}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.replace(/\?.*/,"?[...]")}</span>function <span class="fstat-no" title="function not covered" >N(</span>e,t){<span class="cstat-no" title="statement not covered" >return""+a.pretty(e,x(t),a.Type.RANGE)}</span>function <span class="fstat-no" title="function not covered" >I(</span>e,t){<span class="cstat-no" title="statement not covered" >return""+a.pretty(e,x(t),a.Type.REFERENCE)}</span>function <span class="fstat-no" title="function not covered" >L(</span>e,t){<span class="cstat-no" title="statement not covered" >return`${k(e,t)}${a.pretty(e,"@",a.Type.REFERENCE)}${I(e,t.reference)}`}</span>t.makeIdent=p,t.makeDescriptor=f,t.makeLocator=h,t.convertToIdent=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{identHash:e.identHash,scope:e.scope,name:e.name}}</span>,t.convertDescriptorToLocator=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{identHash:e.identHash,scope:e.scope,name:e.name,locatorHash:e.descriptorHash,reference:e.range}}</span>,t.convertLocatorToDescriptor=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{identHash:e.identHash,scope:e.scope,name:e.name,descriptorHash:e.locatorHash,range:e.reference}}</span>,t.convertPackageToLocator=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{identHash:e.identHash,scope:e.scope,name:e.name,locatorHash:e.locatorHash,reference:e.reference}}</span>,t.renamePackage=d,t.copyPackage=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return d(e,e)}</span>,t.virtualizeDescriptor=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(t.includes("#"))<span class="cstat-no" title="statement not covered" >throw new Error("Invalid entropy");<span class="cstat-no" title="statement not covered" >r</span></span>eturn f(e,`virtual:${t}#${e.range}`)}</span>,t.virtualizePackage=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(t.includes("#"))<span class="cstat-no" title="statement not covered" >throw new Error("Invalid entropy");<span class="cstat-no" title="statement not covered" >r</span></span>eturn d(e,h(e,`virtual:${t}#${e.reference}`))}</span>,t.isVirtualDescriptor=g,t.isVirtualLocator=y,t.devirtualizeDescriptor=_,t.devirtualizeLocator=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!y(e))<span class="cstat-no" title="statement not covered" >throw new Error("Not a virtual descriptor");<span class="cstat-no" title="statement not covered" >r</span></span>eturn h(e,e.reference.replace(/^[^#]*#/,""))}</span>,t.bindDescriptor=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.range.includes("::")?e:f(e,`${e.range}::${o.default.stringify(t)}`)}</span>,t.bindLocator=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.reference.includes("::")?e:h(e,`${e.reference}::${o.default.stringify(t)}`)}</span>,t.areIdentsEqual=E,t.areDescriptorsEqual=m,t.areLocatorsEqual=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.locatorHash===t.locatorHash}</span>,t.areVirtualPackagesEquivalent=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(!y(e))<span class="cstat-no" title="statement not covered" >throw new Error("Invalid package type");<span class="cstat-no" title="statement not covered" >i</span></span>f(!y(t))<span class="cstat-no" title="statement not covered" >throw new Error("Invalid package type");<span class="cstat-no" title="statement not covered" >i</span></span>f(!E(e,t))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.dependencies.size!==t.dependencies.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(const r of e.dependencies.values()){const e=<span class="cstat-no" title="statement not covered" >t.dependencies.get(r.identHash);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!m(r,e))<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}</span>,t.parseIdent=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >b(e);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >throw new Error(`Invalid ident (${e})`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,t.tryParseIdent=b,t.parseDescriptor=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{const r=<span class="cstat-no" title="statement not covered" >v(e,t);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >throw new Error(`Invalid descriptor (${e})`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>,t.tryParseDescriptor=v,t.parseLocator=S,t.tryParseLocator=R,t.parseRange=A,t.parseFileStyleRange=<span class="fstat-no" title="function not covered" >fu</span>nction(e,{protocol:t}){const{selector:r,params:n}=<span class="cstat-no" title="statement not covered" >A(e,{requireProtocol:t,requireBindings:!0});<span class="cstat-no" title="statement not covered" ></span>if("string"!=typeof n.locator)<span class="cstat-no" title="statement not covered" >throw new Error("Assertion failed: Invalid bindings for "+e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{parentLocator:S(n.locator,!0),path:r}}</span>,t.makeRange=O,t.convertToManifestRange=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const{params:t,protocol:r,source:n,selector:s}=<span class="cstat-no" title="statement not covered" >A(e);<span class="cstat-no" title="statement not covered" ></span>for(const e in t)<span class="cstat-no" title="statement not covered" >e.startsWith("__")&amp;&amp;delete t[e];<span class="cstat-no" title="statement not covered" >r</span></span>eturn O({protocol:r,source:n,params:t,selector:s})}</span>,t.requirableIdent=T,t.stringifyIdent=C,t.stringifyDescriptor=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.scope?`@${e.scope}/${e.name}@${e.range}`:`${e.name}@${e.range}`}</span>,t.stringifyLocator=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.scope?`@${e.scope}/${e.name}@${e.reference}`:`${e.name}@${e.reference}`}</span>,t.slugifyIdent=P,t.slugifyLocator=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const{protocol:t,selector:r}=<span class="cstat-no" title="statement not covered" >A(e.reference),</span>n=<span class="cstat-no" title="statement not covered" >null!==t?t.replace(/:$/,""):"exotic",</span>o=<span class="cstat-no" title="statement not covered" >i.default.valid(r),</span>a=<span class="cstat-no" title="statement not covered" >null!==o?`${n}-${o}`:""+n,</span>c=(<span class="cstat-no" title="statement not covered" >e.scope,`${P(e)}-${a}-${e.locatorHash.slice(0,10)}`)</span>;<span class="cstat-no" title="statement not covered" >return s.toFilename(c)}</span>,t.prettyIdent=k,t.prettyRange=N,t.prettyDescriptor=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return`${k(e,t)}${a.pretty(e,"@",a.Type.RANGE)}${N(e,t.range)}`}</span>,t.prettyReference=I,t.prettyLocator=L,t.prettyLocatorNoColors=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return`${C(e)}@${x(e.reference)}`}</span>,t.sortDescriptors=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return u.sortMap(e,[<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >C(e),<span class="fstat-no" title="function not covered" ></span>e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.range]</span>)}</span>,t.prettyWorkspace=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return k(e,t.locator)}</span>,t.prettyResolution=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){const n=<span class="cstat-no" title="statement not covered" >g(t)?_(t):t;<span class="cstat-no" title="statement not covered" ></span>return null===r?`${l.prettyDescriptor(e,n)} → ${a.mark(e).Cross}`:n.identHash===r.identHash?`${l.prettyDescriptor(e,n)} → ${I(e,r.reference)}`:`${l.prettyDescriptor(e,n)} → ${L(e,r)}`}</span>,t.prettyDependent=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >return null===r?""+L(e,t):`${L(e,t)} (via ${l.prettyRange(e,r.range)})`}</span>,t.getIdentVendorPath=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"node_modules/"+T(e)}</span>},3851:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PackageExtensionStatus=t.PackageExtensionType=t.LinkType=void 0,function(e){e.HARD="HARD",e.SOFT="SOFT"}(t.LinkType||(t.LinkType={})),function(e){e.Dependency="Dependency",e.PeerDependency="PeerDependency",e.PeerDependencyMeta="PeerDependencyMeta"}(t.PackageExtensionType||(t.PackageExtensionType={})),function(e){e.Inactive="inactive",e.Redundant="redundant",e.Active="active"}(t.PackageExtensionStatus||(t.PackageExtensionStatus={}))},449:<span class="fstat-no" title="function not covered" >e=</span>&gt;{function <span class="fstat-no" title="function not covered" >t(</span>e){var t=<span class="cstat-no" title="statement not covered" >new Error("Cannot find module '"+e+"'");<span class="cstat-no" title="statement not covered" ></span>throw t.code="MODULE_NOT_FOUND",t}<span class="cstat-no" title="statement not covered" ></span>t.keys=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[],</span>t.resolve=t,t.id=449,e.exports=t}</span>,7652:(e,t,r)=&gt;{"use strict";e=r.nmd(e);const n=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..r)=&gt;<span class="cstat-no" title="statement not covered" >`[${e(...r)+t}m`,</span></span>s=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e(...r);<span class="cstat-no" title="statement not covered" ></span>return`[${38+t};5;${n}m`}</span>,</span>o=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e(...r);<span class="cstat-no" title="statement not covered" ></span>return`[${38+t};2;${n[0]};${n[1]};${n[2]}m`}</span>,</span>i=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >[e,t,r],</span>c=(e,t,r)=&gt;{Object.defineProperty(e,t,{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;{const n=<span class="cstat-no" title="statement not covered" >r();<span class="cstat-no" title="statement not covered" ></span>return Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0}),n}</span>,enumerable:!0,configurable:!0})};let u;const l=<span class="fstat-no" title="function not covered" >(e</span>,t,n,s)=&gt;{<span class="cstat-no" title="statement not covered" >void 0===u&amp;&amp;(u=r(2744));c</span>onst o=<span class="cstat-no" title="statement not covered" >s?10:0,</span>i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const[r,s]of Object.entries(u)){const a=<span class="cstat-no" title="statement not covered" >"ansi16"===r?"ansi":r;<span class="cstat-no" title="statement not covered" ></span>r===t?i[a]=e(n,o):"object"==typeof s&amp;&amp;(i[a]=e(s[t],o))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>;Object.defineProperty(e,"exports",{enumerable:!0,get:function(){const e=new Map,t={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};t.color.gray=t.color.blackBright,t.bgColor.bgGray=t.bgColor.bgBlackBright,t.color.grey=t.color.blackBright,t.bgColor.bgGrey=t.bgColor.bgBlackBright;for(const[r,n]of Object.entries(t)){for(const[r,s]of Object.entries(n))t[r]={open:`[${s[0]}m`,close:`[${s[1]}m`},n[r]=t[r],e.set(s[0],s[1]);Object.defineProperty(t,r,{value:n,enumerable:!1})}return Object.defineProperty(t,"codes",{value:e,enumerable:!1}),t.color.close="[39m",t.bgColor.close="[49m",c(t.color,"ansi",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l(n,"ansi16",i,!1))</span>,c(t.color,"ansi256",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l(s,"ansi256",i,!1))</span>,c(t.color,"ansi16m",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l(o,"rgb",a,!1))</span>,c(t.bgColor,"ansi",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l(n,"ansi16",i,!0))</span>,c(t.bgColor,"ansi256",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l(s,"ansi256",i,!0))</span>,c(t.bgColor,"ansi16m",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l(o,"rgb",a,!0))</span>,t}})},9920:e=&gt;{"use strict";e.exports=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >[...new Set([].concat(...e))]}</span>,2235:(e,t,r)=&gt;{"use strict";const n=r(4900),s=r(4617),o=r(1495),i=r(425),a=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >for(let n of e){let e=<span class="cstat-no" title="statement not covered" >a.create(n,t);<span class="cstat-no" title="statement not covered" ></span>Array.isArray(e)?r.push(...e):r.push(e)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >r=[].concat(a.create(e,t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t&amp;&amp;!0===t.expand&amp;&amp;!0===t.nodupes&amp;&amp;(r=[...new Set(r)]),r}</span>;a.parse=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >i(e,t),</span>a.stringify=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >n("string"==typeof e?a.parse(e,t):e,t),</span>a.compile=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;(<span class="cstat-no" title="statement not covered" >"string"==typeof e&amp;&amp;(e=a.parse(e,t)),s(e,t))</span>,a.expand=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >"string"==typeof e&amp;&amp;(e=a.parse(e,t));l</span>et r=<span class="cstat-no" title="statement not covered" >o(e,t);<span class="cstat-no" title="statement not covered" ></span>return!0===t.noempty&amp;&amp;(r=r.filter(Boolean)),!0===t.nodupes&amp;&amp;(r=[...new Set(r)]),r}</span>,a.create=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >""===e||e.length&lt;3?[e]:!0!==t.expand?a.compile(e,t):a.expand(e,t),</span>e.exports=a},4617:(e,t,r)=&gt;{"use strict";const n=r(2169),s=r(4542);e.exports=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,o=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let i=<span class="cstat-no" title="statement not covered" >s.isInvalidBrace(o),</span>a=<span class="cstat-no" title="statement not covered" >!0===e.invalid&amp;&amp;!0===t.escapeInvalid,</span>c=<span class="cstat-no" title="statement not covered" >!0===i||!0===a,</span>u=<span class="cstat-no" title="statement not covered" >!0===t.escapeInvalid?"\\":"",</span>l=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(!0===e.isOpen)<span class="cstat-no" title="statement not covered" >return u+e.value;<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===e.isClose)<span class="cstat-no" title="statement not covered" >return u+e.value;<span class="cstat-no" title="statement not covered" >i</span></span>f("open"===e.type)<span class="cstat-no" title="statement not covered" >return c?u+e.value:"(";<span class="cstat-no" title="statement not covered" >i</span></span>f("close"===e.type)<span class="cstat-no" title="statement not covered" >return c?u+e.value:")";<span class="cstat-no" title="statement not covered" >i</span></span>f("comma"===e.type)<span class="cstat-no" title="statement not covered" >return"comma"===e.prev.type?"":c?e.value:"|";<span class="cstat-no" title="statement not covered" >i</span></span>f(e.value)<span class="cstat-no" title="statement not covered" >return e.value;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.nodes&amp;&amp;e.ranges&gt;0){let r=<span class="cstat-no" title="statement not covered" >s.reduce(e.nodes),</span>o=<span class="cstat-no" title="statement not covered" >n(...r,{...t,wrap:!1,toRegex:!0});<span class="cstat-no" title="statement not covered" ></span>if(0!==o.length)<span class="cstat-no" title="statement not covered" >return r.length&gt;1&amp;&amp;o.length&gt;1?`(${o})`:o}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(e.nodes)<span class="cstat-no" title="statement not covered" >for(let t of e.nodes)<span class="cstat-no" title="statement not covered" >l+=r(t,e);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn l}</span>;<span class="cstat-no" title="statement not covered" ></span>return r(e)}</span>},5384:e=&gt;{"use strict";e.exports={MAX_LENGTH:65536,CHAR_0:"0",CHAR_9:"9",CHAR_UPPERCASE_A:"A",CHAR_LOWERCASE_A:"a",CHAR_UPPERCASE_Z:"Z",CHAR_LOWERCASE_Z:"z",CHAR_LEFT_PARENTHESES:"(",CHAR_RIGHT_PARENTHESES:")",CHAR_ASTERISK:"*",CHAR_AMPERSAND:"&amp;",CHAR_AT:"@",CHAR_BACKSLASH:"\\",CHAR_BACKTICK:"`",CHAR_CARRIAGE_RETURN:"\r",CHAR_CIRCUMFLEX_ACCENT:"^",CHAR_COLON:":",CHAR_COMMA:",",CHAR_DOLLAR:"$",CHAR_DOT:".",CHAR_DOUBLE_QUOTE:'"',CHAR_EQUAL:"=",CHAR_EXCLAMATION_MARK:"!",CHAR_FORM_FEED:"\f",CHAR_FORWARD_SLASH:"/",CHAR_HASH:"#",CHAR_HYPHEN_MINUS:"-",CHAR_LEFT_ANGLE_BRACKET:"&lt;",CHAR_LEFT_CURLY_BRACE:"{",CHAR_LEFT_SQUARE_BRACKET:"[",CHAR_LINE_FEED:"\n",CHAR_NO_BREAK_SPACE:" ",CHAR_PERCENT:"%",CHAR_PLUS:"+",CHAR_QUESTION_MARK:"?",CHAR_RIGHT_ANGLE_BRACKET:"&gt;",CHAR_RIGHT_CURLY_BRACE:"}",CHAR_RIGHT_SQUARE_BRACKET:"]",CHAR_SEMICOLON:";",CHAR_SINGLE_QUOTE:"'",CHAR_SPACE:" ",CHAR_TAB:"\t",CHAR_UNDERSCORE:"_",CHAR_VERTICAL_LINE:"|",CHAR_ZERO_WIDTH_NOBREAK_SPACE:"\ufeff"}},1495:(e,t,r)=&gt;{"use strict";const n=r(2169),s=r(4900),o=r(4542),i=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e=[].concat(e),!(t=[].concat(t)).length)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.length)<span class="cstat-no" title="statement not covered" >return r?o.flatten(t).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >`{${e}}`)</span>:t;<span class="cstat-no" title="statement not covered" >f</span></span>or(let s of e)<span class="cstat-no" title="statement not covered" >if(Array.isArray(s))<span class="cstat-no" title="statement not covered" >for(let e of s)<span class="cstat-no" title="statement not covered" >n.push(i(e,t,r));e</span></span>lse <span class="cstat-no" title="statement not covered" >for(let e of t)<span class="cstat-no" title="statement not covered" >!0===r&amp;&amp;"string"==typeof e&amp;&amp;(e=`{${e}}`),n.push(Array.isArray(e)?i(s,e,r):s+e);<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn o.flatten(n)}</span>;e.exports=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >void 0===t.rangeLimit?1e3:t.rangeLimit,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,c=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.queue=[];l</span>et u=<span class="cstat-no" title="statement not covered" >c,</span>l=<span class="cstat-no" title="statement not covered" >c.queue;<span class="cstat-no" title="statement not covered" ></span>for(;"brace"!==u.type&amp;&amp;"root"!==u.type&amp;&amp;u.parent;)<span class="cstat-no" title="statement not covered" >u=u.parent,l=u.queue;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.invalid||e.dollar)<span class="cstat-no" title="statement not covered" >return void l.push(i(l.pop(),s(e,t)));<span class="cstat-no" title="statement not covered" >i</span></span>f("brace"===e.type&amp;&amp;!0!==e.invalid&amp;&amp;2===e.nodes.length)<span class="cstat-no" title="statement not covered" >return void l.push(i(l.pop(),["{}"]));<span class="cstat-no" title="statement not covered" >i</span></span>f(e.nodes&amp;&amp;e.ranges&gt;0){let a=<span class="cstat-no" title="statement not covered" >o.reduce(e.nodes);<span class="cstat-no" title="statement not covered" ></span>if(o.exceedsLimit(...a,t.step,r))<span class="cstat-no" title="statement not covered" >throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");l</span></span>et c=<span class="cstat-no" title="statement not covered" >n(...a,t);<span class="cstat-no" title="statement not covered" ></span>return 0===c.length&amp;&amp;(c=s(e,t)),l.push(i(l.pop(),c)),void(e.nodes=[])}</span>l</span>et p=<span class="cstat-no" title="statement not covered" >o.encloseBrace(e),</span>f=<span class="cstat-no" title="statement not covered" >e.queue,</span>h=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(;"brace"!==h.type&amp;&amp;"root"!==h.type&amp;&amp;h.parent;)<span class="cstat-no" title="statement not covered" >h=h.parent,f=h.queue;<span class="cstat-no" title="statement not covered" >f</span></span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e.nodes.length;t++){let r=<span class="cstat-no" title="statement not covered" >e.nodes[t];<span class="cstat-no" title="statement not covered" ></span>"comma"!==r.type||"brace"!==e.type?"close"!==r.type?r.value&amp;&amp;"open"!==r.type?f.push(i(f.pop(),r.value)):r.nodes&amp;&amp;a(r,e):l.push(i(l.pop(),f,p)):(1===t&amp;&amp;f.push(""),f.push(""))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn f}</span>;<span class="cstat-no" title="statement not covered" ></span>return o.flatten(a(e))}</span>},425:(e,t,r)=&gt;{"use strict";const n=r(4900),{MAX_LENGTH:s,CHAR_BACKSLASH:o,CHAR_BACKTICK:i,CHAR_COMMA:a,CHAR_DOT:c,CHAR_LEFT_PARENTHESES:u,CHAR_RIGHT_PARENTHESES:l,CHAR_LEFT_CURLY_BRACE:p,CHAR_RIGHT_CURLY_BRACE:f,CHAR_LEFT_SQUARE_BRACKET:h,CHAR_RIGHT_SQUARE_BRACKET:d,CHAR_DOUBLE_QUOTE:g,CHAR_SINGLE_QUOTE:y,CHAR_NO_BREAK_SPACE:_,CHAR_ZERO_WIDTH_NOBREAK_SPACE:E}=r(5384);e.exports=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string");l</span></span>et r=<span class="cstat-no" title="statement not covered" >t||{},</span>m=<span class="cstat-no" title="statement not covered" >"number"==typeof r.maxLength?Math.min(s,r.maxLength):s;<span class="cstat-no" title="statement not covered" ></span>if(e.length&gt;m)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${m})`);l</span></span>et b,v=<span class="cstat-no" title="statement not covered" >{type:"root",input:e,nodes:[]},</span>S=<span class="cstat-no" title="statement not covered" >[v],</span>R=<span class="cstat-no" title="statement not covered" >v,</span>A=<span class="cstat-no" title="statement not covered" >v,</span>w=<span class="cstat-no" title="statement not covered" >0,</span>O=<span class="cstat-no" title="statement not covered" >e.length,</span>T=<span class="cstat-no" title="statement not covered" >0,</span>C=<span class="cstat-no" title="statement not covered" >0;</span>const P=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e[T++],</span></span>k=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if("text"===e.type&amp;&amp;"dot"===A.type&amp;&amp;(A.type="text"),!A||"text"!==A.type||"text"!==e.type)<span class="cstat-no" title="statement not covered" >return R.nodes.push(e),e.parent=R,e.prev=A,A=e,e;<span class="cstat-no" title="statement not covered" >A</span></span>.value+=e.value}</span>;<span class="cstat-no" title="statement not covered" ></span>for(k({type:"bos"});T&lt;O;)<span class="cstat-no" title="statement not covered" >if(R=S[S.length-1],b=P(),b!==E&amp;&amp;b!==_)<span class="cstat-no" title="statement not covered" >if(b!==o)<span class="cstat-no" title="statement not covered" >if(b!==d)<span class="cstat-no" title="statement not covered" >if(b!==h)<span class="cstat-no" title="statement not covered" >if(b!==u)<span class="cstat-no" title="statement not covered" >if(b!==l)<span class="cstat-no" title="statement not covered" >if(b!==g&amp;&amp;b!==y&amp;&amp;b!==i)<span class="cstat-no" title="statement not covered" >if(b!==p)<span class="cstat-no" title="statement not covered" >if(b!==f)<span class="cstat-no" title="statement not covered" >if(b===a&amp;&amp;C&gt;0){<span class="cstat-no" title="statement not covered" >if(R.ranges&gt;0){<span class="cstat-no" title="statement not covered" >R.ranges=0;l</span>et e=<span class="cstat-no" title="statement not covered" >R.nodes.shift();<span class="cstat-no" title="statement not covered" ></span>R.nodes=[e,{type:"text",value:n(R)}]}<span class="cstat-no" title="statement not covered" ></span>k</span>({type:"comma",value:b}),R.commas++}</span>else <span class="cstat-no" title="statement not covered" >if(b===c&amp;&amp;C&gt;0&amp;&amp;0===R.commas){let e=<span class="cstat-no" title="statement not covered" >R.nodes;<span class="cstat-no" title="statement not covered" ></span>if(0===C||0===e.length){<span class="cstat-no" title="statement not covered" >k({type:"text",value:b});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("dot"===A.type){<span class="cstat-no" title="statement not covered" >if(R.range=[],A.value+=b,A.type="range",3!==R.nodes.length&amp;&amp;5!==R.nodes.length){<span class="cstat-no" title="statement not covered" >R.invalid=!0,R.ranges=0,A.type="text";<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>R</span>.ranges++,R.args=[];<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("range"===A.type){<span class="cstat-no" title="statement not covered" >e.pop();l</span>et t=<span class="cstat-no" title="statement not covered" >e[e.length-1];<span class="cstat-no" title="statement not covered" ></span>t.value+=A.value+b,A=t,R.ranges--;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>k</span>({type:"dot",value:b})}</span>else <span class="cstat-no" title="statement not covered" >k({type:"text",value:b});e</span></span></span>lse{<span class="cstat-no" title="statement not covered" >if("brace"!==R.type){<span class="cstat-no" title="statement not covered" >k({type:"text",value:b});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et e=<span class="cstat-no" title="statement not covered" >"close";<span class="cstat-no" title="statement not covered" ></span>R=S.pop(),R.close=!0,k({type:e,value:b}),C--,R=S[S.length-1]}</span>e</span>lse{<span class="cstat-no" title="statement not covered" >C++;l</span>et e=<span class="cstat-no" title="statement not covered" >A.value&amp;&amp;"$"===A.value.slice(-1)||!0===R.dollar;<span class="cstat-no" title="statement not covered" ></span>R=k({type:"brace",open:!0,close:!1,dollar:e,depth:C,commas:0,ranges:0,nodes:[]}),S.push(R),k({type:"open",value:b})}</span>e</span>lse{let e,r=<span class="cstat-no" title="statement not covered" >b;<span class="cstat-no" title="statement not covered" ></span>for(!0!==t.keepQuotes&amp;&amp;(b="");T&lt;O&amp;&amp;(e=P());)<span class="cstat-no" title="statement not covered" >if(e!==o){<span class="cstat-no" title="statement not covered" >if(e===r){<span class="cstat-no" title="statement not covered" >!0===t.keepQuotes&amp;&amp;(b+=e);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>b</span>+=e}</span>else <span class="cstat-no" title="statement not covered" >b+=e+P();<span class="cstat-no" title="statement not covered" >k</span></span></span>({type:"text",value:b})}</span>e</span>lse{<span class="cstat-no" title="statement not covered" >if("paren"!==R.type){<span class="cstat-no" title="statement not covered" >k({type:"text",value:b});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>R</span>=S.pop(),k({type:"text",value:b}),R=S[S.length-1]}</span>e</span>lse <span class="cstat-no" title="statement not covered" >R=k({type:"paren",nodes:[]}),S.push(R),k({type:"text",value:b});e</span></span>lse{<span class="cstat-no" title="statement not covered" >w++;l</span>et e;<span class="cstat-no" title="statement not covered" >for(;T&lt;O&amp;&amp;(e=P());)<span class="cstat-no" title="statement not covered" >if(b+=e,e!==h)<span class="cstat-no" title="statement not covered" >if(e!==o){<span class="cstat-no" title="statement not covered" >if(e===d&amp;&amp;(w--,0===w))<span class="cstat-no" title="statement not covered" >break}</span></span>else <span class="cstat-no" title="statement not covered" >b+=P();e</span></span>lse <span class="cstat-no" title="statement not covered" >w++;<span class="cstat-no" title="statement not covered" >k</span></span></span>({type:"text",value:b})}</span>e</span>lse <span class="cstat-no" title="statement not covered" >k({type:"text",value:"\\"+b});e</span></span>lse <span class="cstat-no" title="statement not covered" >k({type:"text",value:(t.keepEscaping?b:"")+P()});<span class="cstat-no" title="statement not covered" >d</span></span></span></span>o{<span class="cstat-no" title="statement not covered" >if(R=S.pop(),"root"!==R.type){<span class="cstat-no" title="statement not covered" >R.nodes.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.nodes||("open"===e.type&amp;&amp;(e.isOpen=!0),"close"===e.type&amp;&amp;(e.isClose=!0),e.nodes||(e.type="text"),e.invalid=!0)}</span>);l</span>et e=<span class="cstat-no" title="statement not covered" >S[S.length-1],</span>t=<span class="cstat-no" title="statement not covered" >e.nodes.indexOf(R);<span class="cstat-no" title="statement not covered" ></span>e.nodes.splice(t,1,...R.nodes)}</span>}</span>while(S.length&gt;0);<span class="cstat-no" title="statement not covered" >r</span>eturn k({type:"eos"}),v}</span>},4900:(e,t,r)=&gt;{"use strict";const n=r(4542);e.exports=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,s=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let o=<span class="cstat-no" title="statement not covered" >t.escapeInvalid&amp;&amp;n.isInvalidBrace(s),</span>i=<span class="cstat-no" title="statement not covered" >!0===e.invalid&amp;&amp;!0===t.escapeInvalid,</span>a=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(e.value)<span class="cstat-no" title="statement not covered" >return(o||i)&amp;&amp;n.isOpenOrClose(e)?"\\"+e.value:e.value;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.value)<span class="cstat-no" title="statement not covered" >return e.value;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.nodes)<span class="cstat-no" title="statement not covered" >for(let t of e.nodes)<span class="cstat-no" title="statement not covered" >a+=r(t);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn a}</span>;<span class="cstat-no" title="statement not covered" ></span>return r(e)}</span>},4542:(e,t)=&gt;{"use strict";t.isInteger=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"number"==typeof e?Number.isInteger(e):"string"==typeof e&amp;&amp;""!==e.trim()&amp;&amp;Number.isInteger(Number(e)),</span>t.find=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e.nodes.find(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.type===t)</span>,</span>t.exceedsLimit=<span class="fstat-no" title="function not covered" >(e</span>,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>s)=&gt;<span class="cstat-no" title="statement not covered" >!1!==s&amp;&amp;(!(!t.isInteger(e)||!t.isInteger(r))&amp;&amp;(Number(r)-Number(e))/Number(n)&gt;=s),</span>t.escapeNode=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >e.nodes[t];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(r&amp;&amp;n.type===r||"open"===n.type||"close"===n.type)&amp;&amp;!0!==n.escaped&amp;&amp;(n.value="\\"+n.value,n.escaped=!0)}</span>,t.encloseBrace=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"brace"===e.type&amp;&amp;(e.commas&gt;&gt;0+e.ranges&gt;&gt;0==0&amp;&amp;(e.invalid=!0,!0)),</span>t.isInvalidBrace=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"brace"===e.type&amp;&amp;(!(!0!==e.invalid&amp;&amp;!e.dollar)||(e.commas&gt;&gt;0+e.ranges&gt;&gt;0==0||!0!==e.open||!0!==e.close)&amp;&amp;(e.invalid=!0,!0)),</span>t.isOpenOrClose=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"open"===e.type||"close"===e.type||(!0===e.open||!0===e.close),</span>t.reduce=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.reduce(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;(<span class="cstat-no" title="statement not covered" >"text"===t.type&amp;&amp;e.push(t.value),"range"===t.type&amp;&amp;(t.type="text"),e)</span>,[]),</span>t.flatten=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;{const t=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++){let s=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>Array.isArray(s)?r(s,t):void 0!==s&amp;&amp;t.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>;<span class="cstat-no" title="statement not covered" ></span>return r(e),t}</span>},5882:(e,t,r)=&gt;{"use strict";const n=r(7652),{stdout:s,stderr:o}=r(9428),{stringReplaceAll:i,stringEncaseCRLFWithFirstIndex:a}=r(3327),c=["ansi","ansi","ansi256","ansi16m"],u=Object.create(null);class l{constructor(e){return p(e)}}const p=e=&gt;{const t={};return((e,t={})=&gt;{<span class="missing-if-branch" title="if path not taken" >I</span>if(t.level&gt;3||t.level&lt;0)<span class="cstat-no" title="statement not covered" >throw new Error("The `level` option should be an integer from 0 to 3");c</span>onst r=s?s.level:<span class="branch-1 cbranch-no" title="branch not covered" >0;</span>e.level=void 0===t.level?r:t.level})(t,e),t.template=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >m(t.template,...e),</span>Object.setPrototypeOf(t,f.prototype),Object.setPrototypeOf(t.template,t),t.template.constructor=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.")}</span>,t.template.Instance=l,t.template};function f(e){return p(e)}for(const[e,t]of Object.entries(n))u[e]={<span class="fstat-no" title="function not covered" >ge</span>t(){const r=<span class="cstat-no" title="statement not covered" >y(this,g(t.open,t.close,this._styler),this._isEmpty);<span class="cstat-no" title="statement not covered" ></span>return Object.defineProperty(this,e,{value:r}),r}</span>};u.visible={<span class="fstat-no" title="function not covered" >ge</span>t(){const e=<span class="cstat-no" title="statement not covered" >y(this,this._styler,!0);<span class="cstat-no" title="statement not covered" ></span>return Object.defineProperty(this,"visible",{value:e}),e}</span>};const h=["rgb","hex","keyword","hsl","hsv","hwb","ansi","ansi256"];for(const e of h)u[e]={<span class="fstat-no" title="function not covered" >ge</span>t(){const{level:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(...r){const s=<span class="cstat-no" title="statement not covered" >g(n.color[c[t]][e](...r),n.color.close,this._styler);<span class="cstat-no" title="statement not covered" ></span>return y(this,s,this._isEmpty)}</span>}</span>};for(const e of h){u["bg"+e[0].toUpperCase()+e.slice(1)]={<span class="fstat-no" title="function not covered" >ge</span>t(){const{level:t}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(...r){const s=<span class="cstat-no" title="statement not covered" >g(n.bgColor[c[t]][e](...r),n.bgColor.close,this._styler);<span class="cstat-no" title="statement not covered" ></span>return y(this,s,this._isEmpty)}</span>}</span>}}const d=Object.defineProperties(<span class="fstat-no" title="function not covered" >()</span>=&gt;{},{...u,level:{enumerable:!0,<span class="fstat-no" title="function not covered" >ge</span>t(){<span class="cstat-no" title="statement not covered" >return this._generator.level}</span>,<span class="fstat-no" title="function not covered" >se</span>t(e){<span class="cstat-no" title="statement not covered" >this._generator.level=e}</span>}}),g=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n,s;<span class="cstat-no" title="statement not covered" >return void 0===r?(n=e,s=t):(n=r.openAll+e,s=t+r.closeAll),{open:e,close:t,openAll:n,closeAll:s,parent:r}}</span>,y=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >_(n,1===e.length?""+e[0]:e.join(" "));<span class="cstat-no" title="statement not covered" ></span></span>return n.__proto__=d,n._generator=e,n._styler=t,n._isEmpty=r,n}</span>,_=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(e.level&lt;=0||!t)<span class="cstat-no" title="statement not covered" >return e._isEmpty?"":t;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e._styler;<span class="cstat-no" title="statement not covered" ></span>if(void 0===r)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst{openAll:n,closeAll:s}=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>if(-1!==t.indexOf(""))<span class="cstat-no" title="statement not covered" >for(;void 0!==r;)<span class="cstat-no" title="statement not covered" >t=i(t,r.close,r.open),r=r.parent;c</span></span></span>onst o=<span class="cstat-no" title="statement not covered" >t.indexOf("\n");<span class="cstat-no" title="statement not covered" ></span>return-1!==o&amp;&amp;(t=a(t,s,n,o)),n+t+s}</span>;let E;const m=<span class="fstat-no" title="function not covered" >(e</span>,...t)=&gt;{const[n]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(!Array.isArray(n))<span class="cstat-no" title="statement not covered" >return t.join(" ");c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t.slice(1),</span>o=<span class="cstat-no" title="statement not covered" >[n.raw[0]];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >1;</span>e&lt;n.length;e++)<span class="cstat-no" title="statement not covered" >o.push(String(s[e-1]).replace(/[{}\\]/g,"\\$&amp;"),String(n.raw[e]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn void 0===E&amp;&amp;(E=r(690)),E(e,o.join(""))}</span>;Object.defineProperties(f.prototype,u);const b=f();b.supportsColor=s,b.stderr=f({level:o?o.level:<span class="branch-1 cbranch-no" title="branch not covered" >0}</span>),b.stderr.supportsColor=o,b.Level={None:0,Basic:1,Ansi256:2,TrueColor:3,0:"None",1:"Basic",2:"Ansi256",3:"TrueColor"},e.exports=b},690:<span class="fstat-no" title="function not covered" >e=</span>&gt;{"use strict";const t=<span class="cstat-no" title="statement not covered" >/(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,</span>r=<span class="cstat-no" title="statement not covered" >/(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,</span>n=<span class="cstat-no" title="statement not covered" >/^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,</span>s=<span class="cstat-no" title="statement not covered" >/\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.)|([^\\])/gi,</span>o=<span class="cstat-no" title="statement not covered" >new Map([["n","\n"],["r","\r"],["t","\t"],["b","\b"],["f","\f"],["v","\v"],["0","\0"],["\\","\\"],["e",""],["a",""]]);</span>function <span class="fstat-no" title="function not covered" >i(</span>e){const t=<span class="cstat-no" title="statement not covered" >"u"===e[0],</span>r=<span class="cstat-no" title="statement not covered" >"{"===e[1];<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;!r&amp;&amp;5===e.length||"x"===e[0]&amp;&amp;3===e.length?String.fromCharCode(parseInt(e.slice(1),16)):t&amp;&amp;r?String.fromCodePoint(parseInt(e.slice(2,-1),16)):o.get(e)||e}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t){const r=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >t.trim().split(/\s*,\s*/g);</span>let a;<span class="cstat-no" title="statement not covered" >for(const t of o){const o=<span class="cstat-no" title="statement not covered" >Number(t);<span class="cstat-no" title="statement not covered" ></span>if(Number.isNaN(o)){<span class="cstat-no" title="statement not covered" >if(!(a=t.match(n)))<span class="cstat-no" title="statement not covered" >throw new Error(`Invalid Chalk template style argument: ${t} (in style '${e}')`);<span class="cstat-no" title="statement not covered" >r</span></span>.push(a[2].replace(s,<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >t?i(t):r)</span>)}</span>else <span class="cstat-no" title="statement not covered" >r.push(o)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >c(</span>e){<span class="cstat-no" title="statement not covered" >r.lastIndex=0;c</span>onst t=<span class="cstat-no" title="statement not covered" >[];</span>let n;<span class="cstat-no" title="statement not covered" >for(;null!==(n=r.exec(e));){const e=<span class="cstat-no" title="statement not covered" >n[1];<span class="cstat-no" title="statement not covered" ></span>if(n[2]){const r=<span class="cstat-no" title="statement not covered" >a(e,n[2]);<span class="cstat-no" title="statement not covered" ></span>t.push([e].concat(r))}</span>else <span class="cstat-no" title="statement not covered" >t.push([e])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t){const r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const e of t)<span class="cstat-no" title="statement not covered" >for(const t of e.styles)<span class="cstat-no" title="statement not covered" >r[t[0]]=e.inverse?null:t.slice(1);l</span></span></span>et n=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(const[e,t]of Object.entries(r))<span class="cstat-no" title="statement not covered" >if(Array.isArray(t)){<span class="cstat-no" title="statement not covered" >if(!(e in n))<span class="cstat-no" title="statement not covered" >throw new Error("Unknown Chalk style: "+e);<span class="cstat-no" title="statement not covered" >n</span></span>=t.length&gt;0?n[e](...t):n[e]}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn n}<span class="cstat-no" title="statement not covered" ></span>e.exports=<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(r.replace(t,<span class="fstat-no" title="function not covered" >(t</span>,r,a,l,p,f)=&gt;{<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >o.push(i(r));e</span>lse <span class="cstat-no" title="statement not covered" >if(l){const t=<span class="cstat-no" title="statement not covered" >o.join("");<span class="cstat-no" title="statement not covered" ></span>o=[],s.push(0===n.length?t:u(e,n)(t)),n.push({inverse:a,styles:c(l)})}</span>else <span class="cstat-no" title="statement not covered" >if(p){<span class="cstat-no" title="statement not covered" >if(0===n.length)<span class="cstat-no" title="statement not covered" >throw new Error("Found extraneous } in Chalk template literal");<span class="cstat-no" title="statement not covered" >s</span></span>.push(u(e,n)(o.join(""))),o=[],n.pop()}</span>else <span class="cstat-no" title="statement not covered" >o.push(f)}</span></span></span></span>),s.push(o.join("")),n.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >`Chalk template literal is missing ${n.length} closing bracket${1===n.length?"":"s"} (\`}\`)`;<span class="cstat-no" title="statement not covered" ></span>throw new Error(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.join("")}</span>}</span>,3327:e=&gt;{"use strict";e.exports={stringReplaceAll:<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >e.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>if(-1===n)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t.length;</span>let o=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >i+=e.substr(o,n-o)+t+r,o=n+s,n=e.indexOf(t,o)}</span>while(-1!==n);<span class="cstat-no" title="statement not covered" >r</span>eturn i+=e.substr(o),i}</span>,stringEncaseCRLFWithFirstIndex:<span class="fstat-no" title="function not covered" >(e</span>,t,r,n)=&gt;{let s=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>do{const i=<span class="cstat-no" title="statement not covered" >"\r"===e[n-1];<span class="cstat-no" title="statement not covered" ></span>o+=e.substr(s,(i?n-1:n)-s)+t+(i?"\r\n":"\n")+r,s=n+1,n=e.indexOf("\n",s)}</span>while(-1!==n);<span class="cstat-no" title="statement not covered" >r</span>eturn o+=e.substr(s),o}</span>}},5311:<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >r(3300),</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const e of Object.keys(n))<span class="cstat-no" title="statement not covered" >s[n[e]]=e;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >{rgb:{channels:3,labels:"rgb"},hsl:{channels:3,labels:"hsl"},hsv:{channels:3,labels:"hsv"},hwb:{channels:3,labels:"hwb"},cmyk:{channels:4,labels:"cmyk"},xyz:{channels:3,labels:"xyz"},lab:{channels:3,labels:"lab"},lch:{channels:3,labels:"lch"},hex:{channels:1,labels:["hex"]},keyword:{channels:1,labels:["keyword"]},ansi16:{channels:1,labels:["ansi16"]},ansi256:{channels:1,labels:["ansi256"]},hcg:{channels:3,labels:["h","c","g"]},apple:{channels:3,labels:["r16","g16","b16"]},gray:{channels:1,labels:["gray"]}};<span class="cstat-no" title="statement not covered" ></span>e.exports=o;<span class="cstat-no" title="statement not covered" >f</span>or(const e of Object.keys(o)){<span class="cstat-no" title="statement not covered" >if(!("channels"in o[e]))<span class="cstat-no" title="statement not covered" >throw new Error("missing channels property: "+e);<span class="cstat-no" title="statement not covered" >i</span></span>f(!("labels"in o[e]))<span class="cstat-no" title="statement not covered" >throw new Error("missing channel labels property: "+e);<span class="cstat-no" title="statement not covered" >i</span></span>f(o[e].labels.length!==o[e].channels)<span class="cstat-no" title="statement not covered" >throw new Error("channel and label counts mismatch: "+e);c</span></span>onst{channels:t,labels:r}=<span class="cstat-no" title="statement not covered" >o[e];<span class="cstat-no" title="statement not covered" ></span>delete o[e].channels,delete o[e].labels,Object.defineProperty(o[e],"channels",{value:t}),Object.defineProperty(o[e],"labels",{value:r})}<span class="cstat-no" title="statement not covered" ></span>o</span>.rgb.hsl=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/255,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/255,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/255,</span>s=<span class="cstat-no" title="statement not covered" >Math.min(t,r,n),</span>o=<span class="cstat-no" title="statement not covered" >Math.max(t,r,n),</span>i=<span class="cstat-no" title="statement not covered" >o-s;</span>let a,c;<span class="cstat-no" title="statement not covered" >o===s?a=0:t===o?a=(r-n)/i:r===o?a=2+(n-t)/i:n===o&amp;&amp;(a=4+(t-r)/i),a=Math.min(60*a,360),a&lt;0&amp;&amp;(a+=360);c</span>onst u=<span class="cstat-no" title="statement not covered" >(s+o)/2;<span class="cstat-no" title="statement not covered" ></span>return c=o===s?0:u&lt;=.5?i/(o+s):i/(2-o-s),[a,100*c,100*u]}</span>,o.rgb.hsv=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t,r,n,s,o;const i=<span class="cstat-no" title="statement not covered" >e[0]/255,</span>a=<span class="cstat-no" title="statement not covered" >e[1]/255,</span>c=<span class="cstat-no" title="statement not covered" >e[2]/255,</span>u=<span class="cstat-no" title="statement not covered" >Math.max(i,a,c),</span>l=<span class="cstat-no" title="statement not covered" >u-Math.min(i,a,c),</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return(u-e)/6/l+.5}</span>;<span class="cstat-no" title="statement not covered" ></span>return 0===l?(s=0,o=0):(o=l/u,t=p(i),r=p(a),n=p(c),i===u?s=n-r:a===u?s=1/3+t-n:c===u&amp;&amp;(s=2/3+r-t),s&lt;0?s+=1:s&gt;1&amp;&amp;(s-=1)),[360*s,100*o,100*u]}</span>,o.rgb.hwb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0],</span>r=<span class="cstat-no" title="statement not covered" >e[1];</span>let n=<span class="cstat-no" title="statement not covered" >e[2];</span>const s=<span class="cstat-no" title="statement not covered" >o.rgb.hsl(e)[0],</span>i=<span class="cstat-no" title="statement not covered" >1/255*Math.min(t,Math.min(r,n));<span class="cstat-no" title="statement not covered" ></span>return n=1-1/255*Math.max(t,Math.max(r,n)),[s,100*i,100*n]}</span>,o.rgb.cmyk=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/255,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/255,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/255,</span>s=<span class="cstat-no" title="statement not covered" >Math.min(1-t,1-r,1-n);<span class="cstat-no" title="statement not covered" ></span>return[100*((1-t-s)/(1-s)||0),100*((1-r-s)/(1-s)||0),100*((1-n-s)/(1-s)||0),100*s]}</span>,o.rgb.keyword=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >s[e];<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t;l</span></span>et r,o=<span class="cstat-no" title="statement not covered" >1/0;<span class="cstat-no" title="statement not covered" ></span>for(const t of Object.keys(n)){const s=<span class="cstat-no" title="statement not covered" >n[t],</span>c=(<span class="cstat-no" title="statement not covered" >a=s,((i=e)[0]-a[0])**2+(i[1]-a[1])**2+(i[2]-a[2])**2)</span>;<span class="cstat-no" title="statement not covered" >c&lt;o&amp;&amp;(o=c,r=t)}</span>v</span>ar i,a;<span class="cstat-no" title="statement not covered" >return r}</span>,o.keyword.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n[e]}</span>,o.rgb.xyz=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t=<span class="cstat-no" title="statement not covered" >e[0]/255,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/255,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/255;<span class="cstat-no" title="statement not covered" ></span>t=t&gt;.04045?((t+.055)/1.055)**2.4:t/12.92,r=r&gt;.04045?((r+.055)/1.055)**2.4:r/12.92,n=n&gt;.04045?((n+.055)/1.055)**2.4:n/12.92;<span class="cstat-no" title="statement not covered" >r</span>eturn[100*(.4124*t+.3576*r+.1805*n),100*(.2126*t+.7152*r+.0722*n),100*(.0193*t+.1192*r+.9505*n)]}</span>,o.rgb.lab=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >o.rgb.xyz(e);</span>let r=<span class="cstat-no" title="statement not covered" >t[0],</span>n=<span class="cstat-no" title="statement not covered" >t[1],</span>s=<span class="cstat-no" title="statement not covered" >t[2];<span class="cstat-no" title="statement not covered" ></span>r/=95.047,n/=100,s/=108.883,r=r&gt;.008856?r**(1/3):7.787*r+16/116,n=n&gt;.008856?n**(1/3):7.787*n+16/116,s=s&gt;.008856?s**(1/3):7.787*s+16/116;<span class="cstat-no" title="statement not covered" >r</span>eturn[116*n-16,500*(r-n),200*(n-s)]}</span>,o.hsl.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/360,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/100;</span>let s,o,i;<span class="cstat-no" title="statement not covered" >if(0===r)<span class="cstat-no" title="statement not covered" >return i=255*n,[i,i,i];<span class="cstat-no" title="statement not covered" >s</span></span>=n&lt;.5?n*(1+r):n+r-n*r;c</span>onst a=<span class="cstat-no" title="statement not covered" >2*n-s,</span>c=<span class="cstat-no" title="statement not covered" >[0,0,0];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;3;e++)<span class="cstat-no" title="statement not covered" >o=t+1/3*-(e-1),o&lt;0&amp;&amp;o++,o&gt;1&amp;&amp;o--,i=6*o&lt;1?a+6*(s-a)*o:2*o&lt;1?s:3*o&lt;2?a+(s-a)*(2/3-o)*6:a,c[e]=255*i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}</span>,o.hsl.hsv=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0];</span>let r=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/100,</span>s=<span class="cstat-no" title="statement not covered" >r;</span>const o=<span class="cstat-no" title="statement not covered" >Math.max(n,.01);<span class="cstat-no" title="statement not covered" ></span>n*=2,r*=n&lt;=1?n:2-n,s*=o&lt;=1?o:2-o;<span class="cstat-no" title="statement not covered" >r</span>eturn[t,100*(0===n?2*s/(o+s):2*r/(n+r)),100*((n+r)/2)]}</span>,o.hsv.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/60,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/100;</span>let n=<span class="cstat-no" title="statement not covered" >e[2]/100;</span>const s=<span class="cstat-no" title="statement not covered" >Math.floor(t)%6,</span>o=<span class="cstat-no" title="statement not covered" >t-Math.floor(t),</span>i=<span class="cstat-no" title="statement not covered" >255*n*(1-r),</span>a=<span class="cstat-no" title="statement not covered" >255*n*(1-r*o),</span>c=<span class="cstat-no" title="statement not covered" >255*n*(1-r*(1-o));<span class="cstat-no" title="statement not covered" ></span>switch(n*=255,s){case 0:<span class="cstat-no" title="statement not covered" >return[n,c,i];c</span>ase 1:<span class="cstat-no" title="statement not covered" >return[a,n,i];c</span>ase 2:<span class="cstat-no" title="statement not covered" >return[i,n,c];c</span>ase 3:<span class="cstat-no" title="statement not covered" >return[i,a,n];c</span>ase 4:<span class="cstat-no" title="statement not covered" >return[c,i,n];c</span>ase 5:<span class="cstat-no" title="statement not covered" >return[n,i,a]}</span>}</span>,o.hsv.hsl=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0],</span>r=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/100,</span>s=<span class="cstat-no" title="statement not covered" >Math.max(n,.01);</span>let o,i;<span class="cstat-no" title="statement not covered" >i=(2-r)*n;c</span>onst a=<span class="cstat-no" title="statement not covered" >(2-r)*s;<span class="cstat-no" title="statement not covered" ></span>return o=r*s,o/=a&lt;=1?a:2-a,o=o||0,i/=2,[t,100*o,100*i]}</span>,o.hwb.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/360;</span>let r=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/100;</span>const s=<span class="cstat-no" title="statement not covered" >r+n;</span>let o;<span class="cstat-no" title="statement not covered" >s&gt;1&amp;&amp;(r/=s,n/=s);c</span>onst i=<span class="cstat-no" title="statement not covered" >Math.floor(6*t),</span>a=<span class="cstat-no" title="statement not covered" >1-n;<span class="cstat-no" title="statement not covered" ></span>o=6*t-i,0!=(1&amp;i)&amp;&amp;(o=1-o);c</span>onst c=<span class="cstat-no" title="statement not covered" >r+o*(a-r);</span>let u,l,p;<span class="cstat-no" title="statement not covered" >switch(i){default:case 6:case 0:<span class="cstat-no" title="statement not covered" >u=a,l=c,p=r;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >u=c,l=a,p=r;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >u=r,l=a,p=c;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >u=r,l=c,p=a;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >u=c,l=r,p=a;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 5:<span class="cstat-no" title="statement not covered" >u=a,l=r,p=c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[255*u,255*l,255*p]}</span>,o.cmyk.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/100,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/100,</span>s=<span class="cstat-no" title="statement not covered" >e[3]/100;<span class="cstat-no" title="statement not covered" ></span>return[255*(1-Math.min(1,t*(1-s)+s)),255*(1-Math.min(1,r*(1-s)+s)),255*(1-Math.min(1,n*(1-s)+s))]}</span>,o.xyz.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/100,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/100;</span>let s,o,i;<span class="cstat-no" title="statement not covered" >return s=3.2406*t+-1.5372*r+-.4986*n,o=-.9689*t+1.8758*r+.0415*n,i=.0557*t+-.204*r+1.057*n,s=s&gt;.0031308?1.055*s**(1/2.4)-.055:12.92*s,o=o&gt;.0031308?1.055*o**(1/2.4)-.055:12.92*o,i=i&gt;.0031308?1.055*i**(1/2.4)-.055:12.92*i,s=Math.min(Math.max(0,s),1),o=Math.min(Math.max(0,o),1),i=Math.min(Math.max(0,i),1),[255*s,255*o,255*i]}</span>,o.xyz.lab=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t=<span class="cstat-no" title="statement not covered" >e[0],</span>r=<span class="cstat-no" title="statement not covered" >e[1],</span>n=<span class="cstat-no" title="statement not covered" >e[2];<span class="cstat-no" title="statement not covered" ></span>t/=95.047,r/=100,n/=108.883,t=t&gt;.008856?t**(1/3):7.787*t+16/116,r=r&gt;.008856?r**(1/3):7.787*r+16/116,n=n&gt;.008856?n**(1/3):7.787*n+16/116;<span class="cstat-no" title="statement not covered" >r</span>eturn[116*r-16,500*(t-r),200*(r-n)]}</span>,o.lab.xyz=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t,r,n;<span class="cstat-no" title="statement not covered" >r=(e[0]+16)/116,t=e[1]/500+r,n=r-e[2]/200;c</span>onst s=<span class="cstat-no" title="statement not covered" >r**3,</span>o=<span class="cstat-no" title="statement not covered" >t**3,</span>i=<span class="cstat-no" title="statement not covered" >n**3;<span class="cstat-no" title="statement not covered" ></span>return r=s&gt;.008856?s:(r-16/116)/7.787,t=o&gt;.008856?o:(t-16/116)/7.787,n=i&gt;.008856?i:(n-16/116)/7.787,t*=95.047,r*=100,n*=108.883,[t,r,n]}</span>,o.lab.lch=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0],</span>r=<span class="cstat-no" title="statement not covered" >e[1],</span>n=<span class="cstat-no" title="statement not covered" >e[2];</span>let s;<span class="cstat-no" title="statement not covered" >s=360*Math.atan2(n,r)/2/Math.PI,s&lt;0&amp;&amp;(s+=360);<span class="cstat-no" title="statement not covered" >r</span>eturn[t,Math.sqrt(r*r+n*n),s]}</span>,o.lch.lab=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0],</span>r=<span class="cstat-no" title="statement not covered" >e[1],</span>n=<span class="cstat-no" title="statement not covered" >e[2]/360*2*Math.PI;<span class="cstat-no" title="statement not covered" ></span>return[t,r*Math.cos(n),r*Math.sin(n)]}</span>,o.rgb.ansi16=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >null)</span>{const[r,n,s]=<span class="cstat-no" title="statement not covered" >e;</span>let i=<span class="cstat-no" title="statement not covered" >null===t?o.rgb.hsv(e)[2]:t;<span class="cstat-no" title="statement not covered" ></span>if(i=Math.round(i/50),0===i)<span class="cstat-no" title="statement not covered" >return 30;l</span></span>et a=<span class="cstat-no" title="statement not covered" >30+(Math.round(s/255)&lt;&lt;2|Math.round(n/255)&lt;&lt;1|Math.round(r/255));<span class="cstat-no" title="statement not covered" ></span>return 2===i&amp;&amp;(a+=60),a}</span>,o.hsv.ansi16=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return o.rgb.ansi16(o.hsv.rgb(e),e[2])}</span>,o.rgb.ansi256=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0],</span>r=<span class="cstat-no" title="statement not covered" >e[1],</span>n=<span class="cstat-no" title="statement not covered" >e[2];<span class="cstat-no" title="statement not covered" ></span>if(t===r&amp;&amp;r===n)<span class="cstat-no" title="statement not covered" >return t&lt;8?16:t&gt;248?231:Math.round((t-8)/247*24)+232;<span class="cstat-no" title="statement not covered" >r</span></span>eturn 16+36*Math.round(t/255*5)+6*Math.round(r/255*5)+Math.round(n/255*5)}</span>,o.ansi16.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){let t=<span class="cstat-no" title="statement not covered" >e%10;<span class="cstat-no" title="statement not covered" ></span>if(0===t||7===t)<span class="cstat-no" title="statement not covered" >return e&gt;50&amp;&amp;(t+=3.5),t=t/10.5*255,[t,t,t];c</span></span>onst r=<span class="cstat-no" title="statement not covered" >.5*(1+~~(e&gt;50));<span class="cstat-no" title="statement not covered" ></span>return[(1&amp;t)*r*255,(t&gt;&gt;1&amp;1)*r*255,(t&gt;&gt;2&amp;1)*r*255]}</span>,o.ansi256.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(e&gt;=232){const t=<span class="cstat-no" title="statement not covered" >10*(e-232)+8;<span class="cstat-no" title="statement not covered" ></span>return[t,t,t]}</span>l</span>et t;<span class="cstat-no" title="statement not covered" >e-=16;<span class="cstat-no" title="statement not covered" >r</span>eturn[Math.floor(e/36)/5*255,Math.floor((t=e%36)/6)/5*255,t%6/5*255]}</span>,o.rgb.hex=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >(((255&amp;Math.round(e[0]))&lt;&lt;16)+((255&amp;Math.round(e[1]))&lt;&lt;8)+(255&amp;Math.round(e[2]))).toString(16).toUpperCase();<span class="cstat-no" title="statement not covered" ></span>return"000000".substring(t.length)+t}</span>,o.hex.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return[0,0,0];l</span></span>et r=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>3===t[0].length&amp;&amp;(r=r.split("").map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e+e)</span>.join(""));c</span>onst n=<span class="cstat-no" title="statement not covered" >parseInt(r,16);<span class="cstat-no" title="statement not covered" ></span>return[n&gt;&gt;16&amp;255,n&gt;&gt;8&amp;255,255&amp;n]}</span>,o.rgb.hcg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/255,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/255,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/255,</span>s=<span class="cstat-no" title="statement not covered" >Math.max(Math.max(t,r),n),</span>o=<span class="cstat-no" title="statement not covered" >Math.min(Math.min(t,r),n),</span>i=<span class="cstat-no" title="statement not covered" >s-o;</span>let a,c;<span class="cstat-no" title="statement not covered" >return a=i&lt;1?o/(1-i):0,c=i&lt;=0?0:s===t?(r-n)/i%6:s===r?2+(n-t)/i:4+(t-r)/i,c/=6,c%=1,[360*c,100*i,100*a]}</span>,o.hsl.hcg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>r=<span class="cstat-no" title="statement not covered" >e[2]/100,</span>n=<span class="cstat-no" title="statement not covered" >r&lt;.5?2*t*r:2*t*(1-r);</span>let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return n&lt;1&amp;&amp;(s=(r-.5*n)/(1-n)),[e[0],100*n,100*s]}</span>,o.hsv.hcg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>r=<span class="cstat-no" title="statement not covered" >e[2]/100,</span>n=<span class="cstat-no" title="statement not covered" >t*r;</span>let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return n&lt;1&amp;&amp;(s=(r-n)/(1-n)),[e[0],100*n,100*s]}</span>,o.hcg.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[0]/360,</span>r=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>n=<span class="cstat-no" title="statement not covered" >e[2]/100;<span class="cstat-no" title="statement not covered" ></span>if(0===r)<span class="cstat-no" title="statement not covered" >return[255*n,255*n,255*n];c</span></span>onst s=<span class="cstat-no" title="statement not covered" >[0,0,0],</span>o=<span class="cstat-no" title="statement not covered" >t%1*6,</span>i=<span class="cstat-no" title="statement not covered" >o%1,</span>a=<span class="cstat-no" title="statement not covered" >1-i;</span>let c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>switch(Math.floor(o)){case 0:<span class="cstat-no" title="statement not covered" >s[0]=1,s[1]=i,s[2]=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >s[0]=a,s[1]=1,s[2]=0;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >s[0]=0,s[1]=1,s[2]=i;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >s[0]=0,s[1]=a,s[2]=1;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >s[0]=i,s[1]=0,s[2]=1;<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >s[0]=1,s[1]=0,s[2]=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn c=(1-r)*n,[255*(r*s[0]+c),255*(r*s[1]+c),255*(r*s[2]+c)]}</span>,o.hcg.hsv=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>r=<span class="cstat-no" title="statement not covered" >t+e[2]/100*(1-t);</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return r&gt;0&amp;&amp;(n=t/r),[e[0],100*n,100*r]}</span>,o.hcg.hsl=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>r=<span class="cstat-no" title="statement not covered" >e[2]/100*(1-t)+.5*t;</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return r&gt;0&amp;&amp;r&lt;.5?n=t/(2*r):r&gt;=.5&amp;&amp;r&lt;1&amp;&amp;(n=t/(2*(1-r))),[e[0],100*n,100*r]}</span>,o.hcg.hwb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>r=<span class="cstat-no" title="statement not covered" >t+e[2]/100*(1-t);<span class="cstat-no" title="statement not covered" ></span>return[e[0],100*(r-t),100*(1-r)]}</span>,o.hwb.hcg=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >e[1]/100,</span>r=<span class="cstat-no" title="statement not covered" >1-e[2]/100,</span>n=<span class="cstat-no" title="statement not covered" >r-t;</span>let s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return n&lt;1&amp;&amp;(s=(r-n)/(1-n)),[e[0],100*n,100*s]}</span>,o.apple.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[e[0]/65535*255,e[1]/65535*255,e[2]/65535*255]}</span>,o.rgb.apple=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[e[0]/255*65535,e[1]/255*65535,e[2]/255*65535]}</span>,o.gray.rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[e[0]/100*255,e[0]/100*255,e[0]/100*255]}</span>,o.gray.hsl=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[0,0,e[0]]}</span>,o.gray.hsv=o.gray.hsl,o.gray.hwb=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[0,100,e[0]]}</span>,o.gray.cmyk=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[0,0,0,e[0]]}</span>,o.gray.lab=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[e[0],0,0]}</span>,o.gray.hex=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >255&amp;Math.round(e[0]/100*255),</span>r=<span class="cstat-no" title="statement not covered" >((t&lt;&lt;16)+(t&lt;&lt;8)+t).toString(16).toUpperCase();<span class="cstat-no" title="statement not covered" ></span>return"000000".substring(r.length)+r}</span>,o.rgb.gray=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[(e[0]+e[1]+e[2])/3/255*100]}</span>}</span>,2744:<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >r(5311),</span>s=<span class="cstat-no" title="statement not covered" >r(8577),</span>o=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>Object.keys(n).forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >o[e]={},Object.defineProperty(o[e],"channels",{value:n[e].channels}),Object.defineProperty(o[e],"labels",{value:n[e].labels});c</span>onst t=<span class="cstat-no" title="statement not covered" >s(e);<span class="cstat-no" title="statement not covered" ></span>Object.keys(t).forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>o[e][r]=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(...t){const r=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>if(null==r)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >r</span></span>.length&gt;1&amp;&amp;(t=r);c</span>onst n=<span class="cstat-no" title="statement not covered" >e(t);<span class="cstat-no" title="statement not covered" ></span>if("object"==typeof n)<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >n.length,</span>t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;e;t++)<span class="cstat-no" title="statement not covered" >n[t]=Math.round(n[t]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n}</span>;<span class="cstat-no" title="statement not covered" ></span>return"conversion"in e&amp;&amp;(t.conversion=e.conversion),t}</span>(n),o[e][r].raw=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(...t){const r=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>return null==r?r:(r.length&gt;1&amp;&amp;(t=r),e(t))}</span>;<span class="cstat-no" title="statement not covered" ></span>return"conversion"in e&amp;&amp;(t.conversion=e.conversion),t}</span>(n)}</span>)}</span>),e.exports=o}</span>,8577:<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >r(5311);</span>function <span class="fstat-no" title="function not covered" >s(</span>e){const t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const e=<span class="cstat-no" title="statement not covered" >{},</span>t=<span class="cstat-no" title="statement not covered" >Object.keys(n);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >t.length,</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;r;n++)<span class="cstat-no" title="statement not covered" >e[t[n]]={distance:-1,parent:null};<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(),</span>r=<span class="cstat-no" title="statement not covered" >[e];<span class="cstat-no" title="statement not covered" ></span>for(t[e].distance=0;r.length;){const e=<span class="cstat-no" title="statement not covered" >r.pop(),</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(n[e]);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >s.length,</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n;o++){const n=<span class="cstat-no" title="statement not covered" >s[o],</span>i=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>-1===i.distance&amp;&amp;(i.distance=t[e].distance+1,i.parent=e,r.unshift(n))}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >o(</span>e,t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return t(e(r))}</span>}</span>function <span class="fstat-no" title="function not covered" >i(</span>e,t){const r=<span class="cstat-no" title="statement not covered" >[t[e].parent,e];</span>let s=<span class="cstat-no" title="statement not covered" >n[t[e].parent][e],</span>i=<span class="cstat-no" title="statement not covered" >t[e].parent;<span class="cstat-no" title="statement not covered" ></span>for(;t[i].parent;)<span class="cstat-no" title="statement not covered" >r.unshift(t[i].parent),s=o(n[t[i].parent][i],s),i=t[i].parent;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s.conversion=r,s}<span class="cstat-no" title="statement not covered" ></span>e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >s(e),</span>r=<span class="cstat-no" title="statement not covered" >{},</span>n=<span class="cstat-no" title="statement not covered" >Object.keys(t);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >n.length,</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;e;s++){const e=<span class="cstat-no" title="statement not covered" >n[s];<span class="cstat-no" title="statement not covered" ></span>null!==t[e].parent&amp;&amp;(r[e]=i(e,t))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>}</span>,3300:<span class="fstat-no" title="function not covered" >e=</span>&gt;{"use strict";<span class="cstat-no" title="statement not covered" >e.exports={aliceblue:[240,248,255],antiquewhite:[250,235,215],aqua:[0,255,255],aquamarine:[127,255,212],azure:[240,255,255],beige:[245,245,220],bisque:[255,228,196],black:[0,0,0],blanchedalmond:[255,235,205],blue:[0,0,255],blueviolet:[138,43,226],brown:[165,42,42],burlywood:[222,184,135],cadetblue:[95,158,160],chartreuse:[127,255,0],chocolate:[210,105,30],coral:[255,127,80],cornflowerblue:[100,149,237],cornsilk:[255,248,220],crimson:[220,20,60],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgoldenrod:[184,134,11],darkgray:[169,169,169],darkgreen:[0,100,0],darkgrey:[169,169,169],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkseagreen:[143,188,143],darkslateblue:[72,61,139],darkslategray:[47,79,79],darkslategrey:[47,79,79],darkturquoise:[0,206,209],darkviolet:[148,0,211],deeppink:[255,20,147],deepskyblue:[0,191,255],dimgray:[105,105,105],dimgrey:[105,105,105],dodgerblue:[30,144,255],firebrick:[178,34,34],floralwhite:[255,250,240],forestgreen:[34,139,34],fuchsia:[255,0,255],gainsboro:[220,220,220],ghostwhite:[248,248,255],gold:[255,215,0],goldenrod:[218,165,32],gray:[128,128,128],green:[0,128,0],greenyellow:[173,255,47],grey:[128,128,128],honeydew:[240,255,240],hotpink:[255,105,180],indianred:[205,92,92],indigo:[75,0,130],ivory:[255,255,240],khaki:[240,230,140],lavender:[230,230,250],lavenderblush:[255,240,245],lawngreen:[124,252,0],lemonchiffon:[255,250,205],lightblue:[173,216,230],lightcoral:[240,128,128],lightcyan:[224,255,255],lightgoldenrodyellow:[250,250,210],lightgray:[211,211,211],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightsalmon:[255,160,122],lightseagreen:[32,178,170],lightskyblue:[135,206,250],lightslategray:[119,136,153],lightslategrey:[119,136,153],lightsteelblue:[176,196,222],lightyellow:[255,255,224],lime:[0,255,0],limegreen:[50,205,50],linen:[250,240,230],magenta:[255,0,255],maroon:[128,0,0],mediumaquamarine:[102,205,170],mediumblue:[0,0,205],mediumorchid:[186,85,211],mediumpurple:[147,112,219],mediumseagreen:[60,179,113],mediumslateblue:[123,104,238],mediumspringgreen:[0,250,154],mediumturquoise:[72,209,204],mediumvioletred:[199,21,133],midnightblue:[25,25,112],mintcream:[245,255,250],mistyrose:[255,228,225],moccasin:[255,228,181],navajowhite:[255,222,173],navy:[0,0,128],oldlace:[253,245,230],olive:[128,128,0],olivedrab:[107,142,35],orange:[255,165,0],orangered:[255,69,0],orchid:[218,112,214],palegoldenrod:[238,232,170],palegreen:[152,251,152],paleturquoise:[175,238,238],palevioletred:[219,112,147],papayawhip:[255,239,213],peachpuff:[255,218,185],peru:[205,133,63],pink:[255,192,203],plum:[221,160,221],powderblue:[176,224,230],purple:[128,0,128],rebeccapurple:[102,51,153],red:[255,0,0],rosybrown:[188,143,143],royalblue:[65,105,225],saddlebrown:[139,69,19],salmon:[250,128,114],sandybrown:[244,164,96],seagreen:[46,139,87],seashell:[255,245,238],sienna:[160,82,45],silver:[192,192,192],skyblue:[135,206,235],slateblue:[106,90,205],slategray:[112,128,144],slategrey:[112,128,144],snow:[255,250,250],springgreen:[0,255,127],steelblue:[70,130,180],tan:[210,180,140],teal:[0,128,128],thistle:[216,191,216],tomato:[255,99,71],turquoise:[64,224,208],violet:[238,130,238],wheat:[245,222,179],white:[255,255,255],whitesmoke:[245,245,245],yellow:[255,255,0],yellowgreen:[154,205,50]}}</span>,6241:(e,t,r)=&gt;{"use strict";const n=r(5622),s=r(5763),o=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.length&gt;1?`{${e.join(",")}}`:e[0],</span>i=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >"!"===e[0]?e.slice(1):e;<span class="cstat-no" title="statement not covered" ></span>return n.isAbsolute(r)?r:n.join(t,r)}</span>,a=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(t.files&amp;&amp;!Array.isArray(t.files))<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof t.files}\``);<span class="cstat-no" title="statement not covered" >i</span></span>f(t.extensions&amp;&amp;!Array.isArray(t.extensions))<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof t.extensions}\``);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.files&amp;&amp;t.extensions?t.files.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >return n.posix.join(e,(s=r,i=t.extensions,n.extname(s)?"**/"+s:`**/${s}.${o(i)}`));v</span>ar s,i}):t.files?t.files.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >n.posix.join(e,"**/"+t))</span>:t.extensions?[n.posix.join(e,"**/*."+o(t.extensions))]:[n.posix.join(e,"**")]}</span>;e.exports=<span class="fstat-no" title="function not covered" >as</span>ync(e,t)=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof(t={cwd:process.cwd(),...t}).cwd)<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof t.cwd}\``);c</span></span>onst r=<span class="cstat-no" title="statement not covered" >await Promise.all([].concat(e).map(<span class="fstat-no" title="function not covered" >as</span>ync e=&gt;<span class="cstat-no" title="statement not covered" >await s.isDirectory(i(e,t.cwd))?a(e,t):e)</span>);<span class="cstat-no" title="statement not covered" ></span>return[].concat.apply([],r)}</span>,e.exports.sync=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof(t={cwd:process.cwd(),...t}).cwd)<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof t.cwd}\``);c</span></span>onst r=<span class="cstat-no" title="statement not covered" >[].concat(e).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >s.isDirectorySync(i(e,t.cwd))?a(e,t):e)</span>;<span class="cstat-no" title="statement not covered" ></span>return[].concat.apply([],r)}</span>},3802:(e,t,r)=&gt;{"use strict";const n=r(378),s=r(9606),o=r(7956),i=r(6153),a=r(3543),c=r(1168);async function <span class="fstat-no" title="function not covered" >u(</span>e,t){<span class="cstat-no" title="statement not covered" >p(e);c</span>onst r=<span class="cstat-no" title="statement not covered" >l(e,s.default,t),</span>n=<span class="cstat-no" title="statement not covered" >await Promise.all(r);<span class="cstat-no" title="statement not covered" ></span>return c.array.flatten(n)}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,t,r){const s=<span class="cstat-no" title="statement not covered" >[].concat(e),</span>o=<span class="cstat-no" title="statement not covered" >new a.default(r),</span>i=<span class="cstat-no" title="statement not covered" >n.generate(s,o),</span>c=<span class="cstat-no" title="statement not covered" >new t(o);<span class="cstat-no" title="statement not covered" ></span>return i.map(c.read,c)}</span>function <span class="fstat-no" title="function not covered" >p(</span>e){<span class="cstat-no" title="statement not covered" >if(![].concat(e).every(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c.string.isString(e)&amp;&amp;!c.string.isEmpty(e))</span>)<span class="cstat-no" title="statement not covered" >throw new TypeError("Patterns must be a string (non empty) or an array of strings")}</span></span>!function(e){e.sync=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >p(e);c</span>onst r=<span class="cstat-no" title="statement not covered" >l(e,i.default,t);<span class="cstat-no" title="statement not covered" ></span>return c.array.flatten(r)}</span>,e.stream=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >p(e);c</span>onst r=<span class="cstat-no" title="statement not covered" >l(e,o.default,t);<span class="cstat-no" title="statement not covered" ></span>return c.stream.merge(r)}</span>,e.generateTasks=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >p(e);c</span>onst r=<span class="cstat-no" title="statement not covered" >[].concat(e),</span>s=<span class="cstat-no" title="statement not covered" >new a.default(t);<span class="cstat-no" title="statement not covered" ></span>return n.generate(r,s)}</span>,e.isDynamicPattern=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >p(e);c</span>onst r=<span class="cstat-no" title="statement not covered" >new a.default(t);<span class="cstat-no" title="statement not covered" ></span>return c.pattern.isDynamicPattern(e,r)}</span>,e.escapePath=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return p(e),c.path.escape(e)}</span>}(u||(<span class="branch-1 cbranch-no" title="branch not covered" >u={})</span>),e.exports=u},378:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.convertPatternGroupToTask=t.convertPatternGroupsToTasks=t.groupPatternsByBaseDirectory=t.getNegativePatternsAsPositive=t.getPositivePatterns=t.convertPatternsToTasks=t.generate=void 0;const n=r(1168);function <span class="fstat-no" title="function not covered" >s(</span>e,t,r){const n=<span class="cstat-no" title="statement not covered" >a(e);<span class="cstat-no" title="statement not covered" ></span>if("."in n){<span class="cstat-no" title="statement not covered" >return[u(".",e,t,r)]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn c(n,t,r)}</span>function <span class="fstat-no" title="function not covered" >o(</span>e){<span class="cstat-no" title="statement not covered" >return n.pattern.getPositivePatterns(e)}</span>function <span class="fstat-no" title="function not covered" >i(</span>e,t){<span class="cstat-no" title="statement not covered" >return n.pattern.getNegativePatterns(e).concat(t).map(n.pattern.convertToPositivePattern)}</span>function <span class="fstat-no" title="function not covered" >a(</span>e){<span class="cstat-no" title="statement not covered" >return e.reduce(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >n.pattern.getBaseDirectory(t);<span class="cstat-no" title="statement not covered" ></span>return r in e?e[r].push(t):e[r]=[t],e}</span>,{})}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return Object.keys(e).map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >u(n,e[n],t,r))</span>}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t,r,s){<span class="cstat-no" title="statement not covered" >return{dynamic:s,positive:t,negative:r,base:e,patterns:[].concat(t,r.map(n.pattern.convertToNegativePattern))}}</span>t.generate=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const r=<span class="cstat-no" title="statement not covered" >o(e),</span>a=<span class="cstat-no" title="statement not covered" >i(e,t.ignore),</span>c=<span class="cstat-no" title="statement not covered" >r.filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n.pattern.isStaticPattern(e,t))</span>,</span>u=<span class="cstat-no" title="statement not covered" >r.filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n.pattern.isDynamicPattern(e,t))</span>,</span>l=<span class="cstat-no" title="statement not covered" >s(c,a,!1),</span>p=<span class="cstat-no" title="statement not covered" >s(u,a,!0);<span class="cstat-no" title="statement not covered" ></span>return l.concat(p)}</span>,t.convertPatternsToTasks=s,t.getPositivePatterns=o,t.getNegativePatternsAsPositive=i,t.groupPatternsByBaseDirectory=a,t.convertPatternGroupsToTasks=c,t.convertPatternGroupToTask=u},9606:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6722),s=r(2445);class o extends s.default{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this._reader=new n.default(this._settings)}<span class="fstat-no" title="function not covered" ></span>re</span>ad(e){const t=<span class="cstat-no" title="statement not covered" >this._getRootDirectory(e),</span>r=<span class="cstat-no" title="statement not covered" >this._getReaderOptions(e),</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return new Promise(<span class="fstat-no" title="function not covered" >(s</span>,o)=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.api(t,e,r);<span class="cstat-no" title="statement not covered" ></span>i.once("error",o),i.on("data",<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n.push(r.transform(e)))</span>,i.once("end",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s(n))</span>}</span>)}<span class="fstat-no" title="function not covered" ></span>ap</span>i(e,t,r){<span class="cstat-no" title="statement not covered" >return t.dynamic?this._reader.dynamic(e,r):this._reader.static(t.patterns,r)}</span>}t.default=o},3297:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1168),s=r(5071);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this._settings=e,this._micromatchOptions=t}<span class="fstat-no" title="function not covered" ></span>ge</span>tFilter(e,t,r){const n=<span class="cstat-no" title="statement not covered" >this._getMatcher(t),</span>s=<span class="cstat-no" title="statement not covered" >this._getNegativePatternsRe(r);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this._filter(e,t,n,s)}<span class="fstat-no" title="function not covered" ></span></span>_g</span>etMatcher(e){<span class="cstat-no" title="statement not covered" >return new s.default(e,this._settings,this._micromatchOptions)}<span class="fstat-no" title="function not covered" ></span>_g</span>etNegativePatternsRe(e){const t=<span class="cstat-no" title="statement not covered" >e.filter(n.pattern.isAffectDepthOfReadingPattern);<span class="cstat-no" title="statement not covered" ></span>return n.pattern.convertPatternsToRe(t,this._micromatchOptions)}<span class="fstat-no" title="function not covered" ></span>_f</span>ilter(e,t,r,s){<span class="cstat-no" title="statement not covered" >if(this._isSkippedByDeep(e,t.path))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._isSkippedSymbolicLink(t))<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >n.path.removeLeadingDotSegment(t.path);<span class="cstat-no" title="statement not covered" ></span>return!this._isSkippedByPositivePatterns(o,r)&amp;&amp;this._isSkippedByNegativePatterns(o,s)}<span class="fstat-no" title="function not covered" ></span>_i</span>sSkippedByDeep(e,t){<span class="cstat-no" title="statement not covered" >return this._settings.deep!==1/0&amp;&amp;this._getEntryLevel(e,t)&gt;=this._settings.deep}<span class="fstat-no" title="function not covered" ></span>_g</span>etEntryLevel(e,t){const r=<span class="cstat-no" title="statement not covered" >t.split("/").length;<span class="cstat-no" title="statement not covered" ></span>if(""===e)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r-e.split("/").length}<span class="fstat-no" title="function not covered" ></span>_i</span>sSkippedSymbolicLink(e){<span class="cstat-no" title="statement not covered" >return!this._settings.followSymbolicLinks&amp;&amp;e.dirent.isSymbolicLink()}<span class="fstat-no" title="function not covered" ></span>_i</span>sSkippedByPositivePatterns(e,t){<span class="cstat-no" title="statement not covered" >return!this._settings.baseNameMatch&amp;&amp;!t.match(e)}<span class="fstat-no" title="function not covered" ></span>_i</span>sSkippedByNegativePatterns(e,t){<span class="cstat-no" title="statement not covered" >return!n.pattern.matchAny(e,t)}</span>}},3966:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1168);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this._settings=e,this._micromatchOptions=t,this.index=new Map}<span class="fstat-no" title="function not covered" ></span>ge</span>tFilter(e,t){const r=<span class="cstat-no" title="statement not covered" >n.pattern.convertPatternsToRe(e,this._micromatchOptions),</span>s=<span class="cstat-no" title="statement not covered" >n.pattern.convertPatternsToRe(t,this._micromatchOptions);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this._filter(e,r,s)}<span class="fstat-no" title="function not covered" ></span></span>_f</span>ilter(e,t,r){<span class="cstat-no" title="statement not covered" >if(this._settings.unique&amp;&amp;this._isDuplicateEntry(e))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._onlyFileFilter(e)||this._onlyDirectoryFilter(e))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(this._isSkippedByAbsoluteNegativePatterns(e.path,r))<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._settings.baseNameMatch?e.name:e.path,</span>s=<span class="cstat-no" title="statement not covered" >this._isMatchToPatterns(n,t)&amp;&amp;!this._isMatchToPatterns(e.path,r);<span class="cstat-no" title="statement not covered" ></span>return this._settings.unique&amp;&amp;s&amp;&amp;this._createIndexRecord(e),s}<span class="fstat-no" title="function not covered" ></span>_i</span>sDuplicateEntry(e){<span class="cstat-no" title="statement not covered" >return this.index.has(e.path)}<span class="fstat-no" title="function not covered" ></span>_c</span>reateIndexRecord(e){<span class="cstat-no" title="statement not covered" >this.index.set(e.path,void 0)}<span class="fstat-no" title="function not covered" ></span>_o</span>nlyFileFilter(e){<span class="cstat-no" title="statement not covered" >return this._settings.onlyFiles&amp;&amp;!e.dirent.isFile()}<span class="fstat-no" title="function not covered" ></span>_o</span>nlyDirectoryFilter(e){<span class="cstat-no" title="statement not covered" >return this._settings.onlyDirectories&amp;&amp;!e.dirent.isDirectory()}<span class="fstat-no" title="function not covered" ></span>_i</span>sSkippedByAbsoluteNegativePatterns(e,t){<span class="cstat-no" title="statement not covered" >if(!this._settings.absolute)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >n.path.makeAbsolute(this._settings.cwd,e);<span class="cstat-no" title="statement not covered" ></span>return n.pattern.matchAny(r,t)}<span class="fstat-no" title="function not covered" ></span>_i</span>sMatchToPatterns(e,t){const r=<span class="cstat-no" title="statement not covered" >n.path.removeLeadingDotSegment(e);<span class="cstat-no" title="statement not covered" ></span>return n.pattern.matchAny(r,t)}</span>}},6034:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1168);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this._settings=e}<span class="fstat-no" title="function not covered" ></span>ge</span>tFilter(){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this._isNonFatalError(e)}<span class="fstat-no" title="function not covered" ></span></span>_i</span>sNonFatalError(e){<span class="cstat-no" title="statement not covered" >return n.errno.isEnoentCodeError(e)||this._settings.suppressErrors}</span>}},6389:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1168);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,r){<span class="cstat-no" title="statement not covered" >this._patterns=e,this._settings=t,this._micromatchOptions=r,this._storage=[],this._fillStorage()}<span class="fstat-no" title="function not covered" ></span>_f</span>illStorage(){const e=<span class="cstat-no" title="statement not covered" >n.pattern.expandPatternsWithBraceExpansion(this._patterns);<span class="cstat-no" title="statement not covered" ></span>for(const t of e){const e=<span class="cstat-no" title="statement not covered" >this._getPatternSegments(t),</span>r=<span class="cstat-no" title="statement not covered" >this._splitSegmentsIntoSections(e);<span class="cstat-no" title="statement not covered" ></span>this._storage.push({complete:r.length&lt;=1,pattern:t,segments:e,sections:r})}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etPatternSegments(e){<span class="cstat-no" title="statement not covered" >return n.pattern.getPatternParts(e,this._micromatchOptions).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >n.pattern.isDynamicPattern(e,this._settings)?{dynamic:!0,pattern:e,patternRe:n.pattern.makeRe(e,this._micromatchOptions)}:{dynamic:!1,pattern:e})</span>}<span class="fstat-no" title="function not covered" ></span>_s</span>plitSegmentsIntoSections(e){<span class="cstat-no" title="statement not covered" >return n.array.splitWhen(e,<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.dynamic&amp;&amp;n.pattern.hasGlobStar(e.pattern))</span>}</span>}},5071:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(6389);class s extends n.default{<span class="fstat-no" title="function not covered" >ma</span>tch(e){const t=<span class="cstat-no" title="statement not covered" >e.split("/"),</span>r=<span class="cstat-no" title="statement not covered" >t.length,</span>n=<span class="cstat-no" title="statement not covered" >this._storage.filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.complete||e.segments.length&gt;r)</span>;<span class="cstat-no" title="statement not covered" ></span>for(const e of n){const n=<span class="cstat-no" title="statement not covered" >e.sections[0];<span class="cstat-no" title="statement not covered" ></span>if(!e.complete&amp;&amp;r&gt;n.length)<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(t.every(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >e.segments[r];<span class="cstat-no" title="statement not covered" ></span>return!(!n.dynamic||!n.patternRe.test(t))||!n.dynamic&amp;&amp;n.pattern===t}</span>))<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>}t.default=s},2445:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5622),s=r(3297),o=r(3966),i=r(6034),a=r(6642);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this._settings=e,this.errorFilter=new i.default(this._settings),this.entryFilter=new o.default(this._settings,this._getMicromatchOptions()),this.deepFilter=new s.default(this._settings,this._getMicromatchOptions()),this.entryTransformer=new a.default(this._settings)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRootDirectory(e){<span class="cstat-no" title="statement not covered" >return n.resolve(this._settings.cwd,e.base)}<span class="fstat-no" title="function not covered" ></span>_g</span>etReaderOptions(e){const t=<span class="cstat-no" title="statement not covered" >"."===e.base?"":e.base;<span class="cstat-no" title="statement not covered" ></span>return{basePath:t,pathSegmentSeparator:"/",concurrency:this._settings.concurrency,deepFilter:this.deepFilter.getFilter(t,e.positive,e.negative),entryFilter:this.entryFilter.getFilter(e.positive,e.negative),errorFilter:this.errorFilter.getFilter(),followSymbolicLinks:this._settings.followSymbolicLinks,fs:this._settings.fs,stats:this._settings.stats,throwErrorOnBrokenSymbolicLink:this._settings.throwErrorOnBrokenSymbolicLink,transform:this.entryTransformer.getTransformer()}}<span class="fstat-no" title="function not covered" ></span>_g</span>etMicromatchOptions(){<span class="cstat-no" title="statement not covered" >return{dot:this._settings.dot,matchBase:this._settings.baseNameMatch,nobrace:!this._settings.braceExpansion,nocase:!this._settings.caseSensitiveMatch,noext:!this._settings.extglob,noglobstar:!this._settings.globstar,posix:!0,strictSlashes:!1}}</span>}},7956:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2413),s=r(6722),o=r(2445);class i extends o.default{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this._reader=new s.default(this._settings)}<span class="fstat-no" title="function not covered" ></span>re</span>ad(e){const t=<span class="cstat-no" title="statement not covered" >this._getRootDirectory(e),</span>r=<span class="cstat-no" title="statement not covered" >this._getReaderOptions(e),</span>s=<span class="cstat-no" title="statement not covered" >this.api(t,e,r),</span>o=<span class="cstat-no" title="statement not covered" >new n.Readable({objectMode:!0,read:<span class="fstat-no" title="function not covered" >()</span>=&gt;{}});<span class="cstat-no" title="statement not covered" ></span>return s.once("error",<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >o.emit("error",e))</span>.on("data",<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >o.emit("data",r.transform(e)))</span>.once("end",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o.emit("end"))</span>,o.once("close",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s.destroy())</span>,o}<span class="fstat-no" title="function not covered" ></span>ap</span>i(e,t,r){<span class="cstat-no" title="statement not covered" >return t.dynamic?this._reader.dynamic(e,r):this._reader.static(t.patterns,r)}</span>}t.default=i},6153:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(8838),s=r(2445);class o extends s.default{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this._reader=new n.default(this._settings)}<span class="fstat-no" title="function not covered" ></span>re</span>ad(e){const t=<span class="cstat-no" title="statement not covered" >this._getRootDirectory(e),</span>r=<span class="cstat-no" title="statement not covered" >this._getReaderOptions(e);<span class="cstat-no" title="statement not covered" ></span>return this.api(t,e,r).map(r.transform)}<span class="fstat-no" title="function not covered" ></span>ap</span>i(e,t,r){<span class="cstat-no" title="statement not covered" >return t.dynamic?this._reader.dynamic(e,r):this._reader.static(t.patterns,r)}</span>}t.default=o},6642:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(1168);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this._settings=e}<span class="fstat-no" title="function not covered" ></span>ge</span>tTransformer(){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this._transform(e)}<span class="fstat-no" title="function not covered" ></span></span>_t</span>ransform(e){let t=<span class="cstat-no" title="statement not covered" >e.path;<span class="cstat-no" title="statement not covered" ></span>return this._settings.absolute&amp;&amp;(t=n.path.makeAbsolute(this._settings.cwd,t),t=n.path.unixify(t)),this._settings.markDirectories&amp;&amp;e.dirent.isDirectory()&amp;&amp;(t+="/"),this._settings.objectMode?Object.assign(Object.assign({},e),{path:t}):t}</span>}},586:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(5622),s=r(3403),o=r(1168);t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >this._settings=e,this._fsStatSettings=new s.Settings({followSymbolicLink:this._settings.followSymbolicLinks,fs:this._settings.fs,throwErrorOnBrokenSymbolicLink:this._settings.followSymbolicLinks})}<span class="fstat-no" title="function not covered" ></span>_g</span>etFullEntryPath(e){<span class="cstat-no" title="statement not covered" >return n.resolve(this._settings.cwd,e)}<span class="fstat-no" title="function not covered" ></span>_m</span>akeEntry(e,t){const r=<span class="cstat-no" title="statement not covered" >{name:t,path:t,dirent:o.fs.createDirentFromStats(t,e)};<span class="cstat-no" title="statement not covered" ></span>return this._settings.stats&amp;&amp;(r.stats=e),r}<span class="fstat-no" title="function not covered" ></span>_i</span>sFatalError(e){<span class="cstat-no" title="statement not covered" >return!o.errno.isEnoentCodeError(e)&amp;&amp;!this._settings.suppressErrors}</span>}},6722:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(2413),s=r(3403),o=r(3011),i=r(586);class a extends i.default{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this._walkStream=o.walkStream,this._stat=s.stat}<span class="fstat-no" title="function not covered" ></span>dy</span>namic(e,t){<span class="cstat-no" title="statement not covered" >return this._walkStream(e,t)}<span class="fstat-no" title="function not covered" ></span>st</span>atic(e,t){const r=<span class="cstat-no" title="statement not covered" >e.map(this._getFullEntryPath,this),</span>s=<span class="cstat-no" title="statement not covered" >new n.PassThrough({objectMode:!0});<span class="cstat-no" title="statement not covered" ></span>s._write=<span class="fstat-no" title="function not covered" >(n</span>,o,i)=&gt;<span class="cstat-no" title="statement not covered" >this._getEntry(r[n],e[n],t).then(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >null!==e&amp;&amp;t.entryFilter(e)&amp;&amp;s.push(e),n===r.length-1&amp;&amp;s.end(),i()}</span>).catch(i);<span class="cstat-no" title="statement not covered" ></span>f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;r.length;e++)<span class="cstat-no" title="statement not covered" >s.write(e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}<span class="fstat-no" title="function not covered" ></span>_g</span>etEntry(e,t,r){<span class="cstat-no" title="statement not covered" >return this._getStat(e).then(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >this._makeEntry(e,t))</span>.catch(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(r.errorFilter(e))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span></span>hrow e}</span>)}<span class="fstat-no" title="function not covered" ></span>_g</span>etStat(e){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{<span class="cstat-no" title="statement not covered" >this._stat(e,this._fsStatSettings,<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >null===e?t(n):r(e))</span>}</span>)}</span>}t.default=a},8838:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0});const n=r(3403),s=r(3011),o=r(586);class i extends o.default{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this._walkSync=s.walkSync,this._statSync=n.statSync}<span class="fstat-no" title="function not covered" ></span>dy</span>namic(e,t){<span class="cstat-no" title="statement not covered" >return this._walkSync(e,t)}<span class="fstat-no" title="function not covered" ></span>st</span>atic(e,t){const r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const n of e){const e=<span class="cstat-no" title="statement not covered" >this._getFullEntryPath(n),</span>s=<span class="cstat-no" title="statement not covered" >this._getEntry(e,n,t);<span class="cstat-no" title="statement not covered" ></span>null!==s&amp;&amp;t.entryFilter(s)&amp;&amp;r.push(s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}<span class="fstat-no" title="function not covered" ></span>_g</span>etEntry(e,t,r){<span class="cstat-no" title="statement not covered" >try{const r=<span class="cstat-no" title="statement not covered" >this._getStat(e);<span class="cstat-no" title="statement not covered" ></span>return this._makeEntry(r,t)}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(r.errorFilter(e))<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" >t</span></span>hrow e}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etStat(e){<span class="cstat-no" title="statement not covered" >return this._statSync(e,this._fsStatSettings)}</span>}t.default=i},3543:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.DEFAULT_FILE_SYSTEM_ADAPTER=void 0;const n=r(5747),s=r(2087).cpus().length;t.DEFAULT_FILE_SYSTEM_ADAPTER={lstat:n.lstat,lstatSync:n.lstatSync,stat:n.stat,statSync:n.statSync,readdir:n.readdir,readdirSync:n.readdirSync};t.default=class{<span class="fstat-no" title="function not covered" >co</span>nstructor(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this._options=e,this.absolute=this._getValue(this._options.absolute,!1),this.baseNameMatch=this._getValue(this._options.baseNameMatch,!1),this.braceExpansion=this._getValue(this._options.braceExpansion,!0),this.caseSensitiveMatch=this._getValue(this._options.caseSensitiveMatch,!0),this.concurrency=this._getValue(this._options.concurrency,s),this.cwd=this._getValue(this._options.cwd,process.cwd()),this.deep=this._getValue(this._options.deep,1/0),this.dot=this._getValue(this._options.dot,!1),this.extglob=this._getValue(this._options.extglob,!0),this.followSymbolicLinks=this._getValue(this._options.followSymbolicLinks,!0),this.fs=this._getFileSystemMethods(this._options.fs),this.globstar=this._getValue(this._options.globstar,!0),this.ignore=this._getValue(this._options.ignore,[]),this.markDirectories=this._getValue(this._options.markDirectories,!1),this.objectMode=this._getValue(this._options.objectMode,!1),this.onlyDirectories=this._getValue(this._options.onlyDirectories,!1),this.onlyFiles=this._getValue(this._options.onlyFiles,!0),this.stats=this._getValue(this._options.stats,!1),this.suppressErrors=this._getValue(this._options.suppressErrors,!1),this.throwErrorOnBrokenSymbolicLink=this._getValue(this._options.throwErrorOnBrokenSymbolicLink,!1),this.unique=this._getValue(this._options.unique,!0),this.onlyDirectories&amp;&amp;(this.onlyFiles=!1),this.stats&amp;&amp;(this.objectMode=!0)}<span class="fstat-no" title="function not covered" ></span>_g</span>etValue(e,t){<span class="cstat-no" title="statement not covered" >return void 0===e?t:e}<span class="fstat-no" title="function not covered" ></span>_g</span>etFileSystemMethods(e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return Object.assign(Object.assign({},t.DEFAULT_FILE_SYSTEM_ADAPTER),e)}</span>}},5761:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.splitWhen=t.flatten=void 0,t.flatten=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.reduce(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >[].concat(e,t),</span>[])}</span>,t.splitWhen=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){const r=<span class="cstat-no" title="statement not covered" >[[]];</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const s of e)<span class="cstat-no" title="statement not covered" >t(s)?(n++,r[n]=[]):r[n].push(s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>},5153:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isEnoentCodeError=void 0,t.isEnoentCodeError=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"ENOENT"===e.code}</span>},6208:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createDirentFromStats=void 0;class r{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t){<span class="cstat-no" title="statement not covered" >this.name=e,this.isBlockDevice=t.isBlockDevice.bind(t),this.isCharacterDevice=t.isCharacterDevice.bind(t),this.isDirectory=t.isDirectory.bind(t),this.isFIFO=t.isFIFO.bind(t),this.isFile=t.isFile.bind(t),this.isSocket=t.isSocket.bind(t),this.isSymbolicLink=t.isSymbolicLink.bind(t)}</span>}t.createDirentFromStats=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return new r(e,t)}</span>},1168:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.string=t.stream=t.pattern=t.path=t.fs=t.errno=t.array=void 0;const n=r(5761);t.array=n;const s=r(5153);t.errno=s;const o=r(6208);t.fs=o;const i=r(1952);t.path=i;const a=r(6084);t.pattern=a;const c=r(7710);t.stream=c;const u=r(8716);t.string=u},1952:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.removeLeadingDotSegment=t.escape=t.makeAbsolute=t.unixify=void 0;const n=r(5622),s=/(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;t.unixify=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.replace(/\\/g,"/")}</span>,t.makeAbsolute=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return n.resolve(e,t)}</span>,t.escape=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.replace(s,"\\$2")}</span>,t.removeLeadingDotSegment=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("."===e.charAt(0)){const t=<span class="cstat-no" title="statement not covered" >e.charAt(1);<span class="cstat-no" title="statement not covered" ></span>if("/"===t||"\\"===t)<span class="cstat-no" title="statement not covered" >return e.slice(2)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e}</span>},6084:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.matchAny=t.convertPatternsToRe=t.makeRe=t.getPatternParts=t.expandBraceExpansion=t.expandPatternsWithBraceExpansion=t.isAffectDepthOfReadingPattern=t.endsWithSlashGlobStar=t.hasGlobStar=t.getBaseDirectory=t.getPositivePatterns=t.getNegativePatterns=t.isPositivePattern=t.isNegativePattern=t.convertToNegativePattern=t.convertToPositivePattern=t.isDynamicPattern=t.isStaticPattern=void 0;const n=r(5622),s=r(3340),o=r(2401),i=r(4722),a=/[*?]|^!/,c=/\[.*]/,u=/(?:^|[^!*+?@])\(.*\|.*\)/,l=/[!*+?@]\(.*\)/,p=/{.*(?:,|\.\.).*}/;function <span class="fstat-no" title="function not covered" >f(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return!h(e,t)}</span>function <span class="fstat-no" title="function not covered" >h(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return""!==e&amp;&amp;(!(!1!==t.caseSensitiveMatch&amp;&amp;!e.includes("\\"))||(!!(a.test(e)||c.test(e)||u.test(e))||(!(!1===t.extglob||!l.test(e))||!(!1===t.braceExpansion||!p.test(e)))))}</span>function <span class="fstat-no" title="function not covered" >d(</span>e){<span class="cstat-no" title="statement not covered" >return e.startsWith("!")&amp;&amp;"("!==e[1]}</span>function <span class="fstat-no" title="function not covered" >g(</span>e){<span class="cstat-no" title="statement not covered" >return!d(e)}</span>function <span class="fstat-no" title="function not covered" >y(</span>e){<span class="cstat-no" title="statement not covered" >return e.endsWith("/**")}</span>function <span class="fstat-no" title="function not covered" >_(</span>e){<span class="cstat-no" title="statement not covered" >return o.braces(e,{expand:!0,nodupes:!0})}</span>function <span class="fstat-no" title="function not covered" >E(</span>e,t){<span class="cstat-no" title="statement not covered" >return o.makeRe(e,t)}</span>t.isStaticPattern=f,t.isDynamicPattern=h,t.convertToPositivePattern=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return d(e)?e.slice(1):e}</span>,t.convertToNegativePattern=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"!"+e}</span>,t.isNegativePattern=d,t.isPositivePattern=g,t.getNegativePatterns=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.filter(d)}</span>,t.getPositivePatterns=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.filter(g)}</span>,t.getBaseDirectory=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return s(e,{flipBackslashes:!1})}</span>,t.hasGlobStar=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.includes("**")}</span>,t.endsWithSlashGlobStar=y,t.isAffectDepthOfReadingPattern=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >n.basename(e);<span class="cstat-no" title="statement not covered" ></span>return y(e)||f(t)}</span>,t.expandPatternsWithBraceExpansion=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.reduce(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e.concat(_(t)),</span>[])}</span>,t.expandBraceExpansion=_,t.getPatternParts=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let{parts:r}=<span class="cstat-no" title="statement not covered" >i.scan(e,Object.assign(Object.assign({},t),{parts:!0}));<span class="cstat-no" title="statement not covered" ></span>return 0===r.length&amp;&amp;(r=[e]),r[0].startsWith("/")&amp;&amp;(r[0]=r[0].slice(1),r.unshift("")),r}</span>,t.makeRe=E,t.convertPatternsToRe=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >E(e,t))</span>}</span>,t.matchAny=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t.some(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.test(e))</span>}</span>},7710:(e,t,r)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.merge=void 0;const n=r(7308);function <span class="fstat-no" title="function not covered" >s(</span>e){<span class="cstat-no" title="statement not covered" >e.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.emit("close"))</span>}</span>t.merge=<span class="fstat-no" title="function not covered" >fu</span>nction(e){const t=<span class="cstat-no" title="statement not covered" >n(e);<span class="cstat-no" title="statement not covered" ></span>return e.forEach(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.once("error",<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.emit("error",e))</span>}</span>),t.once("close",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s(e))</span>,t.once("end",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s(e))</span>,t}</span>},8716:(e,t)=&gt;{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.isEmpty=t.isString=void 0,t.isString=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"string"==typeof e}</span>,t.isEmpty=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return""===e}</span>},1391:(e,t,r)=&gt;{"use strict";var n=r(2383);function <span class="fstat-no" title="function not covered" >s(</span>){}function <span class="fstat-no" title="function not covered" >o(</span>){<span class="cstat-no" title="statement not covered" >this.value=null,this.callback=s,this.next=null,this.release=s,this.context=null;v</span>ar e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.worked=<span class="fstat-no" title="function not covered" >fu</span>nction(t,r){var n=<span class="cstat-no" title="statement not covered" >e.callback;<span class="cstat-no" title="statement not covered" ></span>e.value=null,e.callback=s,n.call(e.context,t,r),e.release(e)}</span>}</span>e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){<span class="cstat-no" title="statement not covered" >"function"==typeof e&amp;&amp;(r=t,t=e,e=null);v</span>ar i=<span class="cstat-no" title="statement not covered" >n(o),</span>a=<span class="cstat-no" title="statement not covered" >null,</span>c=<span class="cstat-no" title="statement not covered" >null,</span>u=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >{push:<span class="fstat-no" title="function not covered" >fu</span>nction(r,n){var o=<span class="cstat-no" title="statement not covered" >i.get();<span class="cstat-no" title="statement not covered" ></span>o.context=e,o.release=p,o.value=r,o.callback=n||s,u===l.concurrency||l.paused?c?(c.next=o,c=o):(a=o,c=o,l.saturated()):(u++,t.call(e,o.value,o.worked))}</span>,drain:s,saturated:s,pause:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l.paused=!0}</span>,paused:!1,concurrency:r,running:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return u}</span>,resume:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(!l.paused)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >l</span></span>.paused=!1;<span class="cstat-no" title="statement not covered" >f</span>or(var e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;l.concurrency;e++)<span class="cstat-no" title="statement not covered" >u++,p()}</span></span>,idle:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return 0===u&amp;&amp;0===l.length()}</span>,length:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >a,</span>t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;e;)<span class="cstat-no" title="statement not covered" >e=e.next,t++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,getQueue:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >a,</span>t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(;e;)<span class="cstat-no" title="statement not covered" >t.push(e.value),e=e.next;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>,unshift:<span class="fstat-no" title="function not covered" >fu</span>nction(r,n){var o=<span class="cstat-no" title="statement not covered" >i.get();<span class="cstat-no" title="statement not covered" ></span>o.context=e,o.release=p,o.value=r,o.callback=n||s,u===l.concurrency||l.paused?a?(o.next=a,a=o):(a=o,c=o,l.saturated()):(u++,t.call(e,o.value,o.worked))}</span>,empty:s,kill:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a=null,c=null,l.drain=s}</span>,killAndDrain:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a=null,c=null,l.drain(),l.drain=s}</span>};<span class="cstat-no" title="statement not covered" ></span>return l;f</span>unction <span class="fstat-no" title="function not covered" >p(</span>r){<span class="cstat-no" title="statement not covered" >r&amp;&amp;i.release(r);v</span>ar n=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>n?l.paused?u--:(c===a&amp;&amp;(c=null),a=n.next,n.next=null,t.call(e,n.value,n.worked),null===c&amp;&amp;l.empty()):0==--u&amp;&amp;l.drain()}</span>}},2169:(e,t,r)=&gt;{"use strict";
/*!
 * fill-range &lt;https://github.com/jonschlinkert/fill-range&gt;
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */const n=r(1669),s=r(4615),o=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >null!==e&amp;&amp;"object"==typeof e&amp;&amp;!Array.isArray(e),</span>i=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"number"==typeof e||"string"==typeof e&amp;&amp;""!==e,</span>a=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Number.isInteger(+e),</span>c=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >""+e,</span>r=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>if("-"===t[0]&amp;&amp;(t=t.slice(1)),"0"===t)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(;"0"===t[++r];);<span class="cstat-no" title="statement not covered" >r</span>eturn r&gt;0}</span>,u=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(t&gt;0){let r=<span class="cstat-no" title="statement not covered" >"-"===e[0]?"-":"";<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(e=e.slice(1)),e=r+e.padStart(r?t-1:t,"0")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1===r?String(e):e}</span>,l=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >"-"===e[0]?"-":"";<span class="cstat-no" title="statement not covered" ></span>for(r&amp;&amp;(e=e.slice(1),t--);e.length&lt;t;)<span class="cstat-no" title="statement not covered" >e="0"+e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r?"-"+e:e}</span>,p=<span class="fstat-no" title="function not covered" >(e</span>,t,r,n)=&gt;{<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >return s(e,t,{wrap:!1,...n});l</span></span>et o=<span class="cstat-no" title="statement not covered" >String.fromCharCode(e);<span class="cstat-no" title="statement not covered" ></span>return e===t?o:`[${o}-${String.fromCharCode(t)}]`}</span>,f=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(Array.isArray(e)){let t=<span class="cstat-no" title="statement not covered" >!0===r.wrap,</span>n=<span class="cstat-no" title="statement not covered" >r.capture?"":"?:";<span class="cstat-no" title="statement not covered" ></span>return t?`(${n}${e.join("|")})`:e.join("|")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s(e,t,r)}</span>,h=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >new RangeError("Invalid range arguments: "+n.inspect(...e)),</span>d=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(!0===r.strictRanges)<span class="cstat-no" title="statement not covered" >throw h([e,t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[]}</span>,g=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let s=<span class="cstat-no" title="statement not covered" >Number(e),</span>o=<span class="cstat-no" title="statement not covered" >Number(t);<span class="cstat-no" title="statement not covered" ></span>if(!Number.isInteger(s)||!Number.isInteger(o)){<span class="cstat-no" title="statement not covered" >if(!0===n.strictRanges)<span class="cstat-no" title="statement not covered" >throw h([e,t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[]}<span class="cstat-no" title="statement not covered" ></span>0</span>===s&amp;&amp;(s=0),0===o&amp;&amp;(o=0);l</span>et i=<span class="cstat-no" title="statement not covered" >s&gt;o,</span>a=<span class="cstat-no" title="statement not covered" >String(e),</span>d=<span class="cstat-no" title="statement not covered" >String(t),</span>g=<span class="cstat-no" title="statement not covered" >String(r);<span class="cstat-no" title="statement not covered" ></span>r=Math.max(Math.abs(r),1);l</span>et y=<span class="cstat-no" title="statement not covered" >c(a)||c(d)||c(g),</span>_=<span class="cstat-no" title="statement not covered" >y?Math.max(a.length,d.length,g.length):0,</span>E=<span class="cstat-no" title="statement not covered" >!1===y&amp;&amp;!1===(<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof e||"string"==typeof t||!0===r.stringify)</span>(e,t,n),</span>m=<span class="cstat-no" title="statement not covered" >n.transform||(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!0===e?Number(t):String(t))</span></span>(E);<span class="cstat-no" title="statement not covered" ></span>if(n.toRegex&amp;&amp;1===r)<span class="cstat-no" title="statement not covered" >return p(l(e,_),l(t,_),!0,n);l</span></span>et b=<span class="cstat-no" title="statement not covered" >{negatives:[],positives:[]},</span>v=<span class="cstat-no" title="statement not covered" >[],</span>S=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i?s&gt;=o:s&lt;=o;)<span class="cstat-no" title="statement not covered" >!0===n.toRegex&amp;&amp;r&gt;1?b[(R=s)&lt;0?"negatives":"positives"].push(Math.abs(R)):v.push(u(m(s,S),_,E)),s=i?s-r:s+r,S++;v</span></span>ar R;<span class="cstat-no" title="statement not covered" >return!0===n.toRegex?r&gt;1?(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >e.negatives.sort(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;t?-1:e&gt;t?1:0)</span>,e.positives.sort(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;t?-1:e&gt;t?1:0)</span>;l</span>et r,n=<span class="cstat-no" title="statement not covered" >t.capture?"":"?:",</span>s=<span class="cstat-no" title="statement not covered" >"",</span>o=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e.positives.length&amp;&amp;(s=e.positives.join("|")),e.negatives.length&amp;&amp;(o=`-(${n}${e.negatives.join("|")})`),r=s&amp;&amp;o?`${s}|${o}`:s||o,t.wrap?`(${n}${r})`:r}</span>)(b,n):f(v,null,{wrap:!1,...n}):v}</span>,y=<span class="fstat-no" title="function not covered" >(e</span>,t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(null==t&amp;&amp;i(e))<span class="cstat-no" title="statement not covered" >return[e];<span class="cstat-no" title="statement not covered" >i</span></span>f(!i(e)||!i(t))<span class="cstat-no" title="statement not covered" >return d(e,t,n);<span class="cstat-no" title="statement not covered" >i</span></span>f("function"==typeof r)<span class="cstat-no" title="statement not covered" >return y(e,t,1,{transform:r});<span class="cstat-no" title="statement not covered" >i</span></span>f(o(r))<span class="cstat-no" title="statement not covered" >return y(e,t,0,r);l</span></span>et s=<span class="cstat-no" title="statement not covered" >{...n};<span class="cstat-no" title="statement not covered" ></span>return!0===s.capture&amp;&amp;(s.wrap=!0),r=r||s.step||1,a(r)?a(e)&amp;&amp;a(t)?g(e,t,r,s):(<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!a(e)&amp;&amp;e.length&gt;1||!a(t)&amp;&amp;t.length&gt;1)<span class="cstat-no" title="statement not covered" >return d(e,t,n);l</span></span>et s=<span class="cstat-no" title="statement not covered" >n.transform||(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >String.fromCharCode(e))</span>,</span>o=<span class="cstat-no" title="statement not covered" >(""+e).charCodeAt(0),</span>i=<span class="cstat-no" title="statement not covered" >(""+t).charCodeAt(0),</span>c=<span class="cstat-no" title="statement not covered" >o&gt;i,</span>u=<span class="cstat-no" title="statement not covered" >Math.min(o,i),</span>l=<span class="cstat-no" title="statement not covered" >Math.max(o,i);<span class="cstat-no" title="statement not covered" ></span>if(n.toRegex&amp;&amp;1===r)<span class="cstat-no" title="statement not covered" >return p(u,l,!1,n);l</span></span>et h=<span class="cstat-no" title="statement not covered" >[],</span>g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;c?o&gt;=i:o&lt;=i;)<span class="cstat-no" title="statement not covered" >h.push(s(o,g)),o=c?o-r:o+r,g++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!0===n.toRegex?f(h,null,{wrap:!1,options:n}):h}</span>)(e,t,Math.max(Math.abs(r),1),s):null==r||o(r)?y(e,t,1,r):(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(!0===t.strictRanges)<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected step "${e}" to be a number`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[]}</span>)(r,s)}</span>;e.exports=y},3340:(e,t,r)=&gt;{"use strict";var n=r(8193),s=r(5622).posix.dirname,o="win32"===r(2087).platform(),i=/\\/g,a=/[\{\[].*[\/]*.*[\}\]]$/,c=/(^|[^\\])([\{\[]|\([^\)]+$)/,u=/\\([\!\*\?\|\[\]\(\)\{\}])/g;e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >Object.assign({flipBackslashes:!0},t).flipBackslashes&amp;&amp;o&amp;&amp;e.indexOf("/")&lt;0&amp;&amp;(e=e.replace(i,"/")),a.test(e)&amp;&amp;(e+="/"),e+="a";<span class="cstat-no" title="statement not covered" >d</span>o{<span class="cstat-no" title="statement not covered" >e=s(e)}</span>while(n(e)||c.test(e));<span class="cstat-no" title="statement not covered" >r</span>eturn e.replace(u,"$1")}</span>},734:(e,t,r)=&gt;{"use strict";const{promisify:n}=r(1669),s=r(5747),o=r(5622),i=r(3802),a=r(635),c=r(7234),u=["**/node_modules/**","**/flow-typed/**","**/coverage/**","**/.git"],l=n(s.readFile),p=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >c(o.relative(t.cwd,o.dirname(t.fileName)));<span class="cstat-no" title="statement not covered" ></span>return e.split(/\r?\n/).filter(Boolean).filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.startsWith("#"))</span>.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.startsWith("!")?"!"+o.posix.join(e,t.slice(1)):o.posix.join(e,t))</span></span>(r))}</span>,f=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.reduce(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;(<span class="cstat-no" title="statement not covered" >e.add(p(t.content,{cwd:t.cwd,fileName:t.filePath})),e)</span>,a()),</span>h=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >e.ignores(c(o.relative(t,(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(e=c(e),o.isAbsolute(t)){<span class="cstat-no" title="statement not covered" >if(t.startsWith(e))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error(`Path ${t} is not in cwd ${e}`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.join(e,t)}</span>)(t,r)))),</span></span>d=<span class="fstat-no" title="function not covered" >({</span>ignore:e=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>cwd:t=<span class="branch-0 cbranch-no" title="branch not covered" >c(process.cwd())}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;(<span class="cstat-no" title="statement not covered" >{ignore:e,cwd:t})</span>;e.exports=<span class="fstat-no" title="function not covered" >as</span>ync e=&gt;{<span class="cstat-no" title="statement not covered" >e=d(e);c</span>onst t=<span class="cstat-no" title="statement not covered" >await i("**/.gitignore",{ignore:u.concat(e.ignore),cwd:e.cwd}),</span>r=<span class="cstat-no" title="statement not covered" >await Promise.all(t.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >as</span>ync(e,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >o.join(t,e);<span class="cstat-no" title="statement not covered" ></span>return{cwd:t,filePath:r,content:await l(r,"utf8")}}</span>)(t,e.cwd))</span>),</span>n=<span class="cstat-no" title="statement not covered" >f(r);<span class="cstat-no" title="statement not covered" ></span>return h(n,e.cwd)}</span>,e.exports.sync=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e=d(e);c</span>onst t=<span class="cstat-no" title="statement not covered" >i.sync("**/.gitignore",{ignore:u.concat(e.ignore),cwd:e.cwd}).map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >o.join(t,e);<span class="cstat-no" title="statement not covered" ></span>return{cwd:t,filePath:r,content:s.readFileSync(r,"utf8")}}</span>)(t,e.cwd))</span>,</span>r=<span class="cstat-no" title="statement not covered" >f(t);<span class="cstat-no" title="statement not covered" ></span>return h(r,e.cwd)}</span>},8592:(e,t,r)=&gt;{"use strict";const n=r(5747),s=r(9920),o=r(7308),i=r(3802),a=r(6241),c=r(734),{FilterStream:u,UniqueStream:l}=r(6160),p=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1,</span>f=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"!"===e[0],</span>h=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e.every(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof e)</span>)<span class="cstat-no" title="statement not covered" >throw new TypeError("Patterns must be a string or an array of strings")}</span></span>)(e=s([].concat(e))),(<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!e.cwd)<span class="cstat-no" title="statement not covered" >return;l</span></span>et t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=n.statSync(e.cwd)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!t.isDirectory())<span class="cstat-no" title="statement not covered" >throw new Error("The `cwd` option must be a path to a directory")}</span></span>)(t);c</span>onst r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t={ignore:[],expandDirectories:!0,...t};<span class="cstat-no" title="statement not covered" >f</span>or(const[n,s]of e.entries()){<span class="cstat-no" title="statement not covered" >if(f(s))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e.slice(n).filter(f).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.slice(1))</span>,</span>i=<span class="cstat-no" title="statement not covered" >{...t,ignore:t.ignore.concat(o)};<span class="cstat-no" title="statement not covered" ></span>r.push({pattern:s,options:i})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,d=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e.options.expandDirectories?(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return e.options.cwd&amp;&amp;(r.cwd=e.options.cwd),Array.isArray(e.options.expandDirectories)?r={...r,files:e.options.expandDirectories}:"object"==typeof e.options.expandDirectories&amp;&amp;(r={...r,...e.options.expandDirectories}),t(e.pattern,r)}</span>)(e,t):[e.pattern],</span>g=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.gitignore?c.sync({cwd:e.cwd,ignore:e.ignore}):p,</span>y=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const{options:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return r.ignore&amp;&amp;Array.isArray(r.ignore)&amp;&amp;r.expandDirectories&amp;&amp;(r.ignore=a.sync(r.ignore)),{pattern:t,options:r}}</span>;</span>e.exports=<span class="fstat-no" title="function not covered" >as</span>ync(e,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >h(e,t),</span>[o,u]=<span class="cstat-no" title="statement not covered" >await Promise.all([(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.gitignore?c({cwd:t.cwd,ignore:t.ignore}):p)</span>(),(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{const e=<span class="cstat-no" title="statement not covered" >await Promise.all(r.map(<span class="fstat-no" title="function not covered" >as</span>ync e=&gt;{const t=<span class="cstat-no" title="statement not covered" >await d(e,a);<span class="cstat-no" title="statement not covered" ></span>return Promise.all(t.map(y(e)))}</span>));<span class="cstat-no" title="statement not covered" ></span>return s(...e)}</span>)()]),</span>l=<span class="cstat-no" title="statement not covered" >await Promise.all(u.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i(e.pattern,e.options))</span>);<span class="cstat-no" title="statement not covered" ></span>return s(...l).filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >return!o((t=e,t.stats instanceof n.Stats?t.path:t));v</span>ar t})}</span>,e.exports.sync=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >h(e,t).reduce(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >d(t,a.sync).map(y(t));<span class="cstat-no" title="statement not covered" ></span>return e.concat(r)}</span>,[]),</span>n=<span class="cstat-no" title="statement not covered" >g(t);<span class="cstat-no" title="statement not covered" ></span>return r.reduce(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >s(e,i.sync(t.pattern,t.options)),</span>[]).filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!n(e))</span>}</span>,e.exports.stream=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >h(e,t).reduce(<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >d(t,a.sync).map(y(t));<span class="cstat-no" title="statement not covered" ></span>return e.concat(r)}</span>,[]),</span>n=<span class="cstat-no" title="statement not covered" >g(t),</span>s=<span class="cstat-no" title="statement not covered" >new u(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!n(e))</span>,</span>c=<span class="cstat-no" title="statement not covered" >new l;<span class="cstat-no" title="statement not covered" ></span>return o(r.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i.stream(e.pattern,e.options))</span>).pipe(s).pipe(c)}</span>,e.exports.generateGlobTasks=h,e.exports.hasMagic=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >[].concat(e).some(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i.isDynamicPattern(e,t))</span>,</span>e.exports.gitignore=c},6160:(e,t,r)=&gt;{"use strict";const{Transform:n}=r(2413);class s extends n{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super({objectMode:!0})}</span>}e.exports={FilterStream:class extends s{<span class="fstat-no" title="function not covered" >co</span>nstructor(e){<span class="cstat-no" title="statement not covered" >super(),this._filter=e}<span class="fstat-no" title="function not covered" ></span>_t</span>ransform(e,t,r){<span class="cstat-no" title="statement not covered" >this._filter(e)&amp;&amp;this.push(e),r()}</span>},UniqueStream:class extends s{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(),this._pushed=new Set}<span class="fstat-no" title="function not covered" ></span>_t</span>ransform(e,t,r){<span class="cstat-no" title="statement not covered" >this._pushed.has(e)||(this.push(e),this._pushed.add(e)),r()}</span>}}},2918:e=&gt;{"use strict";e.exports=(e,t=process.argv)=&gt;{const r=e.startsWith("-")?<span class="branch-0 cbranch-no" title="branch not covered" >"":</span>1===e.length?<span class="branch-0 cbranch-no" title="branch not covered" >"-":</span>"--",n=t.indexOf(r+e),s=t.indexOf("--");return-1!==n&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >-1===s|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >n&lt;s)</span>}},635:e=&gt;{function <span class="fstat-no" title="function not covered" >t(</span>e){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)?e:[e]}</span>const r=/^\s+$/,n=/^\\!/,s=/^\\#/,o=/\r?\n/g,i=/^\.*\/|^\.+$/,a="undefined"!=typeof Symbol?Symbol.for("node-ignore"):<span class="branch-1 cbranch-no" title="branch not covered" >"node-ignore",</span>c=/([0-z])-([0-z])/g,u=[[/\\?\s+$/,<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >0===e.indexOf("\\")?" ":""]</span>,[/\\\s/g,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >" "]</span>,[/[\\$.|*+(){^]/g,<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"\\"+e]</span>,[/(?!\\)\?/g,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"[^/]"]</span>,[/^\//,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"^"]</span>,[/\//g,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"\\/"]</span>,[/^\^*\\\*\\\*\\\//,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"^(?:.*\\/)?"]</span>,[/^(?=[^^])/,<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return/\/(?!$)/.test(this)?"^":"(?:^|\\/)"}</span>],[/\\\/\\\*\\\*(?=\\\/|$)/g,<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >t+6&lt;r.length?"(?:\\/[^\\/]+)*":"\\/.+"]</span>,[/(^|[^\\]+)\\\*(?=.+)/g,<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >t+"[^\\/]*"]</span>,[/\\\\\\(?=[$.|*+(){^])/g,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"\\"]</span>,[/\\\\/g,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >"\\"]</span>,[/(\\)?\[([^\]/]*?)(\\*)($|\])/g,<span class="fstat-no" title="function not covered" >(e</span>,t,r,n,s)=&gt;<span class="cstat-no" title="statement not covered" >"\\"===t?`\\[${r}${(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const{length:t}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return e.slice(0,t-t%2)}</span>)(n)}${s}`:"]"===s&amp;&amp;n.length%2==0?`[${(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.replace(c,<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >t.charCodeAt(0)&lt;=r.charCodeAt(0)?e:"")</span>)</span>(r)}${n}]`:"[]"]</span>,[/(?:[^*])$/,<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >/\/$/.test(e)?e+"$":e+"(?=$|\\/$)"]</span>,[/(\^|\\\/)?\\\*$/,<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >(t?t+"[^/]+":"[^/]*")+"(?=$|\\/$)"]</span>],l=Object.create(null),p=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof e;</span>class f{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,r,n){<span class="cstat-no" title="statement not covered" >this.origin=e,this.pattern=t,this.negative=r,this.regex=n}</span>}const h=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >e;</span>let o=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>0===e.indexOf("!")&amp;&amp;(o=!0,e=e.substr(1));c</span>onst i=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{const n=<span class="cstat-no" title="statement not covered" >l[e];<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return n;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >u.reduce(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >t.replace(r[0],r[1].bind(e)),</span>e);<span class="cstat-no" title="statement not covered" ></span>return l[e]=r?new RegExp(s,"i"):new RegExp(s)}</span>)(e=e.replace(n,"!").replace(s,"#"),0,t);<span class="cstat-no" title="statement not covered" ></span>return new f(r,e,o,i)}</span>,d=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >throw new t(e)}</span>,g=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(!p(e))<span class="cstat-no" title="statement not covered" >return r(`path must be a string, but got \`${t}\``,TypeError);<span class="cstat-no" title="statement not covered" >i</span></span>f(!e)<span class="cstat-no" title="statement not covered" >return r("path must not be empty",TypeError);<span class="cstat-no" title="statement not covered" >i</span></span>f(g.isNotRelative(e)){<span class="cstat-no" title="statement not covered" >return r(`path should be a ${"`path.relative()`d"} string, but got "${t}"`,RangeError)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!0}</span>,y=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i.test(e);</span>g.isNotRelative=y,g.convert=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e;</span>class _{<span class="fstat-no" title="function not covered" >co</span>nstructor({ignorecase:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{var t,r,n;<span class="cstat-no" title="statement not covered" >this._rules=[],this._ignorecase=e,t=this,r=a,n=!0,Object.defineProperty(t,r,{value:n}),this._initCache()}<span class="fstat-no" title="function not covered" ></span>_i</span>nitCache(){<span class="cstat-no" title="statement not covered" >this._ignoreCache=Object.create(null),this._testCache=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>_a</span>ddPattern(e){<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;e[a])<span class="cstat-no" title="statement not covered" >return this._rules=this._rules.concat(e._rules),void(this._added=!0);<span class="cstat-no" title="statement not covered" >i</span></span>f((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e&amp;&amp;p(e)&amp;&amp;!r.test(e)&amp;&amp;0!==e.indexOf("#"))</span>(e)){const t=<span class="cstat-no" title="statement not covered" >h(e,this._ignorecase);<span class="cstat-no" title="statement not covered" ></span>this._added=!0,this._rules.push(t)}</span>}<span class="fstat-no" title="function not covered" ></span>ad</span>d(e){<span class="cstat-no" title="statement not covered" >return this._added=!1,t(p(e)?(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.split(o))</span>(e):e).forEach(this._addPattern,this),this._added&amp;&amp;this._initCache(),this}<span class="fstat-no" title="function not covered" ></span>ad</span>dPattern(e){<span class="cstat-no" title="statement not covered" >return this.add(e)}<span class="fstat-no" title="function not covered" ></span>_t</span>estOne(e,t){let r=<span class="cstat-no" title="statement not covered" >!1,</span>n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return this._rules.forEach(<span class="fstat-no" title="function not covered" >s=</span>&gt;{const{negative:o}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(n===o&amp;&amp;r!==n||o&amp;&amp;!r&amp;&amp;!n&amp;&amp;!t)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>.regex.test(e)&amp;&amp;(r=!o,n=o)}</span>),{ignored:r,unignored:n}}<span class="fstat-no" title="function not covered" ></span>_t</span>est(e,t,r,n){const s=<span class="cstat-no" title="statement not covered" >e&amp;&amp;g.convert(e);<span class="cstat-no" title="statement not covered" ></span>return g(s,e,d),this._t(s,t,r,n)}<span class="fstat-no" title="function not covered" ></span>_t</span>(e,t,r,n){<span class="cstat-no" title="statement not covered" >if(e in t)<span class="cstat-no" title="statement not covered" >return t[e];<span class="cstat-no" title="statement not covered" >i</span></span>f(n||(n=e.split("/")),n.pop(),!n.length)<span class="cstat-no" title="statement not covered" >return t[e]=this._testOne(e,r);c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this._t(n.join("/")+"/",t,r,n);<span class="cstat-no" title="statement not covered" ></span>return t[e]=s.ignored?s:this._testOne(e,r)}<span class="fstat-no" title="function not covered" ></span>ig</span>nores(e){<span class="cstat-no" title="statement not covered" >return this._test(e,this._ignoreCache,!1).ignored}<span class="fstat-no" title="function not covered" ></span>cr</span>eateFilter(){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!this.ignores(e)}<span class="fstat-no" title="function not covered" ></span></span>fi</span>lter(e){<span class="cstat-no" title="statement not covered" >return t(e).filter(this.createFilter())}<span class="fstat-no" title="function not covered" ></span>te</span>st(e){<span class="cstat-no" title="statement not covered" >return this._test(e,this._testCache,!0)}</span>}const E=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new _(e),</span>m=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1;<span class="missing-if-branch" title="else path not taken" >E</span></span>if(E.isPathValid=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >g(e&amp;&amp;g.convert(e),e,m),</span>E.default=E,e.exports=E,"undefined"!=typeof process&amp;&amp;(process.env&amp;&amp;process.env.IGNORE_TEST_WIN32||"win32"===process.platform)){const e=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >/^\\\\\?\\/.test(e)||/["&lt;&gt;|\u0000-\u001F]+/u.test(e)?e:e.replace(/\\/g,"/");</span>g.convert=e;const t=/^[a-z]:\//i;g.isNotRelative=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.test(e)||y(e)}</span>},4486:e=&gt;{
/*!
 * is-extglob &lt;https://github.com/jonschlinkert/is-extglob&gt;
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if("string"!=typeof e||""===e)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(var t;t=/(\\).|([@?!+*]\(.*\))/g.exec(e);){<span class="cstat-no" title="statement not covered" >if(t[2])<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >e</span></span>=e.slice(t.index+t[0].length)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>},8193:(e,t,r)=&gt;{
/*!
 * is-glob &lt;https://github.com/jonschlinkert/is-glob&gt;
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var n=r(4486),s={"{":"}","(":")","[":"]"},o=/\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/,i=/\\(.)|(^!|[*?{}()[\]]|\(\?)/;e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if("string"!=typeof e||""===e)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(n(e))<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar r,a=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>for(t&amp;&amp;!1===t.strict&amp;&amp;(a=i);r=a.exec(e);){<span class="cstat-no" title="statement not covered" >if(r[2])<span class="cstat-no" title="statement not covered" >return!0;v</span></span>ar c=<span class="cstat-no" title="statement not covered" >r.index+r[0].length,</span>u=<span class="cstat-no" title="statement not covered" >r[1],</span>l=<span class="cstat-no" title="statement not covered" >u?s[u]:null;<span class="cstat-no" title="statement not covered" ></span>if(u&amp;&amp;l){var p=<span class="cstat-no" title="statement not covered" >e.indexOf(l,c);<span class="cstat-no" title="statement not covered" ></span>-1!==p&amp;&amp;(c=p+1)}<span class="cstat-no" title="statement not covered" ></span>e</span>=e.slice(c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>},9235:e=&gt;{"use strict";
/*!
 * is-number &lt;https://github.com/jonschlinkert/is-number&gt;
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"number"==typeof e?e-e==0:"string"==typeof e&amp;&amp;""!==e.trim()&amp;&amp;(Number.isFinite?Number.isFinite(+e):isFinite(+e))}</span>},7308:(e,t,r)=&gt;{"use strict";const n=r(2413).PassThrough,s=Array.prototype.slice;function <span class="fstat-no" title="function not covered" >o(</span>e,t){<span class="cstat-no" title="statement not covered" >if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >for(let r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >e.length;</span>r&lt;n;r++)<span class="cstat-no" title="statement not covered" >e[r]=o(e[r],t);e</span></span>lse{<span class="cstat-no" title="statement not covered" >if(!e._readableState&amp;&amp;e.pipe&amp;&amp;(e=e.pipe(n(t))),!e._readableState||!e.pause||!e.pipe)<span class="cstat-no" title="statement not covered" >throw new Error("Only readable stream can be merged.");<span class="cstat-no" title="statement not covered" >e</span></span>.pause()}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(){const e=<span class="cstat-no" title="statement not covered" >[],</span>t=<span class="cstat-no" title="statement not covered" >s.call(arguments);</span>let r=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >t[t.length-1];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;!Array.isArray(i)&amp;&amp;null==i.pipe?t.pop():i={};c</span>onst a=<span class="cstat-no" title="statement not covered" >!1!==i.end,</span>c=<span class="cstat-no" title="statement not covered" >!0===i.pipeError;<span class="cstat-no" title="statement not covered" ></span>null==i.objectMode&amp;&amp;(i.objectMode=!0);<span class="cstat-no" title="statement not covered" >n</span>ull==i.highWaterMark&amp;&amp;(i.highWaterMark=65536);c</span>onst u=<span class="cstat-no" title="statement not covered" >n(i);</span>function <span class="fstat-no" title="function not covered" >l(</span>){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >arguments.length;</span>t&lt;r;t++)<span class="cstat-no" title="statement not covered" >e.push(o(arguments[t],i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn p(),this}</span>function <span class="fstat-no" title="function not covered" >p(</span>){<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span>=!0;l</span>et t=<span class="cstat-no" title="statement not covered" >e.shift();<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return void process.nextTick(f);<span class="cstat-no" title="statement not covered" >A</span></span>rray.isArray(t)||(t=[t]);l</span>et n=<span class="cstat-no" title="statement not covered" >t.length+1;</span>function <span class="fstat-no" title="function not covered" >s(</span>){<span class="cstat-no" title="statement not covered" >--n&gt;0||(r=!1,p())}</span>function <span class="fstat-no" title="function not covered" >o(</span>e){function <span class="fstat-no" title="function not covered" >t(</span>){<span class="cstat-no" title="statement not covered" >e.removeListener("merge2UnpipeEnd",t),e.removeListener("end",t),c&amp;&amp;e.removeListener("error",r),s()}</span>function <span class="fstat-no" title="function not covered" >r(</span>e){<span class="cstat-no" title="statement not covered" >u.emit("error",e)}<span class="cstat-no" title="statement not covered" ></span>if(e._readableState.endEmitted)<span class="cstat-no" title="statement not covered" >return s();<span class="cstat-no" title="statement not covered" >e</span></span>.on("merge2UnpipeEnd",t),e.on("end",t),c&amp;&amp;e.on("error",r),e.pipe(u,{end:!1}),e.resume()}<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;t.length;e++)<span class="cstat-no" title="statement not covered" >o(t[e]);<span class="cstat-no" title="statement not covered" >s</span></span>()}</span>function <span class="fstat-no" title="function not covered" >f(</span>){<span class="cstat-no" title="statement not covered" >r=!1,u.emit("queueDrain"),a&amp;&amp;u.end()}<span class="cstat-no" title="statement not covered" ></span>u.setMaxListeners(0),u.add=l,u.on("unpipe",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.emit("merge2UnpipeEnd")}</span>)),t.length&amp;&amp;l.apply(null,t);<span class="cstat-no" title="statement not covered" >r</span>eturn u}</span>},2401:(e,t,r)=&gt;{"use strict";const n=r(1669),s=r(2235),o=r(4722),i=r(3598),a=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"string"==typeof e&amp;&amp;(""===e||"./"===e),</span>c=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >t=[].concat(t),e=[].concat(e);l</span>et n=<span class="cstat-no" title="statement not covered" >new Set,</span>s=<span class="cstat-no" title="statement not covered" >new Set,</span>i=<span class="cstat-no" title="statement not covered" >new Set,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >i.add(e.output),r&amp;&amp;r.onResult&amp;&amp;r.onResult(e)}</span>;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.length;i++){let u=<span class="cstat-no" title="statement not covered" >o(String(t[i]),{...r,onResult:c},!0),</span>l=<span class="cstat-no" title="statement not covered" >u.state.negated||u.state.negatedExtglob;<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;a++;<span class="cstat-no" title="statement not covered" >f</span>or(let t of e){let e=<span class="cstat-no" title="statement not covered" >u(t,!0);<span class="cstat-no" title="statement not covered" ></span>(l?!e.isMatch:e.isMatch)&amp;&amp;(l?n.add(e.output):(n.delete(e.output),s.add(e.output)))}</span>}</span>l</span>et u=<span class="cstat-no" title="statement not covered" >(a===t.length?[...i]:[...s]).filter(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!n.has(e))</span>;<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;0===u.length){<span class="cstat-no" title="statement not covered" >if(!0===r.failglob)<span class="cstat-no" title="statement not covered" >throw new Error(`No matches found for "${t.join(", ")}"`);<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===r.nonull||!0===r.nullglob)<span class="cstat-no" title="statement not covered" >return r.unescape?t.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.replace(/\\/g,""))</span>:t}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn u}</span>;c.match=c,c.matcher=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >o(e,t),</span>c.any=c.isMatch=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >o(t,r)(e),</span>c.not=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >t=[].concat(t).map(String);l</span>et n=<span class="cstat-no" title="statement not covered" >new Set,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >c(e,t,{...r,onResult:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.onResult&amp;&amp;r.onResult(e),s.push(e.output)}</span>});<span class="cstat-no" title="statement not covered" ></span>for(let e of s)<span class="cstat-no" title="statement not covered" >o.includes(e)||n.add(e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[...n]}</span>,c.contains=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected a string: "${n.inspect(e)}"`);<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(t))<span class="cstat-no" title="statement not covered" >return t.some(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >c.contains(e,t,r))</span>;<span class="cstat-no" title="statement not covered" >i</span></span>f("string"==typeof t){<span class="cstat-no" title="statement not covered" >if(a(e)||a(t))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.includes(t)||e.startsWith("./")&amp;&amp;e.slice(2).includes(t))<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn c.isMatch(e,t,{...r,contains:!0})}</span>,c.matchKeys=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(!i.isObject(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected the first argument to be an object");l</span></span>et n=<span class="cstat-no" title="statement not covered" >c(Object.keys(e),t,r),</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let t of n)<span class="cstat-no" title="statement not covered" >s[t]=e[t];<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>,c.some=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >[].concat(e);<span class="cstat-no" title="statement not covered" ></span>for(let e of[].concat(t)){let t=<span class="cstat-no" title="statement not covered" >o(String(e),r);<span class="cstat-no" title="statement not covered" ></span>if(n.some(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t(e))</span>)<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>,c.every=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >[].concat(e);<span class="cstat-no" title="statement not covered" ></span>for(let e of[].concat(t)){let t=<span class="cstat-no" title="statement not covered" >o(String(e),r);<span class="cstat-no" title="statement not covered" ></span>if(!n.every(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t(e))</span>)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}</span>,c.all=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected a string: "${n.inspect(e)}"`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[].concat(t).every(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >o(t,r)(e))</span>}</span>,c.capture=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >i.isWindows(r),</span>s=<span class="cstat-no" title="statement not covered" >o.makeRe(String(e),{...r,capture:!0}).exec(n?i.toPosixSlashes(t):t);<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return s.slice(1).map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >void 0===e?"":e)</span>}</span></span>,c.makeRe=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >o.makeRe(...e),</span>c.scan=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >o.scan(...e),</span>c.parse=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n of[].concat(e||[]))<span class="cstat-no" title="statement not covered" >for(let e of s(String(n),t))<span class="cstat-no" title="statement not covered" >r.push(o.parse(e,t));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn r}</span>,c.braces=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t&amp;&amp;!0===t.nobrace||!/\{.*\}/.test(e)?[e]:s(e,t)}</span>,c.braceExpand=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string");<span class="cstat-no" title="statement not covered" >r</span></span>eturn c.braces(e,{...t,expand:!0})}</span>,e.exports=c},5763:(e,t,r)=&gt;{"use strict";const{promisify:n}=r(1669),s=r(5747);async function <span class="fstat-no" title="function not covered" >o(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if("string"!=typeof r)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string, got "+typeof r);<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return(await n(s[e])(r))[t]()}</span>catch(e){<span class="cstat-no" title="statement not covered" >if("ENOENT"===e.code)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>hrow e}</span>}</span>function <span class="fstat-no" title="function not covered" >i(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if("string"!=typeof r)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string, got "+typeof r);<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return s[e](r)[t]()}</span>catch(e){<span class="cstat-no" title="statement not covered" >if("ENOENT"===e.code)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>hrow e}</span>}</span>t.isFile=o.bind(null,"stat","isFile"),t.isDirectory=o.bind(null,"stat","isDirectory"),t.isSymlink=o.bind(null,"lstat","isSymbolicLink"),t.isFileSync=i.bind(null,"statSync","isFile"),t.isDirectorySync=i.bind(null,"statSync","isDirectory"),t.isSymlinkSync=i.bind(null,"lstatSync","isSymbolicLink")},4722:(e,t,r)=&gt;{"use strict";e.exports=r(8828)},1086:(e,t,r)=&gt;{"use strict";const n=r(5622),s={DOT_LITERAL:"\\.",PLUS_LITERAL:"\\+",QMARK_LITERAL:"\\?",SLASH_LITERAL:"\\/",ONE_CHAR:"(?=.)",QMARK:"[^/]",END_ANCHOR:"(?:\\/|$)",DOTS_SLASH:"\\.{1,2}(?:\\/|$)",NO_DOT:"(?!\\.)",NO_DOTS:"(?!(?:^|\\/)\\.{1,2}(?:\\/|$))",NO_DOT_SLASH:"(?!\\.{0,1}(?:\\/|$))",NO_DOTS_SLASH:"(?!\\.{1,2}(?:\\/|$))",QMARK_NO_DOT:"[^.\\/]",STAR:"[^/]*?",START_ANCHOR:"(?:^|\\/)"},o={...s,SLASH_LITERAL:"[\\\\/]",QMARK:"[^\\\\/]",STAR:"[^\\\\/]*?",DOTS_SLASH:"\\.{1,2}(?:[\\\\/]|$)",NO_DOT:"(?!\\.)",NO_DOTS:"(?!(?:^|[\\\\/])\\.{1,2}(?:[\\\\/]|$))",NO_DOT_SLASH:"(?!\\.{0,1}(?:[\\\\/]|$))",NO_DOTS_SLASH:"(?!\\.{1,2}(?:[\\\\/]|$))",QMARK_NO_DOT:"[^.\\\\/]",START_ANCHOR:"(?:^|[\\\\/])",END_ANCHOR:"(?:[\\\\/]|$)"};e.exports={MAX_LENGTH:65536,POSIX_REGEX_SOURCE:{alnum:"a-zA-Z0-9",alpha:"a-zA-Z",ascii:"\\x00-\\x7F",blank:" \\t",cntrl:"\\x00-\\x1F\\x7F",digit:"0-9",graph:"\\x21-\\x7E",lower:"a-z",print:"\\x20-\\x7E ",punct:"\\-!\"#$%&amp;'()\\*+,./:;&lt;=&gt;?@[\\]^_`{|}~",space:" \\t\\r\\n\\v\\f",upper:"A-Z",word:"A-Za-z0-9_",xdigit:"A-Fa-f0-9"},REGEX_BACKSLASH:/\\(?![*+?^${}(|)[\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\].,$*+?^{}()|\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\?)((\W)(\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\[.*?[^\\]\]|\\(?=.))/g,REPLACEMENTS:{"***":"*","**/**":"**","**/**/**":"**"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,SEP:n.sep,extglobChars:<span class="fstat-no" title="function not covered" >e=</span>&gt;(<span class="cstat-no" title="statement not covered" >{"!":{type:"negate",open:"(?:(?!(?:",close:`))${e.STAR})`},"?":{type:"qmark",open:"(?:",close:")?"},"+":{type:"plus",open:"(?:",close:")+"},"*":{type:"star",open:"(?:",close:")*"},"@":{type:"at",open:"(?:",close:")"}})</span>,globChars:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!0===e?o:s}</span>},7974:(e,t,r)=&gt;{"use strict";const n=r(1086),s=r(3598),{MAX_LENGTH:o,POSIX_REGEX_SOURCE:i,REGEX_NON_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_BACKREF:c,REPLACEMENTS:u}=n,l=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if("function"==typeof t.expandRange)<span class="cstat-no" title="statement not covered" >return t.expandRange(...e,t);<span class="cstat-no" title="statement not covered" >e</span></span>.sort();c</span>onst r=<span class="cstat-no" title="statement not covered" >`[${e.join("-")}]`;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >new RegExp(r)}</span>catch(t){<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >s.escapeRegex(e))</span>.join("..")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,p=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >`Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`,</span>f=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string");<span class="cstat-no" title="statement not covered" >e</span></span>=u[e]||e;c</span>onst r=<span class="cstat-no" title="statement not covered" >{...t},</span>f=<span class="cstat-no" title="statement not covered" >"number"==typeof r.maxLength?Math.min(o,r.maxLength):o;</span>let h=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(h&gt;f)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(`Input length: ${h}, exceeds maximum allowed length: ${f}`);c</span></span>onst d=<span class="cstat-no" title="statement not covered" >{type:"bos",value:"",output:r.prepend||""},</span>g=<span class="cstat-no" title="statement not covered" >[d],</span>y=<span class="cstat-no" title="statement not covered" >r.capture?"":"?:",</span>_=<span class="cstat-no" title="statement not covered" >s.isWindows(t),</span>E=<span class="cstat-no" title="statement not covered" >n.globChars(_),</span>m=<span class="cstat-no" title="statement not covered" >n.extglobChars(E),</span>{DOT_LITERAL:b,PLUS_LITERAL:v,SLASH_LITERAL:S,ONE_CHAR:R,DOTS_SLASH:A,NO_DOT:w,NO_DOT_SLASH:O,NO_DOTS_SLASH:T,QMARK:C,QMARK_NO_DOT:P,STAR:k,START_ANCHOR:x}=<span class="cstat-no" title="statement not covered" >E,</span>N=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >`(${y}(?:(?!${x}${e.dot?A:b}).)*?)`,</span></span>I=<span class="cstat-no" title="statement not covered" >r.dot?"":w,</span>L=<span class="cstat-no" title="statement not covered" >r.dot?C:P;</span>let D=<span class="cstat-no" title="statement not covered" >!0===r.bash?N(r):k;<span class="cstat-no" title="statement not covered" ></span>r.capture&amp;&amp;(D=`(${D})`),"boolean"==typeof r.noext&amp;&amp;(r.noextglob=r.noext);c</span>onst M=<span class="cstat-no" title="statement not covered" >{input:e,index:-1,start:0,dot:!0===r.dot,consumed:"",output:"",prefix:"",backtrack:!1,negated:!1,brackets:0,braces:0,parens:0,quotes:0,globstar:!1,tokens:g};<span class="cstat-no" title="statement not covered" ></span>e=s.removePrefix(e,M),h=e.length;c</span>onst H=<span class="cstat-no" title="statement not covered" >[],</span>$=<span class="cstat-no" title="statement not covered" >[],</span>F=<span class="cstat-no" title="statement not covered" >[];</span>let j,B=<span class="cstat-no" title="statement not covered" >d;</span>const U=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >M.index===h-1,</span></span>G=<span class="cstat-no" title="statement not covered" >M.peek=<span class="fstat-no" title="function not covered" >(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >e[M.index+t],</span></span>W=<span class="cstat-no" title="statement not covered" >M.advance=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e[++M.index],</span></span>V=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.slice(M.index+1),</span></span>K=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>=&gt;{<span class="cstat-no" title="statement not covered" >M.consumed+=e,M.index+=t}</span>,</span>q=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >M.output+=null!=e.output?e.output:e.value,K(e.value)}</span>,</span>Y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{let e=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>for(;"!"===G()&amp;&amp;("("!==G(2)||"?"===G(3));)<span class="cstat-no" title="statement not covered" >W(),M.start++,e++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e%2!=0&amp;&amp;(M.negated=!0,M.start++,!0)}</span>,</span>X=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >M[e]++,F.push(e)}</span>,</span>Q=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >M[e]--,F.pop()}</span>,</span>z=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if("globstar"===B.type){const t=<span class="cstat-no" title="statement not covered" >M.braces&gt;0&amp;&amp;("comma"===e.type||"brace"===e.type),</span>r=<span class="cstat-no" title="statement not covered" >!0===e.extglob||H.length&amp;&amp;("pipe"===e.type||"paren"===e.type);<span class="cstat-no" title="statement not covered" ></span>"slash"===e.type||"paren"===e.type||t||r||(M.output=M.output.slice(0,-B.output.length),B.type="star",B.value="*",B.output=D,M.output+=B.output)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(H.length&amp;&amp;"paren"!==e.type&amp;&amp;!m[e.value]&amp;&amp;(H[H.length-1].inner+=e.value),(e.value||e.output)&amp;&amp;q(e),B&amp;&amp;"text"===B.type&amp;&amp;"text"===e.type)<span class="cstat-no" title="statement not covered" >return B.value+=e.value,void(B.output=(B.output||"")+e.value);<span class="cstat-no" title="statement not covered" >e</span></span>.prev=B,g.push(e),B=e}</span>,</span>Z=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const n=<span class="cstat-no" title="statement not covered" >{...m[t],conditions:1,inner:""};<span class="cstat-no" title="statement not covered" ></span>n.prev=B,n.parens=M.parens,n.output=M.output;c</span>onst s=<span class="cstat-no" title="statement not covered" >(r.capture?"(":"")+n.open;<span class="cstat-no" title="statement not covered" ></span>X("parens"),z({type:e,value:t,output:M.output?"":R}),z({type:"paren",extglob:!0,value:W(),output:s}),H.push(n)}</span>,</span>J=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >e.close+(r.capture?")":"");<span class="cstat-no" title="statement not covered" ></span>if("negate"===e.type){let n=<span class="cstat-no" title="statement not covered" >D;<span class="cstat-no" title="statement not covered" ></span>e.inner&amp;&amp;e.inner.length&gt;1&amp;&amp;e.inner.includes("/")&amp;&amp;(n=N(r)),(n!==D||U()||/^\)+$/.test(V()))&amp;&amp;(t=e.close=")$))"+n),"bos"===e.prev.type&amp;&amp;U()&amp;&amp;(M.negatedExtglob=!0)}<span class="cstat-no" title="statement not covered" ></span>z</span>({type:"paren",extglob:!0,value:j,output:t}),Q("parens")}</span>;<span class="cstat-no" title="statement not covered" ></span>if(!1!==r.fastpaths&amp;&amp;!/(^[*!]|[/()[\]{}"])/.test(e)){let n=<span class="cstat-no" title="statement not covered" >!1,</span>o=<span class="cstat-no" title="statement not covered" >e.replace(c,<span class="fstat-no" title="function not covered" >(e</span>,t,r,s,o,i)=&gt;<span class="cstat-no" title="statement not covered" >"\\"===s?(n=!0,e):"?"===s?t?t+s+(o?C.repeat(o.length):""):0===i?L+(o?C.repeat(o.length):""):C.repeat(r.length):"."===s?b.repeat(r.length):"*"===s?t?t+s+(o?D:""):D:t?e:"\\"+e)</span>;<span class="cstat-no" title="statement not covered" ></span>return!0===n&amp;&amp;(o=!0===r.unescape?o.replace(/\\/g,""):o.replace(/\\+/g,<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.length%2==0?"\\\\":e?"\\":"")</span>),o===e&amp;&amp;!0===r.contains?(M.output=e,M):(M.output=s.wrapOutput(o,M,t),M)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;!U();){<span class="cstat-no" title="statement not covered" >if(j=W(),"\0"===j)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f("\\"===j){const e=<span class="cstat-no" title="statement not covered" >G();<span class="cstat-no" title="statement not covered" ></span>if("/"===e&amp;&amp;!0!==r.bash)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f("."===e||";"===e)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e){<span class="cstat-no" title="statement not covered" >j+="\\",z({type:"text",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst t=<span class="cstat-no" title="statement not covered" >/^\\+/.exec(V());</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(t&amp;&amp;t[0].length&gt;2&amp;&amp;(n=t[0].length,M.index+=n,n%2!=0&amp;&amp;(j+="\\")),!0===r.unescape?j=W()||"":j+=W()||"",0===M.brackets){<span class="cstat-no" title="statement not covered" >z({type:"text",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(M.brackets&gt;0&amp;&amp;("]"!==j||"["===B.value||"[^"===B.value)){<span class="cstat-no" title="statement not covered" >if(!1!==r.posix&amp;&amp;":"===j){const e=<span class="cstat-no" title="statement not covered" >B.value.slice(1);<span class="cstat-no" title="statement not covered" ></span>if(e.includes("[")&amp;&amp;(B.posix=!0,e.includes(":"))){const e=<span class="cstat-no" title="statement not covered" >B.value.lastIndexOf("["),</span>t=<span class="cstat-no" title="statement not covered" >B.value.slice(0,e),</span>r=<span class="cstat-no" title="statement not covered" >B.value.slice(e+2),</span>n=<span class="cstat-no" title="statement not covered" >i[r];<span class="cstat-no" title="statement not covered" ></span>if(n){<span class="cstat-no" title="statement not covered" >B.value=t+n,M.backtrack=!0,W(),d.output||1!==g.indexOf(B)||(d.output=R);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>(</span>"["===j&amp;&amp;":"!==G()||"-"===j&amp;&amp;"]"===G())&amp;&amp;(j="\\"+j),"]"!==j||"["!==B.value&amp;&amp;"[^"!==B.value||(j="\\"+j),!0===r.posix&amp;&amp;"!"===j&amp;&amp;"["===B.value&amp;&amp;(j="^"),B.value+=j,q({value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(1===M.quotes&amp;&amp;'"'!==j){<span class="cstat-no" title="statement not covered" >j=s.escapeRegex(j),B.value+=j,q({value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f('"'===j){<span class="cstat-no" title="statement not covered" >M.quotes=1===M.quotes?0:1,!0===r.keepQuotes&amp;&amp;z({type:"text",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("("===j){<span class="cstat-no" title="statement not covered" >X("parens"),z({type:"paren",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(")"===j){<span class="cstat-no" title="statement not covered" >if(0===M.parens&amp;&amp;!0===r.strictBrackets)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(p("opening","("));c</span></span>onst e=<span class="cstat-no" title="statement not covered" >H[H.length-1];<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;M.parens===e.parens+1){<span class="cstat-no" title="statement not covered" >J(H.pop());<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>z</span>({type:"paren",value:j,output:M.parens?")":"\\)"}),Q("parens");<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("["===j){<span class="cstat-no" title="statement not covered" >if(!0!==r.nobracket&amp;&amp;V().includes("]"))<span class="cstat-no" title="statement not covered" >X("brackets");e</span>lse{<span class="cstat-no" title="statement not covered" >if(!0!==r.nobracket&amp;&amp;!0===r.strictBrackets)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(p("closing","]"));<span class="cstat-no" title="statement not covered" >j</span></span>="\\"+j}<span class="cstat-no" title="statement not covered" ></span>z</span>({type:"bracket",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("]"===j){<span class="cstat-no" title="statement not covered" >if(!0===r.nobracket||B&amp;&amp;"bracket"===B.type&amp;&amp;1===B.value.length){<span class="cstat-no" title="statement not covered" >z({type:"text",value:j,output:"\\"+j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===M.brackets){<span class="cstat-no" title="statement not covered" >if(!0===r.strictBrackets)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(p("opening","["));<span class="cstat-no" title="statement not covered" >z</span></span>({type:"text",value:j,output:"\\"+j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>Q</span>("brackets");c</span>onst e=<span class="cstat-no" title="statement not covered" >B.value.slice(1);<span class="cstat-no" title="statement not covered" ></span>if(!0===B.posix||"^"!==e[0]||e.includes("/")||(j="/"+j),B.value+=j,q({value:j}),!1===r.literalBrackets||s.hasRegexChars(e))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >s.escapeRegex(B.value);<span class="cstat-no" title="statement not covered" ></span>if(M.output=M.output.slice(0,-B.value.length),!0===r.literalBrackets){<span class="cstat-no" title="statement not covered" >M.output+=t,B.value=t;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>B</span>.value=`(${y}${t}|${B.value})`,M.output+=B.value;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("{"===j&amp;&amp;!0!==r.nobrace){<span class="cstat-no" title="statement not covered" >X("braces");c</span>onst e=<span class="cstat-no" title="statement not covered" >{type:"brace",value:j,output:"(",outputIndex:M.output.length,tokensIndex:M.tokens.length};<span class="cstat-no" title="statement not covered" ></span>$.push(e),z(e);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("}"===j){const e=<span class="cstat-no" title="statement not covered" >$[$.length-1];<span class="cstat-no" title="statement not covered" ></span>if(!0===r.nobrace||!e){<span class="cstat-no" title="statement not covered" >z({type:"text",value:j,output:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >")";<span class="cstat-no" title="statement not covered" ></span>if(!0===e.dots){const e=<span class="cstat-no" title="statement not covered" >g.slice(),</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >e.length-1;</span>t&gt;=0&amp;&amp;(g.pop(),"brace"!==e[t].type);t--)<span class="cstat-no" title="statement not covered" >"dots"!==e[t].type&amp;&amp;n.unshift(e[t].value);<span class="cstat-no" title="statement not covered" >t</span></span>=l(n,r),M.backtrack=!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0!==e.comma&amp;&amp;!0!==e.dots){const r=<span class="cstat-no" title="statement not covered" >M.output.slice(0,e.outputIndex),</span>n=<span class="cstat-no" title="statement not covered" >M.tokens.slice(e.tokensIndex);<span class="cstat-no" title="statement not covered" ></span>e.value=e.output="\\{",j=t="\\}",M.output=r;<span class="cstat-no" title="statement not covered" >f</span>or(const e of n)<span class="cstat-no" title="statement not covered" >M.output+=e.output||e.value}<span class="cstat-no" title="statement not covered" ></span></span>z</span>({type:"brace",value:j,output:t}),Q("braces"),$.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("|"===j){<span class="cstat-no" title="statement not covered" >H.length&gt;0&amp;&amp;H[H.length-1].conditions++,z({type:"text",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(","===j){let e=<span class="cstat-no" title="statement not covered" >j;</span>const t=<span class="cstat-no" title="statement not covered" >$[$.length-1];<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;"braces"===F[F.length-1]&amp;&amp;(t.comma=!0,e="|"),z({type:"comma",value:j,output:e});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("/"===j){<span class="cstat-no" title="statement not covered" >if("dot"===B.type&amp;&amp;M.index===M.start+1){<span class="cstat-no" title="statement not covered" >M.start=M.index+1,M.consumed="",M.output="",g.pop(),B=d;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>z</span>({type:"slash",value:j,output:S});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("."===j){<span class="cstat-no" title="statement not covered" >if(M.braces&gt;0&amp;&amp;"dot"===B.type){<span class="cstat-no" title="statement not covered" >"."===B.value&amp;&amp;(B.output=b);c</span>onst e=<span class="cstat-no" title="statement not covered" >$[$.length-1];<span class="cstat-no" title="statement not covered" ></span>B.type="dots",B.output+=j,B.value+=j,e.dots=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(M.braces+M.parens===0&amp;&amp;"bos"!==B.type&amp;&amp;"slash"!==B.type){<span class="cstat-no" title="statement not covered" >z({type:"text",value:j,output:b});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>z</span>({type:"dot",value:j,output:b});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("?"===j){<span class="cstat-no" title="statement not covered" >if(!(B&amp;&amp;"("===B.value)&amp;&amp;!0!==r.noextglob&amp;&amp;"("===G()&amp;&amp;"?"!==G(2)){<span class="cstat-no" title="statement not covered" >Z("qmark",j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(B&amp;&amp;"paren"===B.type){const e=<span class="cstat-no" title="statement not covered" >G();</span>let t=<span class="cstat-no" title="statement not covered" >j;<span class="cstat-no" title="statement not covered" ></span>if("&lt;"===e&amp;&amp;!s.supportsLookbehinds())<span class="cstat-no" title="statement not covered" >throw new Error("Node.js v10 or higher is required for regex lookbehinds");<span class="cstat-no" title="statement not covered" >(</span></span>"("===B.value&amp;&amp;!/[!=&lt;:]/.test(e)||"&lt;"===e&amp;&amp;!/&lt;([!=]|\w+&gt;)/.test(V()))&amp;&amp;(t="\\"+j),z({type:"text",value:j,output:t});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0!==r.dot&amp;&amp;("slash"===B.type||"bos"===B.type)){<span class="cstat-no" title="statement not covered" >z({type:"qmark",value:j,output:P});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>z</span>({type:"qmark",value:j,output:C});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("!"===j){<span class="cstat-no" title="statement not covered" >if(!0!==r.noextglob&amp;&amp;"("===G()&amp;&amp;("?"!==G(2)||!/[!=&lt;:]/.test(G(3)))){<span class="cstat-no" title="statement not covered" >Z("negate",j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0!==r.nonegate&amp;&amp;0===M.index){<span class="cstat-no" title="statement not covered" >Y();<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f("+"===j){<span class="cstat-no" title="statement not covered" >if(!0!==r.noextglob&amp;&amp;"("===G()&amp;&amp;"?"!==G(2)){<span class="cstat-no" title="statement not covered" >Z("plus",j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(B&amp;&amp;"("===B.value||!1===r.regex){<span class="cstat-no" title="statement not covered" >z({type:"plus",value:j,output:v});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(B&amp;&amp;("bracket"===B.type||"paren"===B.type||"brace"===B.type)||M.parens&gt;0){<span class="cstat-no" title="statement not covered" >z({type:"plus",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>z</span>({type:"plus",value:v});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("@"===j){<span class="cstat-no" title="statement not covered" >if(!0!==r.noextglob&amp;&amp;"("===G()&amp;&amp;"?"!==G(2)){<span class="cstat-no" title="statement not covered" >z({type:"at",extglob:!0,value:j,output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>z</span>({type:"text",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("*"!==j){<span class="cstat-no" title="statement not covered" >"$"!==j&amp;&amp;"^"!==j||(j="\\"+j);c</span>onst e=<span class="cstat-no" title="statement not covered" >a.exec(V());<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(j+=e[0],M.index+=e[0].length),z({type:"text",value:j});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(B&amp;&amp;("globstar"===B.type||!0===B.star)){<span class="cstat-no" title="statement not covered" >B.type="star",B.star=!0,B.value+=j,B.output=D,M.backtrack=!0,M.globstar=!0,K(j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >V();<span class="cstat-no" title="statement not covered" ></span>if(!0!==r.noextglob&amp;&amp;/^\([^?]/.test(t)){<span class="cstat-no" title="statement not covered" >Z("star",j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("star"===B.type){<span class="cstat-no" title="statement not covered" >if(!0===r.noglobstar){<span class="cstat-no" title="statement not covered" >K(j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >B.prev,</span>s=<span class="cstat-no" title="statement not covered" >n.prev,</span>o=<span class="cstat-no" title="statement not covered" >"slash"===n.type||"bos"===n.type,</span>i=<span class="cstat-no" title="statement not covered" >s&amp;&amp;("star"===s.type||"globstar"===s.type);<span class="cstat-no" title="statement not covered" ></span>if(!0===r.bash&amp;&amp;(!o||t[0]&amp;&amp;"/"!==t[0])){<span class="cstat-no" title="statement not covered" >z({type:"star",value:j,output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst a=<span class="cstat-no" title="statement not covered" >M.braces&gt;0&amp;&amp;("comma"===n.type||"brace"===n.type),</span>c=<span class="cstat-no" title="statement not covered" >H.length&amp;&amp;("pipe"===n.type||"paren"===n.type);<span class="cstat-no" title="statement not covered" ></span>if(!o&amp;&amp;"paren"!==n.type&amp;&amp;!a&amp;&amp;!c){<span class="cstat-no" title="statement not covered" >z({type:"star",value:j,output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;"/**"===t.slice(0,3);){const r=<span class="cstat-no" title="statement not covered" >e[M.index+4];<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;"/"!==r)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>=t.slice(3),K("/**",3)}<span class="cstat-no" title="statement not covered" ></span>i</span>f("bos"===n.type&amp;&amp;U()){<span class="cstat-no" title="statement not covered" >B.type="globstar",B.value+=j,B.output=N(r),M.output=B.output,M.globstar=!0,K(j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("slash"===n.type&amp;&amp;"bos"!==n.prev.type&amp;&amp;!i&amp;&amp;U()){<span class="cstat-no" title="statement not covered" >M.output=M.output.slice(0,-(n.output+B.output).length),n.output="(?:"+n.output,B.type="globstar",B.output=N(r)+(r.strictSlashes?")":"|$)"),B.value+=j,M.globstar=!0,M.output+=n.output+B.output,K(j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("slash"===n.type&amp;&amp;"bos"!==n.prev.type&amp;&amp;"/"===t[0]){const e=<span class="cstat-no" title="statement not covered" >void 0!==t[1]?"|$":"";<span class="cstat-no" title="statement not covered" ></span>M.output=M.output.slice(0,-(n.output+B.output).length),n.output="(?:"+n.output,B.type="globstar",B.output=`${N(r)}${S}|${S}${e})`,B.value+=j,M.output+=n.output+B.output,M.globstar=!0,K(j+W()),z({type:"slash",value:"/",output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f("bos"===n.type&amp;&amp;"/"===t[0]){<span class="cstat-no" title="statement not covered" >B.type="globstar",B.value+=j,B.output=`(?:^|${S}|${N(r)}${S})`,M.output=B.output,M.globstar=!0,K(j+W()),z({type:"slash",value:"/",output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>M</span>.output=M.output.slice(0,-B.output.length),B.type="globstar",B.output=N(r),B.value+=j,M.output+=B.output,M.globstar=!0,K(j);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >{type:"star",value:j,output:D};<span class="cstat-no" title="statement not covered" ></span>!0!==r.bash?!B||"bracket"!==B.type&amp;&amp;"paren"!==B.type||!0!==r.regex?(M.index!==M.start&amp;&amp;"slash"!==B.type&amp;&amp;"dot"!==B.type||("dot"===B.type?(M.output+=O,B.output+=O):!0===r.dot?(M.output+=T,B.output+=T):(M.output+=I,B.output+=I),"*"!==G()&amp;&amp;(M.output+=R,B.output+=R)),z(n)):(n.output=j,z(n)):(n.output=".*?","bos"!==B.type&amp;&amp;"slash"!==B.type||(n.output=I+n.output),z(n))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;M.brackets&gt;0;){<span class="cstat-no" title="statement not covered" >if(!0===r.strictBrackets)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(p("closing","]"));<span class="cstat-no" title="statement not covered" >M</span></span>.output=s.escapeLast(M.output,"["),Q("brackets")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;M.parens&gt;0;){<span class="cstat-no" title="statement not covered" >if(!0===r.strictBrackets)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(p("closing",")"));<span class="cstat-no" title="statement not covered" >M</span></span>.output=s.escapeLast(M.output,"("),Q("parens")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;M.braces&gt;0;){<span class="cstat-no" title="statement not covered" >if(!0===r.strictBrackets)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(p("closing","}"));<span class="cstat-no" title="statement not covered" >M</span></span>.output=s.escapeLast(M.output,"{"),Q("braces")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===r.strictSlashes||"star"!==B.type&amp;&amp;"bracket"!==B.type||z({type:"maybe_slash",value:"",output:S+"?"}),!0===M.backtrack){<span class="cstat-no" title="statement not covered" >M.output="";<span class="cstat-no" title="statement not covered" >f</span>or(const e of M.tokens)<span class="cstat-no" title="statement not covered" >M.output+=null!=e.output?e.output:e.value,e.suffix&amp;&amp;(M.output+=e.suffix)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn M}</span>;f.fastpaths=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >{...t},</span>i=<span class="cstat-no" title="statement not covered" >"number"==typeof r.maxLength?Math.min(o,r.maxLength):o,</span>a=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(a&gt;i)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(`Input length: ${a}, exceeds maximum allowed length: ${i}`);<span class="cstat-no" title="statement not covered" >e</span></span>=u[e]||e;c</span>onst c=<span class="cstat-no" title="statement not covered" >s.isWindows(t),</span>{DOT_LITERAL:l,SLASH_LITERAL:p,ONE_CHAR:f,DOTS_SLASH:h,NO_DOT:d,NO_DOTS:g,NO_DOTS_SLASH:y,STAR:_,START_ANCHOR:E}=<span class="cstat-no" title="statement not covered" >n.globChars(c),</span>m=<span class="cstat-no" title="statement not covered" >r.dot?g:d,</span>b=<span class="cstat-no" title="statement not covered" >r.dot?y:d,</span>v=<span class="cstat-no" title="statement not covered" >r.capture?"":"?:";</span>let S=<span class="cstat-no" title="statement not covered" >!0===r.bash?".*?":_;<span class="cstat-no" title="statement not covered" ></span>r.capture&amp;&amp;(S=`(${S})`);c</span>onst R=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!0===e.noglobstar?S:`(${v}(?:(?!${E}${e.dot?h:l}).)*?)`,</span></span>A=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >switch(e){case"*":<span class="cstat-no" title="statement not covered" >return`${m}${f}${S}`;c</span>ase".*":<span class="cstat-no" title="statement not covered" >return`${l}${f}${S}`;c</span>ase"*.*":<span class="cstat-no" title="statement not covered" >return`${m}${S}${l}${f}${S}`;c</span>ase"*/*":<span class="cstat-no" title="statement not covered" >return`${m}${S}${p}${f}${b}${S}`;c</span>ase"**":<span class="cstat-no" title="statement not covered" >return m+R(r);c</span>ase"**/*":<span class="cstat-no" title="statement not covered" >return`(?:${m}${R(r)}${p})?${b}${f}${S}`;c</span>ase"**/*.*":<span class="cstat-no" title="statement not covered" >return`(?:${m}${R(r)}${p})?${b}${S}${l}${f}${S}`;c</span>ase"**/.*":<span class="cstat-no" title="statement not covered" >return`(?:${m}${R(r)}${p})?${l}${f}${S}`;d</span>efault:{const t=<span class="cstat-no" title="statement not covered" >/^(.*?)\.(\w+)$/.exec(e);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >A(t[1]);<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+l+t[2]}</span>}}</span>,</span>w=<span class="cstat-no" title="statement not covered" >s.removePrefix(e,{negated:!1,prefix:""});</span>let O=<span class="cstat-no" title="statement not covered" >A(w);<span class="cstat-no" title="statement not covered" ></span>return O&amp;&amp;!0!==r.strictSlashes&amp;&amp;(O+=p+"?"),O}</span>,e.exports=f},8828:(e,t,r)=&gt;{"use strict";const n=r(5622),s=r(5321),o=r(7974),i=r(3598),a=r(1086),c=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(Array.isArray(e)){const n=<span class="cstat-no" title="statement not covered" >e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c(e,t,r))</span>;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const t of n){const r=<span class="cstat-no" title="statement not covered" >t(e);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >(s=e)&amp;&amp;"object"==typeof s&amp;&amp;!Array.isArray(s)&amp;&amp;e.tokens&amp;&amp;e.input;</span>var s;<span class="cstat-no" title="statement not covered" >if(""===e||"string"!=typeof e&amp;&amp;!n)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected pattern to be a non-empty string");c</span></span>onst o=<span class="cstat-no" title="statement not covered" >t||{},</span>a=<span class="cstat-no" title="statement not covered" >i.isWindows(t),</span>u=<span class="cstat-no" title="statement not covered" >n?c.compileRe(e,t):c.makeRe(e,t,!1,!0),</span>l=<span class="cstat-no" title="statement not covered" >u.state;<span class="cstat-no" title="statement not covered" ></span>delete u.state;l</span>et p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span></span>if(o.ignore){const e=<span class="cstat-no" title="statement not covered" >{...t,ignore:null,onMatch:null,onResult:null};<span class="cstat-no" title="statement not covered" ></span>p=c(o.ignore,e,r)}</span>c</span>onst f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(r</span>,n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{const{isMatch:s,match:i,output:f}=<span class="cstat-no" title="statement not covered" >c.test(r,u,t,{glob:e,posix:a}),</span>h=<span class="cstat-no" title="statement not covered" >{glob:e,state:l,regex:u,posix:a,input:r,output:f,match:i,isMatch:s};<span class="cstat-no" title="statement not covered" ></span>return"function"==typeof o.onResult&amp;&amp;o.onResult(h),!1===s?(h.isMatch=!1,!!n&amp;&amp;h):p(r)?("function"==typeof o.onIgnore&amp;&amp;o.onIgnore(h),h.isMatch=!1,!!n&amp;&amp;h):("function"==typeof o.onMatch&amp;&amp;o.onMatch(h),!n||h)}</span>;<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(f.state=l),f}</span>;c.test=<span class="fstat-no" title="function not covered" >(e</span>,t,r,{glob:n,posix:s}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if("string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected input to be a string");<span class="cstat-no" title="statement not covered" >i</span></span>f(""===e)<span class="cstat-no" title="statement not covered" >return{isMatch:!1,output:""};c</span></span>onst o=<span class="cstat-no" title="statement not covered" >r||{},</span>a=<span class="cstat-no" title="statement not covered" >o.format||(s?i.toPosixSlashes:null);</span>let u=<span class="cstat-no" title="statement not covered" >e===n,</span>l=<span class="cstat-no" title="statement not covered" >u&amp;&amp;a?a(e):e;<span class="cstat-no" title="statement not covered" ></span>return!1===u&amp;&amp;(l=a?a(e):e,u=l===n),!1!==u&amp;&amp;!0!==o.capture||(u=!0===o.matchBase||!0===o.basename?c.matchBase(e,t,r,s):t.exec(l)),{isMatch:Boolean(u),match:u,output:l}}</span>,c.matchBase=<span class="fstat-no" title="function not covered" >(e</span>,t,r,s=<span class="branch-0 cbranch-no" title="branch not covered" >i.isWindows(r))</span>=&gt;<span class="cstat-no" title="statement not covered" >(t instanceof RegExp?t:c.makeRe(t,r)).test(n.basename(e)),</span>c.isMatch=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >c(t,r)(e),</span>c.parse=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >Array.isArray(e)?e.map(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >c.parse(e,t))</span>:o(e,{...t,fastpaths:!1}),</span>c.scan=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >s(e,t),</span>c.compileRe=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!0===r)<span class="cstat-no" title="statement not covered" >return e.output;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t||{},</span>o=<span class="cstat-no" title="statement not covered" >s.contains?"":"^",</span>i=<span class="cstat-no" title="statement not covered" >s.contains?"":"$";</span>let a=<span class="cstat-no" title="statement not covered" >`${o}(?:${e.output})${i}`;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;!0===e.negated&amp;&amp;(a=`^(?!${a}).*$`);c</span>onst u=<span class="cstat-no" title="statement not covered" >c.toRegex(a,t);<span class="cstat-no" title="statement not covered" ></span>return!0===n&amp;&amp;(u.state=e),u}</span>,c.makeRe=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!e||"string"!=typeof e)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a non-empty string");c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t||{};</span>let i,a=<span class="cstat-no" title="statement not covered" >{negated:!1,fastpaths:!0},</span>u=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return e.startsWith("./")&amp;&amp;(e=e.slice(2),u=a.prefix="./"),!1===s.fastpaths||"."!==e[0]&amp;&amp;"*"!==e[0]||(i=o.fastpaths(e,t)),void 0===i?(a=o(e,t),a.prefix=u+(a.prefix||"")):a.output=i,c.compileRe(a,t,r,n)}</span>,c.toRegex=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >try{const r=<span class="cstat-no" title="statement not covered" >t||{};<span class="cstat-no" title="statement not covered" ></span>return new RegExp(e,r.flags||(r.nocase?"i":""))}</span>catch(e){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;!0===t.debug)<span class="cstat-no" title="statement not covered" >throw e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn/$^/}</span>}</span>,c.constants=a,e.exports=c},5321:(e,t,r)=&gt;{"use strict";const n=r(3598),{CHAR_ASTERISK:s,CHAR_AT:o,CHAR_BACKWARD_SLASH:i,CHAR_COMMA:a,CHAR_DOT:c,CHAR_EXCLAMATION_MARK:u,CHAR_FORWARD_SLASH:l,CHAR_LEFT_CURLY_BRACE:p,CHAR_LEFT_PARENTHESES:f,CHAR_LEFT_SQUARE_BRACKET:h,CHAR_PLUS:d,CHAR_QUESTION_MARK:g,CHAR_RIGHT_CURLY_BRACE:y,CHAR_RIGHT_PARENTHESES:_,CHAR_RIGHT_SQUARE_BRACKET:E}=r(1086),m=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e===l||e===i,</span>b=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >!0!==e.isPrefix&amp;&amp;(e.depth=e.isGlobstar?1/0:1)}</span>;e.exports=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{const r=<span class="cstat-no" title="statement not covered" >t||{},</span>v=<span class="cstat-no" title="statement not covered" >e.length-1,</span>S=<span class="cstat-no" title="statement not covered" >!0===r.parts||!0===r.scanToEnd,</span>R=<span class="cstat-no" title="statement not covered" >[],</span>A=<span class="cstat-no" title="statement not covered" >[],</span>w=<span class="cstat-no" title="statement not covered" >[];</span>let O,T,C=<span class="cstat-no" title="statement not covered" >e,</span>P=<span class="cstat-no" title="statement not covered" >-1,</span>k=<span class="cstat-no" title="statement not covered" >0,</span>x=<span class="cstat-no" title="statement not covered" >0,</span>N=<span class="cstat-no" title="statement not covered" >!1,</span>I=<span class="cstat-no" title="statement not covered" >!1,</span>L=<span class="cstat-no" title="statement not covered" >!1,</span>D=<span class="cstat-no" title="statement not covered" >!1,</span>M=<span class="cstat-no" title="statement not covered" >!1,</span>H=<span class="cstat-no" title="statement not covered" >!1,</span>$=<span class="cstat-no" title="statement not covered" >!1,</span>F=<span class="cstat-no" title="statement not covered" >!1,</span>j=<span class="cstat-no" title="statement not covered" >!1,</span>B=<span class="cstat-no" title="statement not covered" >0,</span>U=<span class="cstat-no" title="statement not covered" >{value:"",depth:0,isGlob:!1};</span>const G=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >P&gt;=v,</span></span>W=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >O=T,C.charCodeAt(++P))</span>;<span class="cstat-no" title="statement not covered" ></span>for(;P&lt;v;){let e;<span class="cstat-no" title="statement not covered" >if(T=W(),T!==i){<span class="cstat-no" title="statement not covered" >if(!0===H||T===p){<span class="cstat-no" title="statement not covered" >for(B++;!0!==G()&amp;&amp;(T=W());)<span class="cstat-no" title="statement not covered" >if(T!==i)<span class="cstat-no" title="statement not covered" >if(T!==p){<span class="cstat-no" title="statement not covered" >if(!0!==H&amp;&amp;T===c&amp;&amp;(T=W())===c){<span class="cstat-no" title="statement not covered" >if(N=U.isBrace=!0,L=U.isGlob=!0,j=!0,!0===S)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0!==H&amp;&amp;T===a){<span class="cstat-no" title="statement not covered" >if(N=U.isBrace=!0,L=U.isGlob=!0,j=!0,!0===S)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(T===y&amp;&amp;(B--,0===B)){<span class="cstat-no" title="statement not covered" >H=!1,N=U.isBrace=!0,j=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>else <span class="cstat-no" title="statement not covered" >B++;e</span></span>lse <span class="cstat-no" title="statement not covered" >$=U.backslashes=!0,W();<span class="cstat-no" title="statement not covered" >i</span></span></span>f(!0===S)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(T!==l){<span class="cstat-no" title="statement not covered" >if(!0!==r.noext){<span class="cstat-no" title="statement not covered" >if(!0===(T===d||T===o||T===s||T===g||T===u)&amp;&amp;C.charCodeAt(P+1)===f){<span class="cstat-no" title="statement not covered" >if(L=U.isGlob=!0,D=U.isExtglob=!0,j=!0,!0===S){<span class="cstat-no" title="statement not covered" >for(;!0!==G()&amp;&amp;(T=W());)<span class="cstat-no" title="statement not covered" >if(T!==i){<span class="cstat-no" title="statement not covered" >if(T===_){<span class="cstat-no" title="statement not covered" >L=U.isGlob=!0,j=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>else <span class="cstat-no" title="statement not covered" >$=U.backslashes=!0,T=W();<span class="cstat-no" title="statement not covered" >c</span></span></span>ontinue}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(T===s){<span class="cstat-no" title="statement not covered" >if(O===s&amp;&amp;(M=U.isGlobstar=!0),L=U.isGlob=!0,j=!0,!0===S)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(T===g){<span class="cstat-no" title="statement not covered" >if(L=U.isGlob=!0,j=!0,!0===S)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(T===h)<span class="cstat-no" title="statement not covered" >for(;!0!==G()&amp;&amp;(e=W());)<span class="cstat-no" title="statement not covered" >if(e!==i){<span class="cstat-no" title="statement not covered" >if(e===E){<span class="cstat-no" title="statement not covered" >if(I=U.isBracket=!0,L=U.isGlob=!0,j=!0,!0===S)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>}</span>else <span class="cstat-no" title="statement not covered" >$=U.backslashes=!0,W();<span class="cstat-no" title="statement not covered" >i</span></span></span></span>f(!0===r.nonegate||T!==u||P!==k){<span class="cstat-no" title="statement not covered" >if(!0!==r.noparen&amp;&amp;T===f){<span class="cstat-no" title="statement not covered" >if(L=U.isGlob=!0,!0===S){<span class="cstat-no" title="statement not covered" >for(;!0!==G()&amp;&amp;(T=W());)<span class="cstat-no" title="statement not covered" >if(T!==f){<span class="cstat-no" title="statement not covered" >if(T===_){<span class="cstat-no" title="statement not covered" >j=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>else <span class="cstat-no" title="statement not covered" >$=U.backslashes=!0,T=W();<span class="cstat-no" title="statement not covered" >c</span></span></span>ontinue}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!0===L){<span class="cstat-no" title="statement not covered" >if(j=!0,!0===S)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>}</span>else <span class="cstat-no" title="statement not covered" >F=U.negated=!0,k++}</span></span>else{<span class="cstat-no" title="statement not covered" >if(R.push(P),A.push(U),U={value:"",depth:0,isGlob:!1},!0===j)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(O===c&amp;&amp;P===k+1){<span class="cstat-no" title="statement not covered" >k+=2;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>x</span>=P+1}</span>}</span>else <span class="cstat-no" title="statement not covered" >$=U.backslashes=!0,T=W(),T===p&amp;&amp;(H=!0)}<span class="cstat-no" title="statement not covered" ></span></span>!</span>0===r.noext&amp;&amp;(D=!1,L=!1);l</span>et V=<span class="cstat-no" title="statement not covered" >C,</span>K=<span class="cstat-no" title="statement not covered" >"",</span>q=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>k&gt;0&amp;&amp;(K=C.slice(0,k),C=C.slice(k),x-=k),V&amp;&amp;!0===L&amp;&amp;x&gt;0?(V=C.slice(0,x),q=C.slice(x)):!0===L?(V="",q=C):V=C,V&amp;&amp;""!==V&amp;&amp;"/"!==V&amp;&amp;V!==C&amp;&amp;m(V.charCodeAt(V.length-1))&amp;&amp;(V=V.slice(0,-1)),!0===r.unescape&amp;&amp;(q&amp;&amp;(q=n.removeBackslashes(q)),V&amp;&amp;!0===$&amp;&amp;(V=n.removeBackslashes(V)));c</span>onst Y=<span class="cstat-no" title="statement not covered" >{prefix:K,input:e,start:k,base:V,glob:q,isBrace:N,isBracket:I,isGlob:L,isExtglob:D,isGlobstar:M,negated:F};<span class="cstat-no" title="statement not covered" ></span>if(!0===r.tokens&amp;&amp;(Y.maxDepth=0,m(T)||A.push(U),Y.tokens=A),!0===r.parts||!0===r.tokens){let t;<span class="cstat-no" title="statement not covered" >for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;R.length;n++){const s=<span class="cstat-no" title="statement not covered" >t?t+1:k,</span>o=<span class="cstat-no" title="statement not covered" >R[n],</span>i=<span class="cstat-no" title="statement not covered" >e.slice(s,o);<span class="cstat-no" title="statement not covered" ></span>r.tokens&amp;&amp;(0===n&amp;&amp;0!==k?(A[n].isPrefix=!0,A[n].value=K):A[n].value=i,b(A[n]),Y.maxDepth+=A[n].depth),0===n&amp;&amp;""===i||w.push(i),t=o}<span class="cstat-no" title="statement not covered" ></span>i</span>f(t&amp;&amp;t+1&lt;e.length){const n=<span class="cstat-no" title="statement not covered" >e.slice(t+1);<span class="cstat-no" title="statement not covered" ></span>w.push(n),r.tokens&amp;&amp;(A[A.length-1].value=n,b(A[A.length-1]),Y.maxDepth+=A[A.length-1].depth)}<span class="cstat-no" title="statement not covered" ></span>Y</span>.slashes=R,Y.parts=w}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Y}</span>},3598:(e,t,r)=&gt;{"use strict";const n=r(5622),s="win32"===process.platform,{REGEX_BACKSLASH:o,REGEX_REMOVE_BACKSLASH:i,REGEX_SPECIAL_CHARS:a,REGEX_SPECIAL_CHARS_GLOBAL:c}=r(1086);t.isObject=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >null!==e&amp;&amp;"object"==typeof e&amp;&amp;!Array.isArray(e),</span>t.hasRegexChars=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >a.test(e),</span>t.isRegexChar=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >1===e.length&amp;&amp;t.hasRegexChars(e),</span>t.escapeRegex=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.replace(c,"\\$1"),</span>t.toPosixSlashes=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.replace(o,"/"),</span>t.removeBackslashes=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.replace(i,<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"\\"===e?"":e)</span>,</span>t.supportsLookbehinds=<span class="fstat-no" title="function not covered" >()</span>=&gt;{const e=<span class="cstat-no" title="statement not covered" >process.version.slice(1).split(".").map(Number);<span class="cstat-no" title="statement not covered" ></span>return 3===e.length&amp;&amp;e[0]&gt;=9||8===e[0]&amp;&amp;e[1]&gt;=10}</span>,t.isWindows=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e&amp;&amp;"boolean"==typeof e.windows?e.windows:!0===s||"\\"===n.sep,</span>t.escapeLast=<span class="fstat-no" title="function not covered" >(e</span>,r,n)=&gt;{const s=<span class="cstat-no" title="statement not covered" >e.lastIndexOf(r,n);<span class="cstat-no" title="statement not covered" ></span>return-1===s?e:"\\"===e[s-1]?t.escapeLast(e,r,s-1):`${e.slice(0,s)}\\${e.slice(s)}`}</span>,t.removePrefix=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return r.startsWith("./")&amp;&amp;(r=r.slice(2),t.prefix="./"),r}</span>,t.wrapOutput=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >`${r.contains?"":"^"}(?:${e})${r.contains?"":"$"}`;<span class="cstat-no" title="statement not covered" ></span>return!0===t.negated&amp;&amp;(n=`(?:^(?!${n}).*$)`),n}</span>},2383:e=&gt;{"use strict";e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >new e,</span>r=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){var n=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return n.next?t=n.next:(t=new e,r=t),n.next=null,n}</span>,release:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r.next=e,r=e}</span>}}</span>},9078:e=&gt;{e.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var r,n,s,o=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>Array.isArray(e)?(r=[],n=e.length):(s=Object.keys(e),r={},n=s.length);f</span>unction <span class="fstat-no" title="function not covered" >i(</span>e){function <span class="fstat-no" title="function not covered" >n(</span>){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t(e,r),t=null}<span class="cstat-no" title="statement not covered" ></span>o?process.nextTick(n):n()}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t,s){<span class="cstat-no" title="statement not covered" >r[e]=s,(0==--n||t)&amp;&amp;i(t)}<span class="cstat-no" title="statement not covered" ></span>n?s?s.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e[t]((<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >a(t,e,r)}</span>))}</span>)):e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e((<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >a(t,e,r)}</span>))}</span>)):i(null);<span class="cstat-no" title="statement not covered" >o</span>=!1}</span>},7234:e=&gt;{"use strict";e.exports=<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >/^\\\\\?\\/.test(e),</span>r=<span class="cstat-no" title="statement not covered" >/[^\u0000-\u0080]+/.test(e);<span class="cstat-no" title="statement not covered" ></span>return t||r?e:e.replace(/\\/g,"/")}</span>},9428:(e,t,r)=&gt;{"use strict";const n=r(2087),s=r(3867),o=r(2918),{env:i}=process;let a;function c(e){return 0!==e&amp;&amp;{level:e,hasBasic:!0,has256:e&gt;=2,has16m:e&gt;=3}}function u(e,t){<span class="missing-if-branch" title="if path not taken" >I</span>if(0===a)<span class="cstat-no" title="statement not covered" >return 0;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o("color=16m")||o("color=full")||o("color=truecolor"))<span class="cstat-no" title="statement not covered" >return 3;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o("color=256"))<span class="cstat-no" title="statement not covered" >return 2;<span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e&amp;&amp;!t&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >void 0===a)<span class="cstat-no" title="statement not covered" ></span>return 0;c</span>onst r=a||0;<span class="missing-if-branch" title="if path not taken" >I</span>if("dumb"===i.TERM)<span class="cstat-no" title="statement not covered" >return r;<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f("win32"===process.platform){const e=n.release().split(".");return Number(e[0])&gt;=10&amp;&amp;Number(e[2])&gt;=10586?Number(e[2])&gt;=14931?3:<span class="branch-1 cbranch-no" title="branch not covered" >2:<span class="branch-1 cbranch-no" title="branch not covered" ></span>1}<span class="cstat-no" title="statement not covered" ></span>if("CI"in i)<span class="cstat-no" title="statement not covered" >return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI"].some(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e in i)</span>||"codeship"===i.CI_NAME?1:r;<span class="cstat-no" title="statement not covered" >i</span></span>f("TEAMCITY_VERSION"in i)<span class="cstat-no" title="statement not covered" >return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(i.TEAMCITY_VERSION)?1:0;<span class="cstat-no" title="statement not covered" >i</span></span>f("GITHUB_ACTIONS"in i)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" >i</span></span>f("truecolor"===i.COLORTERM)<span class="cstat-no" title="statement not covered" >return 3;<span class="cstat-no" title="statement not covered" >i</span></span>f("TERM_PROGRAM"in i){const e=<span class="cstat-no" title="statement not covered" >parseInt((i.TERM_PROGRAM_VERSION||"").split(".")[0],10);<span class="cstat-no" title="statement not covered" ></span>switch(i.TERM_PROGRAM){case"iTerm.app":<span class="cstat-no" title="statement not covered" >return e&gt;=3?3:2;c</span>ase"Apple_Terminal":<span class="cstat-no" title="statement not covered" >return 2}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn/-256(color)?$/i.test(i.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(i.TERM)||"COLORTERM"in i?1:r}</span>o("no-color")||o("no-colors")||o("color=false")||o("color=never")?<span class="branch-0 cbranch-no" title="branch not covered" >a=0:</span>(o("color")||o("colors")||o("color=true")||o("color=always"))&amp;&amp;(<span class="branch-4 cbranch-no" title="branch not covered" >a=1)</span>,"FORCE_COLOR"in i&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >a="true"===i.FORCE_COLOR?1:"false"===i.FORCE_COLOR?0:0===i.FORCE_COLOR.length?1:Math.min(parseInt(i.FORCE_COLOR,10),3))</span>,e.exports={supportsColor:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return c(u(e,e&amp;&amp;e.isTTY))}</span>,stdout:c(u(!0,s.isatty(1))),stderr:c(u(!0,s.isatty(2)))}},4615:(e,t,r)=&gt;{"use strict";
/*!
 * to-regex-range &lt;https://github.com/micromatch/to-regex-range&gt;
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */const n=r(9235),s=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(!1===n(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("toRegexRange: expected the first argument to be a number");<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0===t||e===t)<span class="cstat-no" title="statement not covered" >return String(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(!1===n(t))<span class="cstat-no" title="statement not covered" >throw new TypeError("toRegexRange: expected the second argument to be a number.");l</span></span>et o=<span class="cstat-no" title="statement not covered" >{relaxZeros:!0,...r};<span class="cstat-no" title="statement not covered" ></span>"boolean"==typeof o.strictZeros&amp;&amp;(o.relaxZeros=!1===o.strictZeros);l</span>et c=<span class="cstat-no" title="statement not covered" >e+":"+t+"="+String(o.relaxZeros)+String(o.shorthand)+String(o.capture)+String(o.wrap);<span class="cstat-no" title="statement not covered" ></span>if(s.cache.hasOwnProperty(c))<span class="cstat-no" title="statement not covered" >return s.cache[c].result;l</span></span>et u=<span class="cstat-no" title="statement not covered" >Math.min(e,t),</span>l=<span class="cstat-no" title="statement not covered" >Math.max(e,t);<span class="cstat-no" title="statement not covered" ></span>if(1===Math.abs(u-l)){let r=<span class="cstat-no" title="statement not covered" >e+"|"+t;<span class="cstat-no" title="statement not covered" ></span>return o.capture?`(${r})`:!1===o.wrap?r:`(?:${r})`}</span>l</span>et p=<span class="cstat-no" title="statement not covered" >d(e)||d(t),</span>f=<span class="cstat-no" title="statement not covered" >{min:e,max:t,a:u,b:l},</span>h=<span class="cstat-no" title="statement not covered" >[],</span>g=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(p&amp;&amp;(f.isPadded=p,f.maxLen=String(f.max).length),u&lt;0){<span class="cstat-no" title="statement not covered" >g=i(l&lt;0?Math.abs(l):1,Math.abs(u),f,o),u=f.a=0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l&gt;=0&amp;&amp;(h=i(u,l,f,o)),f.negatives=g,f.positives=h,f.result=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r){let n=<span class="cstat-no" title="statement not covered" >a(e,t,"-",!1,r)||[],</span>s=<span class="cstat-no" title="statement not covered" >a(t,e,"",!1,r)||[],</span>o=<span class="cstat-no" title="statement not covered" >a(e,t,"-?",!0,r)||[];<span class="cstat-no" title="statement not covered" ></span>return n.concat(o).concat(s).join("|")}</span>(g,h,o),!0===o.capture?f.result=`(${f.result})`:!1!==o.wrap&amp;&amp;h.length+g.length&gt;1&amp;&amp;(f.result=`(?:${f.result})`),s.cache[c]=f,f.result}</span>;function <span class="fstat-no" title="function not covered" >o(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(e===t)<span class="cstat-no" title="statement not covered" >return{pattern:e,count:[],digits:0};l</span></span>et n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >r.push([e[n],t[n]]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>(e,t),</span>s=<span class="cstat-no" title="statement not covered" >n.length,</span>o=<span class="cstat-no" title="statement not covered" >"",</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;s;e++){let[t,s]=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>t===s?o+=t:"0"!==t||"9"!==s?o+=h(t,s,r):i++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i&amp;&amp;(o+=!0===r.shorthand?"\\d":"[0-9]"),{pattern:o,count:[i],digits:s}}</span>function <span class="fstat-no" title="function not covered" >i(</span>e,t,r,n){let s,i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e,t){let r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >1,</span>s=<span class="cstat-no" title="statement not covered" >l(e,r),</span>o=<span class="cstat-no" title="statement not covered" >new Set([t]);<span class="cstat-no" title="statement not covered" ></span>for(;e&lt;=s&amp;&amp;s&lt;=t;)<span class="cstat-no" title="statement not covered" >o.add(s),r+=1,s=l(e,r);<span class="cstat-no" title="statement not covered" >f</span></span>or(s=p(t+1,n)-1;e&lt;s&amp;&amp;s&lt;=t;)<span class="cstat-no" title="statement not covered" >o.add(s),n+=1,s=p(t+1,n)-1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o=[...o],o.sort(c),o}</span>(e,t),</span>a=<span class="cstat-no" title="statement not covered" >[],</span>u=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;i.length;e++){let t=<span class="cstat-no" title="statement not covered" >i[e],</span>c=<span class="cstat-no" title="statement not covered" >o(String(u),String(t),n),</span>l=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>r.isPadded||!s||s.pattern!==c.pattern?(r.isPadded&amp;&amp;(l=g(t,r,n)),c.string=l+c.pattern+f(c.count),a.push(c),u=t+1,s=c):(s.count.length&gt;1&amp;&amp;s.count.pop(),s.count.push(c.count[0]),s.string=s.pattern+f(s.count),u=t+1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t,r,n,s){let o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let s of e){let{string:e}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>n||u(t,"string",e)||o.push(r+e),n&amp;&amp;u(t,"string",e)&amp;&amp;o.push(r+e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,t){<span class="cstat-no" title="statement not covered" >return e&gt;t?1:t&gt;e?-1:0}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return e.some(<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e[t]===r)</span>}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,t){<span class="cstat-no" title="statement not covered" >return Number(String(e).slice(0,-t)+"9".repeat(t))}</span>function <span class="fstat-no" title="function not covered" >p(</span>e,t){<span class="cstat-no" title="statement not covered" >return e-e%Math.pow(10,t)}</span>function <span class="fstat-no" title="function not covered" >f(</span>e){let[t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >""]</span>=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return r||t&gt;1?`{${t+(r?","+r:"")}}`:""}</span>function <span class="fstat-no" title="function not covered" >h(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return`[${e}${t-e==1?"":"-"}${t}]`}</span>function <span class="fstat-no" title="function not covered" >d(</span>e){<span class="cstat-no" title="statement not covered" >return/^-?(0+)\d/.test(e)}</span>function <span class="fstat-no" title="function not covered" >g(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(!t.isPadded)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et n=<span class="cstat-no" title="statement not covered" >Math.abs(t.maxLen-String(e).length),</span>s=<span class="cstat-no" title="statement not covered" >!1!==r.relaxZeros;<span class="cstat-no" title="statement not covered" ></span>switch(n){case 0:<span class="cstat-no" title="statement not covered" >return"";c</span>ase 1:<span class="cstat-no" title="statement not covered" >return s?"0?":"0";c</span>ase 2:<span class="cstat-no" title="statement not covered" >return s?"0{0,2}":"00";d</span>efault:<span class="cstat-no" title="statement not covered" >return s?`0{0,${n}}`:`0{${n}}`}</span>}</span>s.cache={},s.clearCache=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s.cache={},</span>e.exports=s},6370:(e,t,r)=&gt;{"use strict";r.r(t),r.d(t,{__extends:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s,</span>__assign:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o,</span>__rest:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i,</span>__decorate:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >a,</span>__param:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >c,</span>__metadata:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >u,</span>__awaiter:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l,</span>__generator:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >p,</span>__createBinding:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >f,</span>__exportStar:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >h,</span>__values:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >d,</span>__read:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >g,</span>__spread:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >y,</span>__spreadArrays:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >_,</span>__await:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >E,</span>__asyncGenerator:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >m,</span>__asyncDelegator:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >b,</span>__asyncValues:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >v,</span>__makeTemplateObject:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >S,</span>__importStar:()=&gt;R,__importDefault:()=&gt;A,__classPrivateFieldGet:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >w,</span>__classPrivateFieldSet:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >O}</span>);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.
&nbsp;
Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.
&nbsp;
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var n=<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return(n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e.__proto__=t}</span>||<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >t.hasOwnProperty(r)&amp;&amp;(e[r]=t[r])}</span></span>)(e,t)}</span>;function <span class="fstat-no" title="function not covered" >s(</span>e,t){function <span class="fstat-no" title="function not covered" >r(</span>){<span class="cstat-no" title="statement not covered" >this.constructor=e}<span class="cstat-no" title="statement not covered" ></span>n(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}</span>var o=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return(o=Object.assign||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var t,r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >arguments.length;</span>r&lt;n;r++)<span class="cstat-no" title="statement not covered" >for(var s in t=arguments[r])<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(t,s)&amp;&amp;(e[s]=t[s]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>).apply(this,arguments)}</span>;function <span class="fstat-no" title="function not covered" >i(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var n in e)<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty.call(e,n)&amp;&amp;t.indexOf(n)&lt;0&amp;&amp;(r[n]=e[n]);<span class="cstat-no" title="statement not covered" >i</span></span>f(null!=e&amp;&amp;"function"==typeof Object.getOwnPropertySymbols){var s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(n=Object.getOwnPropertySymbols(e);s&lt;n.length;s++)<span class="cstat-no" title="statement not covered" >t.indexOf(n[s])&lt;0&amp;&amp;Object.prototype.propertyIsEnumerable.call(e,n[s])&amp;&amp;(r[n[s]]=e[n[s]])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t,r,n){var s,o=<span class="cstat-no" title="statement not covered" >arguments.length,</span>i=<span class="cstat-no" title="statement not covered" >o&lt;3?t:null===n?n=Object.getOwnPropertyDescriptor(t,r):n;<span class="cstat-no" title="statement not covered" ></span>if("object"==typeof Reflect&amp;&amp;"function"==typeof Reflect.decorate)<span class="cstat-no" title="statement not covered" >i=Reflect.decorate(e,t,r,n);e</span>lse <span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >e.length-1;</span>a&gt;=0;a--)<span class="cstat-no" title="statement not covered" >(s=e[a])&amp;&amp;(i=(o&lt;3?s(i):o&gt;3?s(t,r,i):s(t,r))||i);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn o&gt;3&amp;&amp;i&amp;&amp;Object.defineProperty(t,r,i),i}</span>function <span class="fstat-no" title="function not covered" >c(</span>e,t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(r,n){<span class="cstat-no" title="statement not covered" >t(r,n,e)}</span>}</span>function <span class="fstat-no" title="function not covered" >u(</span>e,t){<span class="cstat-no" title="statement not covered" >if("object"==typeof Reflect&amp;&amp;"function"==typeof Reflect.metadata)<span class="cstat-no" title="statement not covered" >return Reflect.metadata(e,t)}</span></span>function <span class="fstat-no" title="function not covered" >l(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >return new(r||(r=Promise))((<span class="fstat-no" title="function not covered" >fu</span>nction(s,o){function <span class="fstat-no" title="function not covered" >i(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c(n.next(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >a(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >c(n.throw(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >o(e)}</span>}</span>function <span class="fstat-no" title="function not covered" >c(</span>e){var t;<span class="cstat-no" title="statement not covered" >e.done?s(e.value):(t=e.value,t instanceof r?t:new r((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e(t)}</span>))).then(i,a)}<span class="cstat-no" title="statement not covered" ></span>c((n=n.apply(e,t||[])).next())}</span>))}</span>function <span class="fstat-no" title="function not covered" >p(</span>e,t){var r,n,s,o,i=<span class="cstat-no" title="statement not covered" >{label:0,sent:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(1&amp;s[0])<span class="cstat-no" title="statement not covered" >throw s[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn s[1]}</span>,trys:[],ops:[]};<span class="cstat-no" title="statement not covered" ></span>return o={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&amp;&amp;(o[Symbol.iterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>),o;f</span>unction <span class="fstat-no" title="function not covered" >a(</span>o){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >throw new TypeError("Generator is already executing.");<span class="cstat-no" title="statement not covered" >f</span></span>or(;i;)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if(r=1,n&amp;&amp;(s=2&amp;o[0]?n.return:o[0]?n.throw||((s=n.return)&amp;&amp;s.call(n),0):n.next)&amp;&amp;!(s=s.call(n,o[1])).done)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >s</span></span>witch(n=0,s&amp;&amp;(o=[2&amp;o[0],s.value]),o[0]){case 0:case 1:<span class="cstat-no" title="statement not covered" >s=o;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >return i.label++,{value:o[1],done:!1};c</span>ase 5:<span class="cstat-no" title="statement not covered" >i.label++,n=o[1],o=[0];<span class="cstat-no" title="statement not covered" >c</span>ontinue;c</span>ase 7:<span class="cstat-no" title="statement not covered" >o=i.ops.pop(),i.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue;d</span>efault:<span class="cstat-no" title="statement not covered" >if(!(s=i.trys,(s=s.length&gt;0&amp;&amp;s[s.length-1])||6!==o[0]&amp;&amp;2!==o[0])){<span class="cstat-no" title="statement not covered" >i=0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(3===o[0]&amp;&amp;(!s||o[1]&gt;s[0]&amp;&amp;o[1]&lt;s[3])){<span class="cstat-no" title="statement not covered" >i.label=o[1];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(6===o[0]&amp;&amp;i.label&lt;s[1]){<span class="cstat-no" title="statement not covered" >i.label=s[1],s=o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s&amp;&amp;i.label&lt;s[2]){<span class="cstat-no" title="statement not covered" >i.label=s[2],i.ops.push(o);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>[2]&amp;&amp;i.ops.pop(),i.trys.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>o</span>=t.call(e,i)}</span>catch(e){<span class="cstat-no" title="statement not covered" >o=[6,e],n=0}</span>finally{<span class="cstat-no" title="statement not covered" >r=s=0}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(5&amp;o[0])<span class="cstat-no" title="statement not covered" >throw o[1];<span class="cstat-no" title="statement not covered" >r</span></span>eturn{value:o[0]?o[1]:void 0,done:!0}}</span>([o,a])}</span>}</span>}function <span class="fstat-no" title="function not covered" >f(</span>e,t,r,n){<span class="cstat-no" title="statement not covered" >void 0===n&amp;&amp;(n=r),e[n]=t[r]}</span>function <span class="fstat-no" title="function not covered" >h(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >"default"===r||t.hasOwnProperty(r)||(t[r]=e[r])}</span></span>function <span class="fstat-no" title="function not covered" >d(</span>e){var t=<span class="cstat-no" title="statement not covered" >"function"==typeof Symbol&amp;&amp;Symbol.iterator,</span>r=<span class="cstat-no" title="statement not covered" >t&amp;&amp;e[t],</span>n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r.call(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(e&amp;&amp;"number"==typeof e.length)<span class="cstat-no" title="statement not covered" >return{next:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;n&gt;=e.length&amp;&amp;(e=void 0),{value:e&amp;&amp;e[n++],done:!e}}</span>};<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")}</span>function <span class="fstat-no" title="function not covered" >g(</span>e,t){var r=<span class="cstat-no" title="statement not covered" >"function"==typeof Symbol&amp;&amp;e[Symbol.iterator];<span class="cstat-no" title="statement not covered" ></span>if(!r)<span class="cstat-no" title="statement not covered" >return e;v</span></span>ar n,s,o=<span class="cstat-no" title="statement not covered" >r.call(e),</span>i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >for(;(void 0===t||t-- &gt;0)&amp;&amp;!(n=o.next()).done;)<span class="cstat-no" title="statement not covered" >i.push(n.value)}</span></span>catch(e){<span class="cstat-no" title="statement not covered" >s={error:e}}</span>finally{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >n&amp;&amp;!n.done&amp;&amp;(r=o.return)&amp;&amp;r.call(o)}</span>finally{<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >throw s.error}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >y(</span>){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >[],</span>t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;arguments.length;t++)<span class="cstat-no" title="statement not covered" >e=e.concat(g(arguments[t]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >_(</span>){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >0,</span>t=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >arguments.length;</span>t&lt;r;t++)<span class="cstat-no" title="statement not covered" >e+=arguments[t].length;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Array(e),</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;r;t++)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >arguments[t],</span>i=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >o.length;</span>i&lt;a;i++,s++)<span class="cstat-no" title="statement not covered" >n[s]=o[i];<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >E(</span>e){<span class="cstat-no" title="statement not covered" >return this instanceof E?(this.v=e,this):new E(e)}</span>function <span class="fstat-no" title="function not covered" >m(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(!Symbol.asyncIterator)<span class="cstat-no" title="statement not covered" >throw new TypeError("Symbol.asyncIterator is not defined.");v</span></span>ar n,s=<span class="cstat-no" title="statement not covered" >r.apply(e,t||[]),</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return n={},i("next"),i("throw"),i("return"),n[Symbol.asyncIterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,n;f</span>unction <span class="fstat-no" title="function not covered" >i(</span>e){<span class="cstat-no" title="statement not covered" >s[e]&amp;&amp;(n[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(r,n){<span class="cstat-no" title="statement not covered" >o.push([e,t,r,n])&gt;1||a(e,t)}</span>))}</span>)}</span>function <span class="fstat-no" title="function not covered" >a(</span>e,t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >(r=s[e](t)).value instanceof E?Promise.resolve(r.value.v).then(c,u):l(o[0][2],r)}</span>catch(e){<span class="cstat-no" title="statement not covered" >l(o[0][3],e)}</span>v</span>ar r}function <span class="fstat-no" title="function not covered" >c(</span>e){<span class="cstat-no" title="statement not covered" >a("next",e)}</span>function <span class="fstat-no" title="function not covered" >u(</span>e){<span class="cstat-no" title="statement not covered" >a("throw",e)}</span>function <span class="fstat-no" title="function not covered" >l(</span>e,t){<span class="cstat-no" title="statement not covered" >e(t),o.shift(),o.length&amp;&amp;a(o[0][0],o[0][1])}</span>}function <span class="fstat-no" title="function not covered" >b(</span>e){var t,r;<span class="cstat-no" title="statement not covered" >return t={},n("next"),n("throw",(<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >throw e}</span>)),n("return"),t[Symbol.iterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,t;f</span>unction <span class="fstat-no" title="function not covered" >n(</span>n,s){<span class="cstat-no" title="statement not covered" >t[n]=e[n]?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(r=!r)?{value:E(e[n](t)),done:"return"===n}:s?s(t):t}</span>:s}</span>}function <span class="fstat-no" title="function not covered" >v(</span>e){<span class="cstat-no" title="statement not covered" >if(!Symbol.asyncIterator)<span class="cstat-no" title="statement not covered" >throw new TypeError("Symbol.asyncIterator is not defined.");v</span></span>ar t,r=<span class="cstat-no" title="statement not covered" >e[Symbol.asyncIterator];<span class="cstat-no" title="statement not covered" ></span>return r?r.call(e):(e=d(e),t={},n("next"),n("throw"),n("return"),t[Symbol.asyncIterator]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this}</span>,t);f</span>unction <span class="fstat-no" title="function not covered" >n(</span>r){<span class="cstat-no" title="statement not covered" >t[r]=e[r]&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(n,s){<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,r,n){<span class="cstat-no" title="statement not covered" >Promise.resolve(n).then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e({value:t,done:r})}</span>),t)}</span>)(n,s,(t=e[r](t)).done,t.value)}</span>))}</span>}</span>}function <span class="fstat-no" title="function not covered" >S(</span>e,t){<span class="cstat-no" title="statement not covered" >return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e}</span>function R(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(e&amp;&amp;e.__esModule)return e;var t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(null!=e)<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Object.hasOwnProperty.call(e,r)&amp;&amp;(t[r]=e[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t.default=e,t}</span>function A(e){return e&amp;&amp;e.__esModule?<span class="branch-0 cbranch-no" title="branch not covered" >e:</span>{default:e}}function <span class="fstat-no" title="function not covered" >w(</span>e,t){<span class="cstat-no" title="statement not covered" >if(!t.has(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("attempted to get private field on non-instance");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.get(e)}</span>function <span class="fstat-no" title="function not covered" >O(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(!t.has(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("attempted to set private field on non-instance");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.set(e,r),r}</span>},4688:e=&gt;{"use strict";e.exports=require("@yarnpkg/fslib")},8042:e=&gt;{"use strict";e.exports=require("clipanion")},6417:e=&gt;{"use strict";e.exports=require("crypto")},8614:e=&gt;{"use strict";e.exports=require("events")},5747:e=&gt;{"use strict";e.exports=require("fs")},2087:e=&gt;{"use strict";e.exports=require("os")},5622:e=&gt;{"use strict";e.exports=require("path")},1191:e=&gt;{"use strict";e.exports=require("querystring")},9513:e=&gt;{"use strict";e.exports=require("semver")},2413:e=&gt;{"use strict";e.exports=require("stream")},3867:e=&gt;{"use strict";e.exports=require("tty")},1669:e=&gt;{"use strict";e.exports=require("util")}},t={};function r(n){if(t[n])return t[n].exports;var s=t[n]={id:n,loaded:!1,exports:{}};return e[n](s,s.exports,r),s.loaded=!0,s.exports}return r.c=t,r.d=(e,t)=&gt;{for(var n in t)r.o(t,n)&amp;&amp;!r.o(e,n)&amp;&amp;Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=&gt;Object.prototype.hasOwnProperty.call(e,t),r.r=e=&gt;{"undefined"!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.nmd=e=&gt;(e.paths=[],e.children||(e.children=[]),e),r(7847)})();
return plugin;
}
};</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-05-16T10:35:10.742Z
            </div>
        <script src="../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../sorter.js"></script>
        <script src="../../block-navigation.js"></script>
    </body>
</html>
    