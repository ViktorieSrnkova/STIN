
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for plugins/@yarnpkg/plugin-typescript.cjs</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../index.html">All files</a> / <a href="index.html">plugins/@yarnpkg</a> plugin-typescript.cjs</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">34.75% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>342/984</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">4.88% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>15/307</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">7.65% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>31/405</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>3/3</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">358x</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-typescript",
factory: function (require) {
var plugin=(()=&gt;{var Ft=Object.create,H=Object.defineProperty,Bt=Object.defineProperties,Kt=Object.getOwnPropertyDescriptor,zt=Object.getOwnPropertyDescriptors,Gt=Object.getOwnPropertyNames,Q=Object.getOwnPropertySymbols,$t=Object.getPrototypeOf,ne=Object.prototype.hasOwnProperty,De=Object.prototype.propertyIsEnumerable;var Re=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >t in e?H(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,</span>u=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >for(var r in t||(t={}))<span class="cstat-no" title="statement not covered" >ne.call(t,r)&amp;&amp;Re(e,r,t[r]);<span class="cstat-no" title="statement not covered" >i</span></span>f(Q)<span class="cstat-no" title="statement not covered" >for(var r of Q(t))<span class="cstat-no" title="statement not covered" >De.call(t,r)&amp;&amp;Re(e,r,t[r]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>,g=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >Bt(e,zt(t)),</span>Lt=e=&gt;H(e,"__esModule",{value:!0});var R=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{var r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(var s in e)<span class="cstat-no" title="statement not covered" >ne.call(e,s)&amp;&amp;t.indexOf(s)&lt;0&amp;&amp;(r[s]=e[s]);<span class="cstat-no" title="statement not covered" >i</span></span>f(e!=null&amp;&amp;Q)<span class="cstat-no" title="statement not covered" >for(var s of Q(e))<span class="cstat-no" title="statement not covered" >t.indexOf(s)&lt;0&amp;&amp;De.call(e,s)&amp;&amp;(r[s]=e[s]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn r}</span>;var I=(e,t)=&gt;()=&gt;(t||e((t={exports:{}}).exports,t),t.exports),Vt=(e,t)=&gt;{for(var r in t)H(e,r,{get:t[r],enumerable:!0})},Qt=(e,t,r)=&gt;{<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;typeof t=="object"||typeof t=="function")for(let s of Gt(t))!ne.call(e,s)&amp;&amp;s!=="default"&amp;&amp;H(e,s,{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t[s],</span>enumerable:!(r=Kt(t,s))||r.enumerable});return e},C=e=&gt;Qt(Lt(H(e!=null?Ft($t(e)):<span class="branch-1 cbranch-no" title="branch not covered" >{},</span>"default",e&amp;&amp;e.__esModule&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >"default"in e?<span class="branch-0 cbranch-no" title="branch not covered" ></span>{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.default,</span>enumerable:!0}:</span>{value:e,enumerable:!0})),e);var xe=I(J=&gt;{"use strict";Object.defineProperty(J,"__esModule",{value:!0});function <span class="fstat-no" title="function not covered" >_(</span>e){let t=<span class="cstat-no" title="statement not covered" >[...e.caches],</span>r=<span class="cstat-no" title="statement not covered" >t.shift();<span class="cstat-no" title="statement not covered" ></span>return r===void 0?ve():{<span class="fstat-no" title="function not covered" >ge</span>t(s,n,a=<span class="branch-0 cbranch-no" title="branch not covered" >{miss:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve()}</span>)</span>{<span class="cstat-no" title="statement not covered" >return r.get(s,n,a).catch(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >_({caches:t}).get(s,n,a))</span>}</span>,<span class="fstat-no" title="function not covered" >se</span>t(s,n){<span class="cstat-no" title="statement not covered" >return r.set(s,n).catch(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >_({caches:t}).set(s,n))</span>}</span>,<span class="fstat-no" title="function not covered" >de</span>lete(s){<span class="cstat-no" title="statement not covered" >return r.delete(s).catch(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >_({caches:t}).delete(s))</span>}</span>,<span class="fstat-no" title="function not covered" >cl</span>ear(){<span class="cstat-no" title="statement not covered" >return r.clear().catch(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >_({caches:t}).clear())</span>}</span>}}</span>function <span class="fstat-no" title="function not covered" >ve(</span>){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >ge</span>t(e,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >{miss:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve()}</span>)</span>{<span class="cstat-no" title="statement not covered" >return t().then(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Promise.all([n,r.miss(n)]))</span>.then(<span class="fstat-no" title="function not covered" >([</span>n])=&gt;<span class="cstat-no" title="statement not covered" >n)</span>}</span>,<span class="fstat-no" title="function not covered" >se</span>t(e,t){<span class="cstat-no" title="statement not covered" >return Promise.resolve(t)}</span>,<span class="fstat-no" title="function not covered" >de</span>lete(e){<span class="cstat-no" title="statement not covered" >return Promise.resolve()}</span>,<span class="fstat-no" title="function not covered" >cl</span>ear(){<span class="cstat-no" title="statement not covered" >return Promise.resolve()}</span>}}</span>J.createFallbackableCache=_;J.createNullCache=ve});var Ee=I(($s,qe)=&gt;{qe.exports=xe()});var Te=I(ae=&gt;{"use strict";Object.defineProperty(ae,"__esModule",{value:!0});function <span class="fstat-no" title="function not covered" >Jt(</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >{serializable:!0})</span>{let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >ge</span>t(r,s,n=<span class="branch-0 cbranch-no" title="branch not covered" >{miss:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve()}</span>)</span>{let a=<span class="cstat-no" title="statement not covered" >JSON.stringify(r);<span class="cstat-no" title="statement not covered" ></span>if(a in t)<span class="cstat-no" title="statement not covered" >return Promise.resolve(e.serializable?JSON.parse(t[a]):t[a]);l</span></span>et o=<span class="cstat-no" title="statement not covered" >s(),</span>d=<span class="cstat-no" title="statement not covered" >n&amp;&amp;n.miss||(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve())</span>;<span class="cstat-no" title="statement not covered" ></span>return o.then(<span class="fstat-no" title="function not covered" >y=</span>&gt;<span class="cstat-no" title="statement not covered" >d(y))</span>.then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o)</span>}</span>,<span class="fstat-no" title="function not covered" >se</span>t(r,s){<span class="cstat-no" title="statement not covered" >return t[JSON.stringify(r)]=e.serializable?JSON.stringify(s):s,Promise.resolve(s)}</span>,<span class="fstat-no" title="function not covered" >de</span>lete(r){<span class="cstat-no" title="statement not covered" >return delete t[JSON.stringify(r)],Promise.resolve()}</span>,<span class="fstat-no" title="function not covered" >cl</span>ear(){<span class="cstat-no" title="statement not covered" >return t={},Promise.resolve()}</span>}}</span>ae.createInMemoryCache=Jt});var we=I((Vs,Me)=&gt;{Me.exports=Te()});var Ce=I(M=&gt;{"use strict";Object.defineProperty(M,"__esModule",{value:!0});function <span class="fstat-no" title="function not covered" >Xt(</span>e,t,r){let s=<span class="cstat-no" title="statement not covered" >{"x-algolia-api-key":r,"x-algolia-application-id":t};<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >he</span>aders(){<span class="cstat-no" title="statement not covered" >return e===oe.WithinHeaders?s:{}}</span>,<span class="fstat-no" title="function not covered" >qu</span>eryParameters(){<span class="cstat-no" title="statement not covered" >return e===oe.WithinQueryParameters?s:{}}</span>}}</span>function <span class="fstat-no" title="function not covered" >Yt(</span>e){let t=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >t++,new Promise(<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s(e(r))}</span>,Math.min(100*t,1e3))}</span>))</span>;<span class="cstat-no" title="statement not covered" ></span>return e(r)}</span>function <span class="fstat-no" title="function not covered" >ke(</span>e,t=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >(r</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve())</span></span>{<span class="cstat-no" title="statement not covered" >return Object.assign(e,{<span class="fstat-no" title="function not covered" >wa</span>it(r){<span class="cstat-no" title="statement not covered" >return ke(e.then(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >Promise.all([t(s,r),s]))</span>.then(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s[1])</span>)}</span>})}</span>function <span class="fstat-no" title="function not covered" >Zt(</span>e){let t=<span class="cstat-no" title="statement not covered" >e.length-1;<span class="cstat-no" title="statement not covered" ></span>for(t;t&gt;0;t--){let r=<span class="cstat-no" title="statement not covered" >Math.floor(Math.random()*(t+1)),</span>s=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>e[t]=e[r],e[r]=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >er(</span>e,t){<span class="cstat-no" title="statement not covered" >return Object.keys(t!==void 0?t:{}).forEach(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >e[r]=t[r](e)}</span>),e}</span>function <span class="fstat-no" title="function not covered" >tr(</span>e,...t){let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return e.replace(/%s/g,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >encodeURIComponent(t[r++]))</span>}</span>var rr="4.2.0",sr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.requester.destroy(),</span></span>oe={WithinQueryParameters:0,WithinHeaders:1};M.AuthMode=oe;M.addMethods=er;M.createAuth=Xt;M.createRetryablePromise=Yt;M.createWaitablePromise=ke;M.destroy=sr;M.encode=tr;M.shuffle=Zt;M.version=rr});var F=I((Js,Ue)=&gt;{Ue.exports=Ce()});var Ne=I(ie=&gt;{"use strict";Object.defineProperty(ie,"__esModule",{value:!0});var nr={Delete:"DELETE",Get:"GET",Post:"POST",Put:"PUT"};ie.MethodEnum=nr});var B=I((Ys,We)=&gt;{We.exports=Ne()});var Ze=I(A=&gt;{"use strict";Object.defineProperty(A,"__esModule",{value:!0});var He=B();function <span class="fstat-no" title="function not covered" >ce(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >e||{},</span>s=<span class="cstat-no" title="statement not covered" >r.data||{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(r).forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >["timeout","headers","queryParameters","data","cacheable"].indexOf(n)===-1&amp;&amp;(s[n]=r[n])}</span>),{data:Object.entries(s).length&gt;0?s:void 0,timeout:r.timeout||t,headers:r.headers||{},queryParameters:r.queryParameters||{},cacheable:r.cacheable}}</span>var X={Read:1,Write:2,Any:3},U={Up:1,Down:2,Timeouted:3},_e=2*60*1e3;function <span class="fstat-no" title="function not covered" >ue(</span>e,t=<span class="branch-0 cbranch-no" title="branch not covered" >U.Up)</span>{<span class="cstat-no" title="statement not covered" >return g(u({},e),{status:t,lastUpdate:Date.now()})}</span>function <span class="fstat-no" title="function not covered" >Fe(</span>e){<span class="cstat-no" title="statement not covered" >return e.status===U.Up||Date.now()-e.lastUpdate&gt;_e}</span>function <span class="fstat-no" title="function not covered" >Be(</span>e){<span class="cstat-no" title="statement not covered" >return e.status===U.Timeouted&amp;&amp;Date.now()-e.lastUpdate&lt;=_e}</span>function <span class="fstat-no" title="function not covered" >le(</span>e){<span class="cstat-no" title="statement not covered" >return{protocol:e.protocol||"https",url:e.url,accept:e.accept||X.Any}}</span>function <span class="fstat-no" title="function not covered" >ar(</span>e,t){<span class="cstat-no" title="statement not covered" >return Promise.all(t.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >e.get(r,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve(ue(r)))</span>)</span>).then(<span class="fstat-no" title="function not covered" >r=</span>&gt;{let s=<span class="cstat-no" title="statement not covered" >r.filter(<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >Fe(d))</span>,</span>n=<span class="cstat-no" title="statement not covered" >r.filter(<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >Be(d))</span>,</span>a=<span class="cstat-no" title="statement not covered" >[...s,...n],</span>o=<span class="cstat-no" title="statement not covered" >a.length&gt;0?a.map(<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >le(d))</span>:t;<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >ge</span>tTimeout(d,y){<span class="cstat-no" title="statement not covered" >return(n.length===0&amp;&amp;d===0?1:n.length+3+d)*y}</span>,statelessHosts:o}}</span>)}</span>var or=<span class="fstat-no" title="function not covered" >({</span>isTimedOut:e,status:t})=&gt;<span class="cstat-no" title="statement not covered" >!e&amp;&amp;~~t==0,</span>ir=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >e.status;<span class="cstat-no" title="statement not covered" ></span>return e.isTimedOut||or(e)||~~(t/100)!=2&amp;&amp;~~(t/100)!=4}</span>,cr=<span class="fstat-no" title="function not covered" >({</span>status:e})=&gt;<span class="cstat-no" title="statement not covered" >~~(e/100)==2,</span>ur=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >ir(e)?t.onRetry(e):cr(e)?t.onSucess(e):t.onFail(e);</span>function <span class="fstat-no" title="function not covered" >Qe(</span>e,t,r,s){let n=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >$e(r,s),</span>o=<span class="cstat-no" title="statement not covered" >Le(e,s),</span>d=<span class="cstat-no" title="statement not covered" >r.method,</span>y=<span class="cstat-no" title="statement not covered" >r.method!==He.MethodEnum.Get?{}:u(u({},r.data),s.data),</span>b=<span class="cstat-no" title="statement not covered" >u(u(u({"x-algolia-agent":e.userAgent.value},e.queryParameters),y),s.queryParameters),</span>f=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(h</span>,S)=&gt;{let O=<span class="cstat-no" title="statement not covered" >h.pop();<span class="cstat-no" title="statement not covered" ></span>if(O===void 0)<span class="cstat-no" title="statement not covered" >throw Ve(de(n));l</span></span>et P=<span class="cstat-no" title="statement not covered" >{data:a,headers:o,method:d,url:Ge(O,r.path,b),connectTimeout:S(f,e.timeouts.connect),responseTimeout:S(f,s.timeout)},</span>x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >j=</span>&gt;{let T=<span class="cstat-no" title="statement not covered" >{request:P,response:j,host:O,triesLeft:h.length};<span class="cstat-no" title="statement not covered" ></span>return n.push(T),T}</span>,</span>v=<span class="cstat-no" title="statement not covered" >{onSucess:<span class="fstat-no" title="function not covered" >j=</span>&gt;<span class="cstat-no" title="statement not covered" >Ke(j),<span class="fstat-no" title="function not covered" ></span>on</span>Retry(j){let T=<span class="cstat-no" title="statement not covered" >x(j);<span class="cstat-no" title="statement not covered" ></span>return j.isTimedOut&amp;&amp;f++,Promise.all([e.logger.info("Retryable failure",pe(T)),e.hostsCache.set(O,ue(O,j.isTimedOut?U.Timeouted:U.Down))]).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >p(h,S))</span>}</span>,<span class="fstat-no" title="function not covered" >on</span>Fail(j){<span class="cstat-no" title="statement not covered" >throw x(j),ze(j,de(n))}</span>};<span class="cstat-no" title="statement not covered" ></span>return e.requester.send(P).then(<span class="fstat-no" title="function not covered" >j=</span>&gt;<span class="cstat-no" title="statement not covered" >ur(j,v))</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return ar(e.hostsCache,t).then(<span class="fstat-no" title="function not covered" >h=</span>&gt;<span class="cstat-no" title="statement not covered" >p([...h.statelessHosts].reverse(),h.getTimeout))</span>}</span>function <span class="fstat-no" title="function not covered" >lr(</span>e){let{hostsCache:t,logger:r,requester:s,requestsCache:n,responsesCache:a,timeouts:o,userAgent:d,hosts:y,queryParameters:b,headers:f}=<span class="cstat-no" title="statement not covered" >e,</span>p=<span class="cstat-no" title="statement not covered" >{hostsCache:t,logger:r,requester:s,requestsCache:n,responsesCache:a,timeouts:o,userAgent:d,headers:f,queryParameters:b,hosts:y.map(<span class="fstat-no" title="function not covered" >h=</span>&gt;<span class="cstat-no" title="statement not covered" >le(h))</span>,<span class="fstat-no" title="function not covered" >re</span>ad(h,S){let O=<span class="cstat-no" title="statement not covered" >ce(S,p.timeouts.read),</span>P=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Qe(p,p.hosts.filter(<span class="fstat-no" title="function not covered" >j=</span>&gt;<span class="cstat-no" title="statement not covered" >(j.accept&amp;X.Read)!=0)</span>,h,O);<span class="cstat-no" title="statement not covered" ></span></span>if((O.cacheable!==void 0?O.cacheable:h.cacheable)!==!0)<span class="cstat-no" title="statement not covered" >return P();l</span></span>et v=<span class="cstat-no" title="statement not covered" >{request:h,mappedRequestOptions:O,transporter:{queryParameters:p.queryParameters,headers:p.headers}};<span class="cstat-no" title="statement not covered" ></span>return p.responsesCache.get(v,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >p.requestsCache.get(v,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >p.requestsCache.set(v,P()).then(<span class="fstat-no" title="function not covered" >j=</span>&gt;<span class="cstat-no" title="statement not covered" >Promise.all([p.requestsCache.delete(v),j]),<span class="fstat-no" title="function not covered" ></span>j=</span>&gt;<span class="cstat-no" title="statement not covered" >Promise.all([p.requestsCache.delete(v),Promise.reject(j)]))</span>.then(<span class="fstat-no" title="function not covered" >([</span>j,T])=&gt;<span class="cstat-no" title="statement not covered" >T)</span>)</span>,</span>{miss:<span class="fstat-no" title="function not covered" >j=</span>&gt;<span class="cstat-no" title="statement not covered" >p.responsesCache.set(v,j)}</span>)}</span>,<span class="fstat-no" title="function not covered" >wr</span>ite(h,S){<span class="cstat-no" title="statement not covered" >return Qe(p,p.hosts.filter(<span class="fstat-no" title="function not covered" >O=</span>&gt;<span class="cstat-no" title="statement not covered" >(O.accept&amp;X.Write)!=0)</span>,h,ce(S,p.timeouts.write))}</span>};<span class="cstat-no" title="statement not covered" ></span>return p}</span>function <span class="fstat-no" title="function not covered" >dr(</span>e){let t=<span class="cstat-no" title="statement not covered" >{value:`Algolia for JavaScript (${e})`,<span class="fstat-no" title="function not covered" >ad</span>d(r){let s=<span class="cstat-no" title="statement not covered" >`; ${r.segment}${r.version!==void 0?` (${r.version})`:""}`;<span class="cstat-no" title="statement not covered" ></span>return t.value.indexOf(s)===-1&amp;&amp;(t.value=`${t.value}${s}`),t}</span>};<span class="cstat-no" title="statement not covered" ></span>return t}</span>function <span class="fstat-no" title="function not covered" >Ke(</span>e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.parse(e.content)}</span>catch(t){<span class="cstat-no" title="statement not covered" >throw Je(t.message,e)}</span>}</span>function <span class="fstat-no" title="function not covered" >ze(</span>{content:e,status:t},r){let s=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >s=JSON.parse(e).message}</span>catch(n){}<span class="cstat-no" title="statement not covered" >r</span>eturn Xe(s,t,r)}</span>function <span class="fstat-no" title="function not covered" >pr(</span>e,...t){let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return e.replace(/%s/g,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >encodeURIComponent(t[r++]))</span>}</span>function <span class="fstat-no" title="function not covered" >Ge(</span>e,t,r){let s=<span class="cstat-no" title="statement not covered" >Ye(r),</span>n=<span class="cstat-no" title="statement not covered" >`${e.protocol}://${e.url}/${t.charAt(0)==="/"?t.substr(1):t}`;<span class="cstat-no" title="statement not covered" ></span>return s.length&amp;&amp;(n+=`?${s}`),n}</span>function <span class="fstat-no" title="function not covered" >Ye(</span>e){let t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >Object.prototype.toString.call(r)==="[object Object]"||Object.prototype.toString.call(r)==="[object Array]";<span class="cstat-no" title="statement not covered" ></span></span>return Object.keys(e).map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >pr("%s=%s",r,t(e[r])?JSON.stringify(e[r]):e[r]))</span>.join("&amp;")}</span>function <span class="fstat-no" title="function not covered" >$e(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e.method===He.MethodEnum.Get||e.data===void 0&amp;&amp;t.data===void 0)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >Array.isArray(e.data)?e.data:u(u({},e.data),t.data);<span class="cstat-no" title="statement not covered" ></span>return JSON.stringify(r)}</span>function <span class="fstat-no" title="function not covered" >Le(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >u(u({},e.headers),t.headers),</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(r).forEach(<span class="fstat-no" title="function not covered" >n=</span>&gt;{let a=<span class="cstat-no" title="statement not covered" >r[n];<span class="cstat-no" title="statement not covered" ></span>s[n.toLowerCase()]=a}</span>),s}</span>function <span class="fstat-no" title="function not covered" >de(</span>e){<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >pe(t))</span>}</span>function <span class="fstat-no" title="function not covered" >pe(</span>e){let t=<span class="cstat-no" title="statement not covered" >e.request.headers["x-algolia-api-key"]?{"x-algolia-api-key":"*****"}:{};<span class="cstat-no" title="statement not covered" ></span>return g(u({},e),{request:g(u({},e.request),{headers:u(u({},e.request.headers),t)})})}</span>function <span class="fstat-no" title="function not covered" >Xe(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return{name:"ApiError",message:e,status:t,transporterStackTrace:r}}</span>function <span class="fstat-no" title="function not covered" >Je(</span>e,t){<span class="cstat-no" title="statement not covered" >return{name:"DeserializationError",message:e,response:t}}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>e){<span class="cstat-no" title="statement not covered" >return{name:"RetryError",message:"Unreachable hosts - your application id may be incorrect. If the error persists, contact support@algolia.com.",transporterStackTrace:e}}</span>A.CallEnum=X;A.HostStatusEnum=U;A.createApiError=Xe;A.createDeserializationError=Je;A.createMappedRequestOptions=ce;A.createRetryError=Ve;A.createStatefulHost=ue;A.createStatelessHost=le;A.createTransporter=lr;A.createUserAgent=dr;A.deserializeFailure=ze;A.deserializeSuccess=Ke;A.isStatefulHostTimeouted=Be;A.isStatefulHostUp=Fe;A.serializeData=$e;A.serializeHeaders=Le;A.serializeQueryParameters=Ye;A.serializeUrl=Ge;A.stackFrameWithoutCredentials=pe;A.stackTraceWithoutCredentials=de});var K=I((en,et)=&gt;{et.exports=Ze()});var tt=I(w=&gt;{"use strict";Object.defineProperty(w,"__esModule",{value:!0});var N=F(),mr=K(),z=B(),hr=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >e.region||"us",</span>r=<span class="cstat-no" title="statement not covered" >N.createAuth(N.AuthMode.WithinHeaders,e.appId,e.apiKey),</span>s=<span class="cstat-no" title="statement not covered" >mr.createTransporter(g(u({hosts:[{url:`analytics.${t}.algolia.com`}]},e),{headers:u(g(u({},r.headers()),{"content-type":"application/json"}),e.headers),queryParameters:u(u({},r.queryParameters()),e.queryParameters)})),</span>n=<span class="cstat-no" title="statement not covered" >e.appId;<span class="cstat-no" title="statement not covered" ></span>return N.addMethods({appId:n,transporter:s},e.methods)}</span>,yr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.write({method:z.MethodEnum.Post,path:"2/abtests",data:t},r),</span></span>gr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.write({method:z.MethodEnum.Delete,path:N.encode("2/abtests/%s",t)},r),</span></span>fr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:z.MethodEnum.Get,path:N.encode("2/abtests/%s",t)},r),</span></span>br=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:z.MethodEnum.Get,path:"2/abtests"},t),</span></span>Pr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.write({method:z.MethodEnum.Post,path:N.encode("2/abtests/%s/stop",t)},r);</span></span>w.addABTest=yr;w.createAnalyticsClient=hr;w.deleteABTest=gr;w.getABTest=fr;w.getABTests=br;w.stopABTest=Pr});var st=I((rn,rt)=&gt;{rt.exports=tt()});var at=I(G=&gt;{"use strict";Object.defineProperty(G,"__esModule",{value:!0});var me=F(),jr=K(),nt=B(),Or=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >e.region||"us",</span>r=<span class="cstat-no" title="statement not covered" >me.createAuth(me.AuthMode.WithinHeaders,e.appId,e.apiKey),</span>s=<span class="cstat-no" title="statement not covered" >jr.createTransporter(g(u({hosts:[{url:`recommendation.${t}.algolia.com`}]},e),{headers:u(g(u({},r.headers()),{"content-type":"application/json"}),e.headers),queryParameters:u(u({},r.queryParameters()),e.queryParameters)}));<span class="cstat-no" title="statement not covered" ></span>return me.addMethods({appId:e.appId,transporter:s},e.methods)}</span>,Ir=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:nt.MethodEnum.Get,path:"1/strategies/personalization"},t),</span></span>Ar=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.write({method:nt.MethodEnum.Post,path:"1/strategies/personalization",data:t},r);</span></span>G.createRecommendationClient=Or;G.getPersonalizationStrategy=Ir;G.setPersonalizationStrategy=Ar});var it=I((nn,ot)=&gt;{ot.exports=at()});var jt=I(i=&gt;{"use strict";Object.defineProperty(i,"__esModule",{value:!0});var l=F(),q=K(),m=B(),Sr=require("crypto");function <span class="fstat-no" title="function not covered" >Y(</span>e){let t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >e.request(r).then(<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e.batch!==void 0&amp;&amp;e.batch(s.hits),!e.shouldStop(s))<span class="cstat-no" title="statement not covered" >return s.cursor?t({cursor:s.cursor}):t({page:(r.page||0)+1})}</span></span>);<span class="cstat-no" title="statement not covered" ></span></span>return t({})}</span>var Dr=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >e.appId,</span>r=<span class="cstat-no" title="statement not covered" >l.createAuth(e.authMode!==void 0?e.authMode:l.AuthMode.WithinHeaders,t,e.apiKey),</span>s=<span class="cstat-no" title="statement not covered" >q.createTransporter(g(u({hosts:[{url:`${t}-dsn.algolia.net`,accept:q.CallEnum.Read},{url:`${t}.algolia.net`,accept:q.CallEnum.Write}].concat(l.shuffle([{url:`${t}-1.algolianet.com`},{url:`${t}-2.algolianet.com`},{url:`${t}-3.algolianet.com`}]))},e),{headers:u(g(u({},r.headers()),{"content-type":"application/x-www-form-urlencoded"}),e.headers),queryParameters:u(u({},r.queryParameters()),e.queryParameters)})),</span>n=<span class="cstat-no" title="statement not covered" >{transporter:s,appId:t,<span class="fstat-no" title="function not covered" >ad</span>dAlgoliaAgent(a,o){<span class="cstat-no" title="statement not covered" >s.userAgent.add({segment:a,version:o})}</span>,<span class="fstat-no" title="function not covered" >cl</span>earCache(){<span class="cstat-no" title="statement not covered" >return Promise.all([s.requestsCache.clear(),s.responsesCache.clear()]).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;{})}</span>};<span class="cstat-no" title="statement not covered" ></span>return l.addMethods(n,e.methods)}</span>;function <span class="fstat-no" title="function not covered" >ct(</span>){<span class="cstat-no" title="statement not covered" >return{name:"MissingObjectIDError",message:"All objects must have an unique objectID (like a primary key) to be valid. Algolia is also able to generate objectIDs automatically but *it's not recommended*. To do it, use the `{'autoGenerateObjectIDIfNotExist': true}` option."}}</span>function <span class="fstat-no" title="function not covered" >ut(</span>){<span class="cstat-no" title="statement not covered" >return{name:"ObjectNotFoundError",message:"Object not found."}}</span>function <span class="fstat-no" title="function not covered" >lt(</span>){<span class="cstat-no" title="statement not covered" >return{name:"ValidUntilNotFoundError",message:"ValidUntil not found in given secured api key."}}</span>var Rr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let d=<span class="cstat-no" title="statement not covered" >r||{},</span>{queryParameters:s}=<span class="cstat-no" title="statement not covered" >d,</span>n=<span class="cstat-no" title="statement not covered" >R(d,["queryParameters"]),</span>a=<span class="cstat-no" title="statement not covered" >u({acl:t},s!==void 0?{queryParameters:s}:{}),</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(y</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >l.createRetryablePromise(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >$(e)(y.key,b).catch(<span class="fstat-no" title="function not covered" >p=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(p.status!==404)<span class="cstat-no" title="statement not covered" >throw p;<span class="cstat-no" title="statement not covered" >r</span></span>eturn f()}</span>))</span>;<span class="cstat-no" title="statement not covered" ></span></span>return l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:"1/keys",data:a},n),o)}</span>,</span>vr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;{let n=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(s);<span class="cstat-no" title="statement not covered" ></span>return n.queryParameters["X-Algolia-User-ID"]=t,e.transporter.write({method:m.MethodEnum.Post,path:"1/clusters/mapping",data:{cluster:r}},n)}</span>,</span>xr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.write({method:m.MethodEnum.Post,path:"1/clusters/mapping/batch",data:{users:t,cluster:r}},s),</span></span>Z=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;{let n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(a</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >L(e)(t,{methods:{waitTask:D}}).waitTask(a.taskID,o);<span class="cstat-no" title="statement not covered" ></span></span>return l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/operation",t),data:{operation:"copy",destination:r}},s),n)}</span>,</span>qr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;<span class="cstat-no" title="statement not covered" >Z(e)(t,r,g(u({},s),{scope:[ee.Rules]})),</span></span>Er=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;<span class="cstat-no" title="statement not covered" >Z(e)(t,r,g(u({},s),{scope:[ee.Settings]})),</span></span>Tr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;<span class="cstat-no" title="statement not covered" >Z(e)(t,r,g(u({},s),{scope:[ee.Synonyms]})),</span></span>Mr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >l.createRetryablePromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >$(e)(t,a).then(o).catch(<span class="fstat-no" title="function not covered" >d=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(d.status!==404)<span class="cstat-no" title="statement not covered" >throw d}</span></span>))</span>;<span class="cstat-no" title="statement not covered" ></span></span>return l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Delete,path:l.encode("1/keys/%s",t)},r),s)}</span>,</span>wr=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >q.serializeQueryParameters(t),</span>s=<span class="cstat-no" title="statement not covered" >Sr.createHmac("sha256",e).update(r).digest("hex");<span class="cstat-no" title="statement not covered" ></span>return Buffer.from(s+r).toString("base64")}</span>,</span>$=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:l.encode("1/keys/%s",t)},r),</span></span>kr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:"1/logs"},t),</span></span>Cr=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >Buffer.from(e,"base64").toString("ascii"),</span>r=<span class="cstat-no" title="statement not covered" >/validUntil=(\d+)/,</span>s=<span class="cstat-no" title="statement not covered" >t.match(r);<span class="cstat-no" title="statement not covered" ></span>if(s===null)<span class="cstat-no" title="statement not covered" >throw lt();<span class="cstat-no" title="statement not covered" >r</span></span>eturn parseInt(s[1],10)-Math.round(new Date().getTime()/1e3)}</span>,</span>Ur=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:"1/clusters/mapping/top"},t),</span></span>Nr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:l.encode("1/clusters/mapping/%s",t)},r),</span></span>Wr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{let n=<span class="cstat-no" title="statement not covered" >t||{},</span>{retrieveMappings:r}=<span class="cstat-no" title="statement not covered" >n,</span>s=<span class="cstat-no" title="statement not covered" >R(n,["retrieveMappings"]);<span class="cstat-no" title="statement not covered" ></span>return r===!0&amp;&amp;(s.getClusters=!0),e.transporter.read({method:m.MethodEnum.Get,path:"1/clusters/mapping/pending"},s)}</span>,</span>L=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let s=<span class="cstat-no" title="statement not covered" >{transporter:e.transporter,appId:e.appId,indexName:t};<span class="cstat-no" title="statement not covered" ></span>return l.addMethods(s,r.methods)}</span>,</span>Hr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:"1/keys"},t),</span></span>_r=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:"1/clusters"},t),</span></span>Fr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:"1/indexes"},t),</span></span>Br=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:"1/clusters/mapping"},t),</span></span>Kr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;{let n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(a</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >L(e)(t,{methods:{waitTask:D}}).waitTask(a.taskID,o);<span class="cstat-no" title="statement not covered" ></span></span>return l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/operation",t),data:{operation:"move",destination:r}},s),n)}</span>,</span>zr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >Promise.all(Object.keys(n.taskID).map(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >L(e)(o,{methods:{waitTask:D}}).waitTask(n.taskID[o],a))</span>);<span class="cstat-no" title="statement not covered" ></span></span>return l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:"1/indexes/*/batch",data:{requests:t}},r),s)}</span>,</span>Gr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Post,path:"1/indexes/*/objects",data:{requests:t}},r),</span></span>$r=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >g(u({},n),{params:q.serializeQueryParameters(n.params||{})}))</span>;<span class="cstat-no" title="statement not covered" ></span>return e.transporter.read({method:m.MethodEnum.Post,path:"1/indexes/*/queries",data:{requests:s},cacheable:!0},r)}</span>,</span>Lr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >Promise.all(t.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;{let d=<span class="cstat-no" title="statement not covered" >s.params,</span>{facetName:n,facetQuery:a}=<span class="cstat-no" title="statement not covered" >d,</span>o=<span class="cstat-no" title="statement not covered" >R(d,["facetName","facetQuery"]);<span class="cstat-no" title="statement not covered" ></span>return L(e)(s.indexName,{methods:{searchForFacetValues:dt}}).searchForFacetValues(n,a,u(u({},r),o))}</span>)),</span></span>Vr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(r);<span class="cstat-no" title="statement not covered" ></span>return s.queryParameters["X-Algolia-User-ID"]=t,e.transporter.write({method:m.MethodEnum.Delete,path:"1/clusters/mapping"},s)}</span>,</span>Qr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >l.createRetryablePromise(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >$(e)(t,a).catch(<span class="fstat-no" title="function not covered" >d=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(d.status!==404)<span class="cstat-no" title="statement not covered" >throw d;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o()}</span>))</span>;<span class="cstat-no" title="statement not covered" ></span></span>return l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/keys/%s/restore",t)},r),s)}</span>,</span>Jr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Post,path:"1/clusters/mapping/search",data:{query:t}},r),</span></span>Xr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >Object.assign({},r),</span>f=<span class="cstat-no" title="statement not covered" >r||{},</span>{queryParameters:n}=<span class="cstat-no" title="statement not covered" >f,</span>a=<span class="cstat-no" title="statement not covered" >R(f,["queryParameters"]),</span>o=<span class="cstat-no" title="statement not covered" >n?{queryParameters:n}:{},</span>d=<span class="cstat-no" title="statement not covered" >["acl","indexes","referers","restrictSources","queryParameters","description","maxQueriesPerIPPerHour","maxHitsPerQuery"],</span>y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >p=</span>&gt;<span class="cstat-no" title="statement not covered" >Object.keys(s).filter(<span class="fstat-no" title="function not covered" >h=</span>&gt;<span class="cstat-no" title="statement not covered" >d.indexOf(h)!==-1)</span>.every(<span class="fstat-no" title="function not covered" >h=</span>&gt;<span class="cstat-no" title="statement not covered" >p[h]===s[h])</span>,</span></span>b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(p</span>,h)=&gt;<span class="cstat-no" title="statement not covered" >l.createRetryablePromise(<span class="fstat-no" title="function not covered" >S=</span>&gt;<span class="cstat-no" title="statement not covered" >$(e)(t,h).then(<span class="fstat-no" title="function not covered" >O=</span>&gt;<span class="cstat-no" title="statement not covered" >y(O)?Promise.resolve():S())</span>)</span>;<span class="cstat-no" title="statement not covered" ></span></span>return l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Put,path:l.encode("1/keys/%s",t),data:o},a),b)}</span>,</span>pt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(n.taskID,a);<span class="cstat-no" title="statement not covered" ></span></span>return l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/batch",e.indexName),data:{requests:t}},r),s)}</span>,</span>Yr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Y(g(u({},t),{shouldStop:<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.cursor===void 0,</span>request:<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/browse",e.indexName),data:r},t)}</span>)),</span></span>Zr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >u({hitsPerPage:1e3},t);<span class="cstat-no" title="statement not covered" ></span>return Y(g(u({},r),{shouldStop:<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s.hits.length&lt;r.hitsPerPage,<span class="fstat-no" title="function not covered" ></span>re</span>quest(s){<span class="cstat-no" title="statement not covered" >return mt(e)("",u(u({},r),s)).then(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >g(u({},n),{hits:n.hits.map(<span class="fstat-no" title="function not covered" >a=</span>&gt;(<span class="cstat-no" title="statement not covered" >delete a._highlightResult,a)</span>)}))</span>}</span>}))}</span>,</span>es=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{let r=<span class="cstat-no" title="statement not covered" >u({hitsPerPage:1e3},t);<span class="cstat-no" title="statement not covered" ></span>return Y(g(u({},r),{shouldStop:<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s.hits.length&lt;r.hitsPerPage,<span class="fstat-no" title="function not covered" ></span>re</span>quest(s){<span class="cstat-no" title="statement not covered" >return ht(e)("",u(u({},r),s)).then(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >g(u({},n),{hits:n.hits.map(<span class="fstat-no" title="function not covered" >a=</span>&gt;(<span class="cstat-no" title="statement not covered" >delete a._highlightResult,a)</span>)}))</span>}</span>}))}</span>,</span>te=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;{let y=<span class="cstat-no" title="statement not covered" >s||{},</span>{batchSize:n}=<span class="cstat-no" title="statement not covered" >y,</span>a=<span class="cstat-no" title="statement not covered" >R(y,["batchSize"]),</span>o=<span class="cstat-no" title="statement not covered" >{taskIDs:[],objectIDs:[]},</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(b</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>=&gt;{let f=<span class="cstat-no" title="statement not covered" >[],</span>p;<span class="cstat-no" title="statement not covered" >for(p=b;p&lt;t.length&amp;&amp;(f.push(t[p]),f.length!==(n||1e3));p++);<span class="cstat-no" title="statement not covered" >r</span>eturn f.length===0?Promise.resolve(o):pt(e)(f.map(<span class="fstat-no" title="function not covered" >h=</span>&gt;(<span class="cstat-no" title="statement not covered" >{action:r,body:h})</span>),a).then(<span class="fstat-no" title="function not covered" >h=</span>&gt;(<span class="cstat-no" title="statement not covered" >o.objectIDs=o.objectIDs.concat(h.objectIDs),o.taskIDs.push(h.taskID),p++,d(p))</span>)}</span>;<span class="cstat-no" title="statement not covered" ></span>return l.createWaitablePromise(d(),<span class="fstat-no" title="function not covered" >(b</span>,f)=&gt;<span class="cstat-no" title="statement not covered" >Promise.all(b.taskIDs.map(<span class="fstat-no" title="function not covered" >p=</span>&gt;<span class="cstat-no" title="statement not covered" >D(e)(p,f))</span>))</span>}</span>,</span>ts=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/clear",e.indexName)},t),<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(r.taskID,s))</span>,</span></span>rs=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{let a=<span class="cstat-no" title="statement not covered" >t||{},</span>{forwardToReplicas:r}=<span class="cstat-no" title="statement not covered" >a,</span>s=<span class="cstat-no" title="statement not covered" >R(a,["forwardToReplicas"]),</span>n=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(s);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(n.queryParameters.forwardToReplicas=1),l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/rules/clear",e.indexName)},n),<span class="fstat-no" title="function not covered" >(o</span>,d)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(o.taskID,d))</span>}</span>,</span>ss=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{let a=<span class="cstat-no" title="statement not covered" >t||{},</span>{forwardToReplicas:r}=<span class="cstat-no" title="statement not covered" >a,</span>s=<span class="cstat-no" title="statement not covered" >R(a,["forwardToReplicas"]),</span>n=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(s);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(n.queryParameters.forwardToReplicas=1),l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/synonyms/clear",e.indexName)},n),<span class="fstat-no" title="function not covered" >(o</span>,d)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(o.taskID,d))</span>}</span>,</span>ns=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/deleteByQuery",e.indexName),data:t},r),<span class="fstat-no" title="function not covered" >(s</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(s.taskID,n))</span>,</span></span>as=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Delete,path:l.encode("1/indexes/%s",e.indexName)},t),<span class="fstat-no" title="function not covered" >(r</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(r.taskID,s))</span>,</span></span>os=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >l.createWaitablePromise(yt(e)([t],r).then(<span class="fstat-no" title="function not covered" >s=</span>&gt;(<span class="cstat-no" title="statement not covered" >{taskID:s.taskIDs[0]})</span>),<span class="fstat-no" title="function not covered" >(s</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(s.taskID,n))</span>,</span></span>yt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let s=<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >n=</span>&gt;(<span class="cstat-no" title="statement not covered" >{objectID:n})</span>);<span class="cstat-no" title="statement not covered" ></span>return te(e)(s,k.DeleteObject,r)}</span>,</span>is=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let o=<span class="cstat-no" title="statement not covered" >r||{},</span>{forwardToReplicas:s}=<span class="cstat-no" title="statement not covered" >o,</span>n=<span class="cstat-no" title="statement not covered" >R(o,["forwardToReplicas"]),</span>a=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(n);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(a.queryParameters.forwardToReplicas=1),l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Delete,path:l.encode("1/indexes/%s/rules/%s",e.indexName,t)},a),<span class="fstat-no" title="function not covered" >(d</span>,y)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(d.taskID,y))</span>}</span>,</span>cs=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let o=<span class="cstat-no" title="statement not covered" >r||{},</span>{forwardToReplicas:s}=<span class="cstat-no" title="statement not covered" >o,</span>n=<span class="cstat-no" title="statement not covered" >R(o,["forwardToReplicas"]),</span>a=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(n);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(a.queryParameters.forwardToReplicas=1),l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Delete,path:l.encode("1/indexes/%s/synonyms/%s",e.indexName,t)},a),<span class="fstat-no" title="function not covered" >(d</span>,y)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(d.taskID,y))</span>}</span>,</span>us=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >gt(e)(t).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!0)</span>.catch(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(r.status!==404)<span class="cstat-no" title="statement not covered" >throw r;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1}</span>),</span></span>ls=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let y=<span class="cstat-no" title="statement not covered" >r||{},</span>{query:s,paginate:n}=<span class="cstat-no" title="statement not covered" >y,</span>a=<span class="cstat-no" title="statement not covered" >R(y,["query","paginate"]),</span>o=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >ft(e)(s||"",g(u({},a),{page:o})).then(<span class="fstat-no" title="function not covered" >b=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(let[f,p]of Object.entries(b.hits))<span class="cstat-no" title="statement not covered" >if(t(p))<span class="cstat-no" title="statement not covered" >return{object:p,position:parseInt(f,10),page:o};<span class="cstat-no" title="statement not covered" >i</span></span></span>f(o++,n===!1||o&gt;=b.nbPages)<span class="cstat-no" title="statement not covered" >throw ut();<span class="cstat-no" title="statement not covered" >r</span></span>eturn d()}</span>);<span class="cstat-no" title="statement not covered" ></span></span>return d()}</span>,</span>ds=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:l.encode("1/indexes/%s/%s",e.indexName,t)},r),</span></span>ps=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >for(let[r,s]of Object.entries(e.hits))<span class="cstat-no" title="statement not covered" >if(s.objectID===t)<span class="cstat-no" title="statement not covered" >return parseInt(r,10);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn-1}</span>,</span>ms=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let o=<span class="cstat-no" title="statement not covered" >r||{},</span>{attributesToRetrieve:s}=<span class="cstat-no" title="statement not covered" >o,</span>n=<span class="cstat-no" title="statement not covered" >R(o,["attributesToRetrieve"]),</span>a=<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >u({indexName:e.indexName,objectID:d},s?{attributesToRetrieve:s}:{}))</span>;<span class="cstat-no" title="statement not covered" ></span>return e.transporter.read({method:m.MethodEnum.Post,path:"1/indexes/*/objects",data:{requests:a}},n)}</span>,</span>hs=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:l.encode("1/indexes/%s/rules/%s",e.indexName,t)},r),</span></span>gt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:l.encode("1/indexes/%s/settings",e.indexName),data:{getVersion:2}},t),</span></span>ys=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:l.encode("1/indexes/%s/synonyms/%s",e.indexName,t)},r),</span></span>bt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Get,path:l.encode("1/indexes/%s/task/%s",e.indexName,t.toString())},r),</span></span>gs=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >l.createWaitablePromise(Pt(e)([t],r).then(<span class="fstat-no" title="function not covered" >s=</span>&gt;(<span class="cstat-no" title="statement not covered" >{objectID:s.objectIDs[0],taskID:s.taskIDs[0]})</span>),<span class="fstat-no" title="function not covered" >(s</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(s.taskID,n))</span>,</span></span>Pt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let o=<span class="cstat-no" title="statement not covered" >r||{},</span>{createIfNotExists:s}=<span class="cstat-no" title="statement not covered" >o,</span>n=<span class="cstat-no" title="statement not covered" >R(o,["createIfNotExists"]),</span>a=<span class="cstat-no" title="statement not covered" >s?k.PartialUpdateObject:k.PartialUpdateObjectNoCreate;<span class="cstat-no" title="statement not covered" ></span>return te(e)(t,a,n)}</span>,</span>fs=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let O=<span class="cstat-no" title="statement not covered" >r||{},</span>{safe:s,autoGenerateObjectIDIfNotExist:n,batchSize:a}=<span class="cstat-no" title="statement not covered" >O,</span>o=<span class="cstat-no" title="statement not covered" >R(O,["safe","autoGenerateObjectIDIfNotExist","batchSize"]),</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(P</span>,x,v,j)=&gt;<span class="cstat-no" title="statement not covered" >l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/operation",P),data:{operation:v,destination:x}},j),<span class="fstat-no" title="function not covered" >(T</span>,V)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(T.taskID,V))</span>,</span></span>y=<span class="cstat-no" title="statement not covered" >Math.random().toString(36).substring(7),</span>b=<span class="cstat-no" title="statement not covered" >`${e.indexName}_tmp_${y}`,</span>f=<span class="cstat-no" title="statement not covered" >he({appId:e.appId,transporter:e.transporter,indexName:b}),</span>p=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >d(e.indexName,b,"copy",g(u({},o),{scope:["settings","synonyms","rules"]}));<span class="cstat-no" title="statement not covered" ></span>p.push(h);l</span>et S=<span class="cstat-no" title="statement not covered" >(s?h.wait(o):h).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let P=<span class="cstat-no" title="statement not covered" >f(t,g(u({},o),{autoGenerateObjectIDIfNotExist:n,batchSize:a}));<span class="cstat-no" title="statement not covered" ></span>return p.push(P),s?P.wait(o):P}</span>).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let P=<span class="cstat-no" title="statement not covered" >d(b,e.indexName,"move",o);<span class="cstat-no" title="statement not covered" ></span>return p.push(P),s?P.wait(o):P}</span>).then(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.all(p))</span>.then(<span class="fstat-no" title="function not covered" >([</span>P,x,v])=&gt;(<span class="cstat-no" title="statement not covered" >{objectIDs:x.objectIDs,taskIDs:[P.taskID,...x.taskIDs,v.taskID]})</span>);<span class="cstat-no" title="statement not covered" ></span>return l.createWaitablePromise(S,<span class="fstat-no" title="function not covered" >(P</span>,x)=&gt;<span class="cstat-no" title="statement not covered" >Promise.all(p.map(<span class="fstat-no" title="function not covered" >v=</span>&gt;<span class="cstat-no" title="statement not covered" >v.wait(x))</span>))</span>}</span>,</span>bs=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >ye(e)(t,g(u({},r),{clearExistingRules:!0})),</span></span>Ps=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >ge(e)(t,g(u({},r),{replaceExistingSynonyms:!0})),</span></span>js=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >l.createWaitablePromise(he(e)([t],r).then(<span class="fstat-no" title="function not covered" >s=</span>&gt;(<span class="cstat-no" title="statement not covered" >{objectID:s.objectIDs[0],taskID:s.taskIDs[0]})</span>),<span class="fstat-no" title="function not covered" >(s</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(s.taskID,n))</span>,</span></span>he=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let o=<span class="cstat-no" title="statement not covered" >r||{},</span>{autoGenerateObjectIDIfNotExist:s}=<span class="cstat-no" title="statement not covered" >o,</span>n=<span class="cstat-no" title="statement not covered" >R(o,["autoGenerateObjectIDIfNotExist"]),</span>a=<span class="cstat-no" title="statement not covered" >s?k.AddObject:k.UpdateObject;<span class="cstat-no" title="statement not covered" ></span>if(a===k.UpdateObject){<span class="cstat-no" title="statement not covered" >for(let d of t)<span class="cstat-no" title="statement not covered" >if(d.objectID===void 0)<span class="cstat-no" title="statement not covered" >return l.createWaitablePromise(Promise.reject(ct()))}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn te(e)(t,a,n)}</span>,</span>Os=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >ye(e)([t],r),</span></span>ye=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let d=<span class="cstat-no" title="statement not covered" >r||{},</span>{forwardToReplicas:s,clearExistingRules:n}=<span class="cstat-no" title="statement not covered" >d,</span>a=<span class="cstat-no" title="statement not covered" >R(d,["forwardToReplicas","clearExistingRules"]),</span>o=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(a);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(o.queryParameters.forwardToReplicas=1),n&amp;&amp;(o.queryParameters.clearExistingRules=1),l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/rules/batch",e.indexName),data:t},o),<span class="fstat-no" title="function not covered" >(y</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(y.taskID,b))</span>}</span>,</span>Is=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >ge(e)([t],r),</span></span>ge=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let d=<span class="cstat-no" title="statement not covered" >r||{},</span>{forwardToReplicas:s,replaceExistingSynonyms:n}=<span class="cstat-no" title="statement not covered" >d,</span>a=<span class="cstat-no" title="statement not covered" >R(d,["forwardToReplicas","replaceExistingSynonyms"]),</span>o=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(a);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(o.queryParameters.forwardToReplicas=1),n&amp;&amp;(o.queryParameters.replaceExistingSynonyms=1),l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/synonyms/batch",e.indexName),data:t},o),<span class="fstat-no" title="function not covered" >(y</span>,b)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(y.taskID,b))</span>}</span>,</span>ft=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/query",e.indexName),data:{query:t},cacheable:!0},r),</span></span>dt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r,s)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/facets/%s/query",e.indexName,t),data:{facetQuery:r},cacheable:!0},s),</span></span>mt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/rules/search",e.indexName),data:{query:t}},r),</span></span>ht=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >e.transporter.read({method:m.MethodEnum.Post,path:l.encode("1/indexes/%s/synonyms/search",e.indexName),data:{query:t}},r),</span></span>As=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let o=<span class="cstat-no" title="statement not covered" >r||{},</span>{forwardToReplicas:s}=<span class="cstat-no" title="statement not covered" >o,</span>n=<span class="cstat-no" title="statement not covered" >R(o,["forwardToReplicas"]),</span>a=<span class="cstat-no" title="statement not covered" >q.createMappedRequestOptions(n);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(a.queryParameters.forwardToReplicas=1),l.createWaitablePromise(e.transporter.write({method:m.MethodEnum.Put,path:l.encode("1/indexes/%s/settings",e.indexName),data:t},a),<span class="fstat-no" title="function not covered" >(d</span>,y)=&gt;<span class="cstat-no" title="statement not covered" >D(e)(d.taskID,y))</span>}</span>,</span>D=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;<span class="cstat-no" title="statement not covered" >l.createRetryablePromise(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >bt(e)(t,r).then(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n.status!=="published"?s():void 0)</span>)</span>,</span></span>Ss={AddObject:"addObject",Analytics:"analytics",Browser:"browse",DeleteIndex:"deleteIndex",DeleteObject:"deleteObject",EditSettings:"editSettings",ListIndexes:"listIndexes",Logs:"logs",Recommendation:"recommendation",Search:"search",SeeUnretrievableAttributes:"seeUnretrievableAttributes",Settings:"settings",Usage:"usage"},k={AddObject:"addObject",UpdateObject:"updateObject",PartialUpdateObject:"partialUpdateObject",PartialUpdateObjectNoCreate:"partialUpdateObjectNoCreate",DeleteObject:"deleteObject"},ee={Settings:"settings",Synonyms:"synonyms",Rules:"rules"},Ds={None:"none",StopIfEnoughMatches:"stopIfEnoughMatches"},Rs={Synonym:"synonym",OneWaySynonym:"oneWaySynonym",AltCorrection1:"altCorrection1",AltCorrection2:"altCorrection2",Placeholder:"placeholder"};i.ApiKeyACLEnum=Ss;i.BatchActionEnum=k;i.ScopeEnum=ee;i.StrategyEnum=Ds;i.SynonymEnum=Rs;i.addApiKey=Rr;i.assignUserID=vr;i.assignUserIDs=xr;i.batch=pt;i.browseObjects=Yr;i.browseRules=Zr;i.browseSynonyms=es;i.chunkedBatch=te;i.clearObjects=ts;i.clearRules=rs;i.clearSynonyms=ss;i.copyIndex=Z;i.copyRules=qr;i.copySettings=Er;i.copySynonyms=Tr;i.createBrowsablePromise=Y;i.createMissingObjectIDError=ct;i.createObjectNotFoundError=ut;i.createSearchClient=Dr;i.createValidUntilNotFoundError=lt;i.deleteApiKey=Mr;i.deleteBy=ns;i.deleteIndex=as;i.deleteObject=os;i.deleteObjects=yt;i.deleteRule=is;i.deleteSynonym=cs;i.exists=us;i.findObject=ls;i.generateSecuredApiKey=wr;i.getApiKey=$;i.getLogs=kr;i.getObject=ds;i.getObjectPosition=ps;i.getObjects=ms;i.getRule=hs;i.getSecuredApiKeyRemainingValidity=Cr;i.getSettings=gt;i.getSynonym=ys;i.getTask=bt;i.getTopUserIDs=Ur;i.getUserID=Nr;i.hasPendingMappings=Wr;i.initIndex=L;i.listApiKeys=Hr;i.listClusters=_r;i.listIndices=Fr;i.listUserIDs=Br;i.moveIndex=Kr;i.multipleBatch=zr;i.multipleGetObjects=Gr;i.multipleQueries=$r;i.multipleSearchForFacetValues=Lr;i.partialUpdateObject=gs;i.partialUpdateObjects=Pt;i.removeUserID=Vr;i.replaceAllObjects=fs;i.replaceAllRules=bs;i.replaceAllSynonyms=Ps;i.restoreApiKey=Qr;i.saveObject=js;i.saveObjects=he;i.saveRule=Os;i.saveRules=ye;i.saveSynonym=Is;i.saveSynonyms=ge;i.search=ft;i.searchForFacetValues=dt;i.searchRules=mt;i.searchSynonyms=ht;i.searchUserIDs=Jr;i.setSettings=As;i.updateApiKey=Xr;i.waitTask=D});var It=I((on,Ot)=&gt;{Ot.exports=jt()});var At=I(re=&gt;{"use strict";Object.defineProperty(re,"__esModule",{value:!0});function <span class="fstat-no" title="function not covered" >vs(</span>){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >de</span>bug(e,t){<span class="cstat-no" title="statement not covered" >return Promise.resolve()}</span>,<span class="fstat-no" title="function not covered" >in</span>fo(e,t){<span class="cstat-no" title="statement not covered" >return Promise.resolve()}</span>,<span class="fstat-no" title="function not covered" >er</span>ror(e,t){<span class="cstat-no" title="statement not covered" >return Promise.resolve()}</span>}}</span>var xs={Debug:1,Info:2,Error:3};re.LogLevelEnum=xs;re.createNullLogger=vs});var Dt=I((un,St)=&gt;{St.exports=At()});var xt=I(fe=&gt;{"use strict";Object.defineProperty(fe,"__esModule",{value:!0});var Rt=require("http"),vt=require("https"),qs=require("url");function <span class="fstat-no" title="function not covered" >Es(</span>){let e=<span class="cstat-no" title="statement not covered" >{keepAlive:!0},</span>t=<span class="cstat-no" title="statement not covered" >new Rt.Agent(e),</span>r=<span class="cstat-no" title="statement not covered" >new vt.Agent(e);<span class="cstat-no" title="statement not covered" ></span>return{<span class="fstat-no" title="function not covered" >se</span>nd(s){<span class="cstat-no" title="statement not covered" >return new Promise(<span class="fstat-no" title="function not covered" >n=</span>&gt;{let a=<span class="cstat-no" title="statement not covered" >qs.parse(s.url),</span>o=<span class="cstat-no" title="statement not covered" >a.query===null?a.pathname:`${a.pathname}?${a.query}`,</span>d=<span class="cstat-no" title="statement not covered" >u({agent:a.protocol==="https:"?r:t,hostname:a.hostname,path:o,method:s.method,headers:s.headers},a.port!==void 0?{port:a.port||""}:{}),</span>y=<span class="cstat-no" title="statement not covered" >(a.protocol==="https:"?vt:Rt).request(d,<span class="fstat-no" title="function not covered" >h=</span>&gt;{let S=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>h.on("data",<span class="fstat-no" title="function not covered" >O=</span>&gt;<span class="cstat-no" title="statement not covered" >S+=O)</span>,h.on("end",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >clearTimeout(f),clearTimeout(p),n({status:h.statusCode||0,content:S,isTimedOut:!1})}</span>)}</span>),</span>b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(h</span>,S)=&gt;<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >y.abort(),n({status:0,content:S,isTimedOut:!0})}</span>,h*1e3),</span></span>f=<span class="cstat-no" title="statement not covered" >b(s.connectTimeout,"Connection timeout"),</span>p;<span class="cstat-no" title="statement not covered" >y.on("error",<span class="fstat-no" title="function not covered" >h=</span>&gt;{<span class="cstat-no" title="statement not covered" >clearTimeout(f),clearTimeout(p),n({status:0,content:h.message,isTimedOut:!1})}</span>),y.once("response",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >clearTimeout(f),p=b(s.responseTimeout,"Socket timeout")}</span>),s.data!==void 0&amp;&amp;y.write(s.data),y.end()}</span>)}</span>,<span class="fstat-no" title="function not covered" >de</span>stroy(){<span class="cstat-no" title="statement not covered" >return t.destroy(),r.destroy(),Promise.resolve()}</span>}}</span>fe.createNodeHttpRequester=Es});var Et=I((dn,qt)=&gt;{qt.exports=xt()});var kt=I((pn,Tt)=&gt;{"use strict";var Mt=Ee(),Ts=we(),W=st(),be=F(),Pe=it(),c=It(),Ms=Dt(),ws=Et(),ks=K();function <span class="fstat-no" title="function not covered" >wt(</span>e,t,r){let s=<span class="cstat-no" title="statement not covered" >{appId:e,apiKey:t,timeouts:{connect:2,read:5,write:30},requester:ws.createNodeHttpRequester(),logger:Ms.createNullLogger(),responsesCache:Mt.createNullCache(),requestsCache:Mt.createNullCache(),hostsCache:Ts.createInMemoryCache(),userAgent:ks.createUserAgent(be.version).add({segment:"Node.js",version:process.versions.node})};<span class="cstat-no" title="statement not covered" ></span>return c.createSearchClient(g(u(u({},s),r),{methods:{search:c.multipleQueries,searchForFacetValues:c.multipleSearchForFacetValues,multipleBatch:c.multipleBatch,multipleGetObjects:c.multipleGetObjects,multipleQueries:c.multipleQueries,copyIndex:c.copyIndex,copySettings:c.copySettings,copyRules:c.copyRules,copySynonyms:c.copySynonyms,moveIndex:c.moveIndex,listIndices:c.listIndices,getLogs:c.getLogs,listClusters:c.listClusters,multipleSearchForFacetValues:c.multipleSearchForFacetValues,getApiKey:c.getApiKey,addApiKey:c.addApiKey,listApiKeys:c.listApiKeys,updateApiKey:c.updateApiKey,deleteApiKey:c.deleteApiKey,restoreApiKey:c.restoreApiKey,assignUserID:c.assignUserID,assignUserIDs:c.assignUserIDs,getUserID:c.getUserID,searchUserIDs:c.searchUserIDs,listUserIDs:c.listUserIDs,getTopUserIDs:c.getTopUserIDs,removeUserID:c.removeUserID,hasPendingMappings:c.hasPendingMappings,generateSecuredApiKey:c.generateSecuredApiKey,getSecuredApiKeyRemainingValidity:c.getSecuredApiKeyRemainingValidity,destroy:be.destroy,initIndex:<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >a=</span>&gt;<span class="cstat-no" title="statement not covered" >c.initIndex(n)(a,{methods:{batch:c.batch,delete:c.deleteIndex,getObject:c.getObject,getObjects:c.getObjects,saveObject:c.saveObject,saveObjects:c.saveObjects,search:c.search,searchForFacetValues:c.searchForFacetValues,waitTask:c.waitTask,setSettings:c.setSettings,getSettings:c.getSettings,partialUpdateObject:c.partialUpdateObject,partialUpdateObjects:c.partialUpdateObjects,deleteObject:c.deleteObject,deleteObjects:c.deleteObjects,deleteBy:c.deleteBy,clearObjects:c.clearObjects,browseObjects:c.browseObjects,getObjectPosition:c.getObjectPosition,findObject:c.findObject,exists:c.exists,saveSynonym:c.saveSynonym,saveSynonyms:c.saveSynonyms,getSynonym:c.getSynonym,searchSynonyms:c.searchSynonyms,browseSynonyms:c.browseSynonyms,deleteSynonym:c.deleteSynonym,clearSynonyms:c.clearSynonyms,replaceAllObjects:c.replaceAllObjects,replaceAllSynonyms:c.replaceAllSynonyms,searchRules:c.searchRules,getRule:c.getRule,deleteRule:c.deleteRule,saveRule:c.saveRule,saveRules:c.saveRules,replaceAllRules:c.replaceAllRules,browseRules:c.browseRules,clearRules:c.clearRules}}),</span></span>initAnalytics:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >W.createAnalyticsClient(g(u(u({},s),n),{methods:{addABTest:W.addABTest,getABTest:W.getABTest,getABTests:W.getABTests,stopABTest:W.stopABTest,deleteABTest:W.deleteABTest}})),</span></span>initRecommendation:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Pe.createRecommendationClient(g(u(u({},s),n),{methods:{getPersonalizationStrategy:Pe.getPersonalizationStrategy,setPersonalizationStrategy:Pe.setPersonalizationStrategy}}))}</span></span>}))}</span>wt.version=be.version;Tt.exports=wt});var Ut=I((mn,je)=&gt;{var Ct=kt();je.exports=Ct;je.exports.default=Ct});var Ws={};Vt(Ws,{default:()=&gt;Ks});var Oe=C(require("@yarnpkg/core")),E=C(require("@yarnpkg/core")),Ie=C(require("@yarnpkg/plugin-essentials")),Ht=C(require("semver"));var se=C(require("@yarnpkg/core")),Nt=C(Ut()),Cs="e8e1bd300d860104bb8c58453ffa1eb4",Us="OFCNCOG2CU",Wt=<span class="fstat-no" title="function not covered" >as</span>ync(e,t)=&gt;{var a;let r=<span class="cstat-no" title="statement not covered" >se.structUtils.stringifyIdent(e),</span>n=<span class="cstat-no" title="statement not covered" >Ns(t).initIndex("npm-search");<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return((a=(await n.getObject(r,{attributesToRetrieve:["types"]})).types)==null?void 0:a.ts)==="definitely-typed"}</span>catch(o){<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>,Ns=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >(0,Nt.default)(Us,Cs,{requester:{<span class="fstat-no" title="function not covered" >as</span>ync send(r){<span class="cstat-no" title="statement not covered" >try{let s=<span class="cstat-no" title="statement not covered" >await se.httpUtils.request(r.url,r.data||null,{configuration:e,headers:r.headers});<span class="cstat-no" title="statement not covered" ></span>return{content:s.body,isTimedOut:!1,status:s.statusCode}}</span>catch(s){<span class="cstat-no" title="statement not covered" >return{content:s.response.body,isTimedOut:!1,status:s.response.statusCode}}</span>}</span>}});</span>var _t=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.scope?`${e.scope}__${e.name}`:`${e.name}`,</span>Hs=<span class="fstat-no" title="function not covered" >as</span>ync(e,t,r,s)=&gt;{<span class="cstat-no" title="statement not covered" >if(r.scope==="types")<span class="cstat-no" title="statement not covered" >return;l</span></span>et{project:n}=<span class="cstat-no" title="statement not covered" >e,</span>{configuration:a}=<span class="cstat-no" title="statement not covered" >n,</span>o=<span class="cstat-no" title="statement not covered" >a.makeResolver(),</span>d=<span class="cstat-no" title="statement not covered" >{project:n,resolver:o,report:new E.ThrowReport};<span class="cstat-no" title="statement not covered" ></span>if(!await Wt(r,a))<span class="cstat-no" title="statement not covered" >return;l</span></span>et b=<span class="cstat-no" title="statement not covered" >_t(r),</span>f=<span class="cstat-no" title="statement not covered" >E.structUtils.parseRange(r.range).selector;<span class="cstat-no" title="statement not covered" ></span>if(!E.semverUtils.validRange(f)){let P=<span class="cstat-no" title="statement not covered" >await o.getCandidates(r,new Map,d);<span class="cstat-no" title="statement not covered" ></span>f=E.structUtils.parseRange(P[0].reference).selector}</span>l</span>et p=<span class="cstat-no" title="statement not covered" >Ht.default.coerce(f);<span class="cstat-no" title="statement not covered" ></span>if(p===null)<span class="cstat-no" title="statement not covered" >return;l</span></span>et h=<span class="cstat-no" title="statement not covered" >`${Ie.suggestUtils.Modifier.CARET}${p.major}`,</span>S=<span class="cstat-no" title="statement not covered" >E.structUtils.makeDescriptor(E.structUtils.makeIdent("types",b),h),</span>O=<span class="cstat-no" title="statement not covered" >E.miscUtils.mapAndFind(n.workspaces,<span class="fstat-no" title="function not covered" >P=</span>&gt;{var T,V;let x=<span class="cstat-no" title="statement not covered" >(T=P.manifest.dependencies.get(r.identHash))==null?void 0:T.descriptorHash,</span>v=<span class="cstat-no" title="statement not covered" >(V=P.manifest.devDependencies.get(r.identHash))==null?void 0:V.descriptorHash;<span class="cstat-no" title="statement not covered" ></span>if(x!==r.descriptorHash&amp;&amp;v!==r.descriptorHash)<span class="cstat-no" title="statement not covered" >return E.miscUtils.mapAndFind.skip;l</span></span>et j=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let Ae of Oe.Manifest.allDependencies){let Se=<span class="cstat-no" title="statement not covered" >P.manifest[Ae].get(S.identHash);<span class="cstat-no" title="statement not covered" ></span>typeof Se!="undefined"&amp;&amp;j.push([Ae,Se])}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn j.length===0?E.miscUtils.mapAndFind.skip:j}</span>);<span class="cstat-no" title="statement not covered" ></span>if(typeof O!="undefined")<span class="cstat-no" title="statement not covered" >for(let[P,x]of O)<span class="cstat-no" title="statement not covered" >e.manifest[P].set(x.identHash,x);e</span></span>lse{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >if((await o.getCandidates(S,new Map,d)).length===0)<span class="cstat-no" title="statement not covered" >return}</span></span>catch{<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ></span>e</span>.manifest[Ie.suggestUtils.Target.DEVELOPMENT].set(S.identHash,S)}</span>}</span>,_s=<span class="fstat-no" title="function not covered" >as</span>ync(e,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(r.scope==="types")<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >_t(r),</span>n=<span class="cstat-no" title="statement not covered" >E.structUtils.makeIdent("types",s);<span class="cstat-no" title="statement not covered" ></span>for(let a of Oe.Manifest.allDependencies)<span class="cstat-no" title="statement not covered" >typeof e.manifest[a].get(n.identHash)!="undefined"&amp;&amp;e.manifest[a].delete(n.identHash)}</span></span>,Fs=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >t.publishConfig&amp;&amp;t.publishConfig.typings&amp;&amp;(t.typings=t.publishConfig.typings),t.publishConfig&amp;&amp;t.publishConfig.types&amp;&amp;(t.types=t.publishConfig.types)}</span>,Bs={hooks:{afterWorkspaceDependencyAddition:Hs,afterWorkspaceDependencyRemoval:_s,beforeWorkspacePacking:Fs}},Ks=Bs;return Ws;})();
return plugin;
}
};
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-05-16T10:35:10.742Z
            </div>
        <script src="../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../sorter.js"></script>
        <script src="../../block-navigation.js"></script>
    </body>
</html>
    