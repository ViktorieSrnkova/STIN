
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for plugins/@yarnpkg/plugin-workspace-tools.cjs</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../prettify.css" />
    <link rel="stylesheet" href="../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../index.html">All files</a> / <a href="index.html">plugins/@yarnpkg</a> plugin-workspace-tools.cjs</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">17.69% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>264/1492</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">1.26% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>20/1582</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">15.88% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>34/214</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>4/4</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input oninput="onInput()" type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">1x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">668x</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">2x</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-workspace-tools",
factory: function (require) {
var plugin=(()=&gt;{var wr=Object.create,me=Object.defineProperty,Sr=Object.defineProperties,vr=Object.getOwnPropertyDescriptor,Hr=Object.getOwnPropertyDescriptors,$r=Object.getOwnPropertyNames,et=Object.getOwnPropertySymbols,kr=Object.getPrototypeOf,tt=Object.prototype.hasOwnProperty,Tr=Object.prototype.propertyIsEnumerable;var rt=(e,t,r)=&gt;t in e?<span class="branch-0 cbranch-no" title="branch not covered" >me(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):</span>e[t]=r,B=(e,t)=&gt;{for(var r in t||(<span class="branch-1 cbranch-no" title="branch not covered" >t={})</span>)tt.call(t,r)&amp;&amp;rt(e,r,t[r]);<span class="missing-if-branch" title="else path not taken" >E</span>if(et)for(var r of et(t))<span class="cstat-no" title="statement not covered" >Tr.call(t,r)&amp;&amp;rt(e,r,t[r]);r</span>eturn e},Q=(e,t)=&gt;Sr(e,Hr(t)),Lr=e=&gt;me(e,"__esModule",{value:!0});var K=(e,t)=&gt;()=&gt;(t||e((t={exports:{}}).exports,t),t.exports),Or=(e,t)=&gt;{for(var r in t)me(e,r,{get:t[r],enumerable:!0})},Nr=(e,t,r)=&gt;{<span class="missing-if-branch" title="else path not taken" >E</span>if(t&amp;&amp;typeof t=="object"||typeof t=="function")for(let n of $r(t))!tt.call(e,n)&amp;&amp;n!=="default"&amp;&amp;me(e,n,{get:()=&gt;t[n],enumerable:!(r=vr(t,n))||r.enumerable});return e},X=e=&gt;Nr(Lr(me(e!=null?wr(kr(e)):<span class="branch-1 cbranch-no" title="branch not covered" >{},</span>"default",e&amp;&amp;e.__esModule&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >"default"in e?<span class="branch-0 cbranch-no" title="branch not covered" ></span>{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.default,</span>enumerable:!0}:</span>{value:e,enumerable:!0})),e);var $e=K(te=&gt;{"use strict";te.isInteger=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof e=="number"?Number.isInteger(e):typeof e=="string"&amp;&amp;e.trim()!==""?Number.isInteger(Number(e)):!1;</span>te.find=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >e.nodes.find(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >r.type===t)</span>;</span>te.exceedsLimit=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>n)=&gt;<span class="cstat-no" title="statement not covered" >n===!1||!te.isInteger(e)||!te.isInteger(t)?!1:(Number(t)-Number(e))/Number(r)&gt;=n;</span>te.escapeNode=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >e.nodes[t];<span class="cstat-no" title="statement not covered" ></span>!n||(r&amp;&amp;n.type===r||n.type==="open"||n.type==="close")&amp;&amp;n.escaped!==!0&amp;&amp;(n.value="\\"+n.value,n.escaped=!0)}</span>;te.encloseBrace=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.type!=="brace"?!1:e.commas&gt;&gt;0+e.ranges&gt;&gt;0==0?(e.invalid=!0,!0):!1;</span>te.isInvalidBrace=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.type!=="brace"?!1:e.invalid===!0||e.dollar?!0:e.commas&gt;&gt;0+e.ranges&gt;&gt;0==0||e.open!==!0||e.close!==!0?(e.invalid=!0,!0):!1;</span>te.isOpenOrClose=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.type==="open"||e.type==="close"?!0:e.open===!0||e.close===!0;</span>te.reduce=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.reduce(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;(<span class="cstat-no" title="statement not covered" >r.type==="text"&amp;&amp;t.push(r.value),r.type==="range"&amp;&amp;(r.type="text"),t)</span>,[]);</span>te.flatten=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;{let t=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;n.length;s++){let a=<span class="cstat-no" title="statement not covered" >n[s];<span class="cstat-no" title="statement not covered" ></span>Array.isArray(a)?r(a,t):a!==void 0&amp;&amp;t.push(a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>;<span class="cstat-no" title="statement not covered" ></span>return r(e),t}</span>});var ke=K((is,at)=&gt;{"use strict";var it=$e();at.exports=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,s=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let a=<span class="cstat-no" title="statement not covered" >t.escapeInvalid&amp;&amp;it.isInvalidBrace(s),</span>i=<span class="cstat-no" title="statement not covered" >n.invalid===!0&amp;&amp;t.escapeInvalid===!0,</span>o=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(n.value)<span class="cstat-no" title="statement not covered" >return(a||i)&amp;&amp;it.isOpenOrClose(n)?"\\"+n.value:n.value;<span class="cstat-no" title="statement not covered" >i</span></span>f(n.value)<span class="cstat-no" title="statement not covered" >return n.value;<span class="cstat-no" title="statement not covered" >i</span></span>f(n.nodes)<span class="cstat-no" title="statement not covered" >for(let h of n.nodes)<span class="cstat-no" title="statement not covered" >o+=r(h);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn o}</span>;<span class="cstat-no" title="statement not covered" ></span>return r(e)}</span>});var ct=K((os,ot)=&gt;{"use strict";ot.exports=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return typeof e=="number"?e-e==0:typeof e=="string"&amp;&amp;e.trim()!==""?Number.isFinite?Number.isFinite(+e):isFinite(+e):!1}</span>});var At=K((cs,ut)=&gt;{"use strict";var lt=ct(),pe=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(lt(e)===!1)<span class="cstat-no" title="statement not covered" >throw new TypeError("toRegexRange: expected the first argument to be a number");<span class="cstat-no" title="statement not covered" >i</span></span>f(t===void 0||e===t)<span class="cstat-no" title="statement not covered" >return String(e);<span class="cstat-no" title="statement not covered" >i</span></span>f(lt(t)===!1)<span class="cstat-no" title="statement not covered" >throw new TypeError("toRegexRange: expected the second argument to be a number.");l</span></span>et n=<span class="cstat-no" title="statement not covered" >B({relaxZeros:!0},r);<span class="cstat-no" title="statement not covered" ></span>typeof n.strictZeros=="boolean"&amp;&amp;(n.relaxZeros=n.strictZeros===!1);l</span>et s=<span class="cstat-no" title="statement not covered" >String(n.relaxZeros),</span>a=<span class="cstat-no" title="statement not covered" >String(n.shorthand),</span>i=<span class="cstat-no" title="statement not covered" >String(n.capture),</span>o=<span class="cstat-no" title="statement not covered" >String(n.wrap),</span>h=<span class="cstat-no" title="statement not covered" >e+":"+t+"="+s+a+i+o;<span class="cstat-no" title="statement not covered" ></span>if(pe.cache.hasOwnProperty(h))<span class="cstat-no" title="statement not covered" >return pe.cache[h].result;l</span></span>et g=<span class="cstat-no" title="statement not covered" >Math.min(e,t),</span>f=<span class="cstat-no" title="statement not covered" >Math.max(e,t);<span class="cstat-no" title="statement not covered" ></span>if(Math.abs(g-f)===1){let R=<span class="cstat-no" title="statement not covered" >e+"|"+t;<span class="cstat-no" title="statement not covered" ></span>return n.capture?`(${R})`:n.wrap===!1?R:`(?:${R})`}</span>l</span>et A=<span class="cstat-no" title="statement not covered" >ft(e)||ft(t),</span>p=<span class="cstat-no" title="statement not covered" >{min:e,max:t,a:g,b:f},</span>k=<span class="cstat-no" title="statement not covered" >[],</span>y=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(A&amp;&amp;(p.isPadded=A,p.maxLen=String(p.max).length),g&lt;0){let R=<span class="cstat-no" title="statement not covered" >f&lt;0?Math.abs(f):1;<span class="cstat-no" title="statement not covered" ></span>y=pt(R,Math.abs(g),p,n),g=p.a=0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn f&gt;=0&amp;&amp;(k=pt(g,f,p,n)),p.negatives=y,p.positives=k,p.result=Ir(y,k,n),n.capture===!0?p.result=`(${p.result})`:n.wrap!==!1&amp;&amp;k.length+y.length&gt;1&amp;&amp;(p.result=`(?:${p.result})`),pe.cache[h]=p,p.result}</span>;function <span class="fstat-no" title="function not covered" >Ir(</span>e,t,r){let n=<span class="cstat-no" title="statement not covered" >Pe(e,t,"-",!1,r)||[],</span>s=<span class="cstat-no" title="statement not covered" >Pe(t,e,"",!1,r)||[],</span>a=<span class="cstat-no" title="statement not covered" >Pe(e,t,"-?",!0,r)||[];<span class="cstat-no" title="statement not covered" ></span>return n.concat(a).concat(s).join("|")}</span>function <span class="fstat-no" title="function not covered" >Mr(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >1,</span>s=<span class="cstat-no" title="statement not covered" >ht(e,r),</span>a=<span class="cstat-no" title="statement not covered" >new Set([t]);<span class="cstat-no" title="statement not covered" ></span>for(;e&lt;=s&amp;&amp;s&lt;=t;)<span class="cstat-no" title="statement not covered" >a.add(s),r+=1,s=ht(e,r);<span class="cstat-no" title="statement not covered" >f</span></span>or(s=dt(t+1,n)-1;e&lt;s&amp;&amp;s&lt;=t;)<span class="cstat-no" title="statement not covered" >a.add(s),n+=1,s=dt(t+1,n)-1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a=[...a],a.sort(Br),a}</span>function <span class="fstat-no" title="function not covered" >Ur(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(e===t)<span class="cstat-no" title="statement not covered" >return{pattern:e,count:[],digits:0};l</span></span>et n=<span class="cstat-no" title="statement not covered" >Pr(e,t),</span>s=<span class="cstat-no" title="statement not covered" >n.length,</span>a=<span class="cstat-no" title="statement not covered" >"",</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s;o++){let[h,g]=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>h===g?a+=h:h!=="0"||g!=="9"?a+=Dr(h,g,r):i++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i&amp;&amp;(a+=r.shorthand===!0?"\\d":"[0-9]"),{pattern:a,count:[i],digits:s}}</span>function <span class="fstat-no" title="function not covered" >pt(</span>e,t,r,n){let s=<span class="cstat-no" title="statement not covered" >Mr(e,t),</span>a=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >e,</span>o;<span class="cstat-no" title="statement not covered" >for(let h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;s.length;h++){let g=<span class="cstat-no" title="statement not covered" >s[h],</span>f=<span class="cstat-no" title="statement not covered" >Ur(String(i),String(g),n),</span>A=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(!r.isPadded&amp;&amp;o&amp;&amp;o.pattern===f.pattern){<span class="cstat-no" title="statement not covered" >o.count.length&gt;1&amp;&amp;o.count.pop(),o.count.push(f.count[0]),o.string=o.pattern+gt(o.count),i=g+1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>r</span>.isPadded&amp;&amp;(A=Gr(g,r,n)),f.string=A+f.pattern+gt(f.count),a.push(f),i=g+1,o=f}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>function <span class="fstat-no" title="function not covered" >Pe(</span>e,t,r,n,s){let a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let i of e){let{string:o}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>!n&amp;&amp;!mt(t,"string",o)&amp;&amp;a.push(r+o),n&amp;&amp;mt(t,"string",o)&amp;&amp;a.push(r+o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>function <span class="fstat-no" title="function not covered" >Pr(</span>e,t){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >r.push([e[n],t[n]]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Br(</span>e,t){<span class="cstat-no" title="statement not covered" >return e&gt;t?1:t&gt;e?-1:0}</span>function <span class="fstat-no" title="function not covered" >mt(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return e.some(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >n[t]===r)</span>}</span>function <span class="fstat-no" title="function not covered" >ht(</span>e,t){<span class="cstat-no" title="statement not covered" >return Number(String(e).slice(0,-t)+"9".repeat(t))}</span>function <span class="fstat-no" title="function not covered" >dt(</span>e,t){<span class="cstat-no" title="statement not covered" >return e-e%Math.pow(10,t)}</span>function <span class="fstat-no" title="function not covered" >gt(</span>e){let[t=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >""]</span>=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return r||t&gt;1?`{${t+(r?","+r:"")}}`:""}</span>function <span class="fstat-no" title="function not covered" >Dr(</span>e,t,r){<span class="cstat-no" title="statement not covered" >return`[${e}${t-e==1?"":"-"}${t}]`}</span>function <span class="fstat-no" title="function not covered" >ft(</span>e){<span class="cstat-no" title="statement not covered" >return/^-?(0+)\d/.test(e)}</span>function <span class="fstat-no" title="function not covered" >Gr(</span>e,t,r){<span class="cstat-no" title="statement not covered" >if(!t.isPadded)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et n=<span class="cstat-no" title="statement not covered" >Math.abs(t.maxLen-String(e).length),</span>s=<span class="cstat-no" title="statement not covered" >r.relaxZeros!==!1;<span class="cstat-no" title="statement not covered" ></span>switch(n){case 0:<span class="cstat-no" title="statement not covered" >return"";c</span>ase 1:<span class="cstat-no" title="statement not covered" >return s?"0?":"0";c</span>ase 2:<span class="cstat-no" title="statement not covered" >return s?"0{0,2}":"00";d</span>efault:<span class="cstat-no" title="statement not covered" >return s?`0{0,${n}}`:`0{${n}}`}</span>}</span>pe.cache={};pe.clearCache=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >pe.cache={};</span>ut.exports=pe});var Ge=K((us,Rt)=&gt;{"use strict";var qr=require("util"),yt=At(),bt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e!==null&amp;&amp;typeof e=="object"&amp;&amp;!Array.isArray(e),</span>Kr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >e===!0?Number(t):String(t),</span></span>De=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >typeof e=="number"||typeof e=="string"&amp;&amp;e!=="",</span>Re=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Number.isInteger(+e),</span>Ue=<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >`${e}`,</span>r=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>if(t[0]==="-"&amp;&amp;(t=t.slice(1)),t==="0")<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(;t[++r]==="0";);<span class="cstat-no" title="statement not covered" >r</span>eturn r&gt;0}</span>,Wr=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >typeof e=="string"||typeof t=="string"?!0:r.stringify===!0,</span>jr=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(t&gt;0){let n=<span class="cstat-no" title="statement not covered" >e[0]==="-"?"-":"";<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(e=e.slice(1)),e=n+e.padStart(n?t-1:t,"0")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r===!1?String(e):e}</span>,_t=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >e[0]==="-"?"-":"";<span class="cstat-no" title="statement not covered" ></span>for(r&amp;&amp;(e=e.slice(1),t--);e.length&lt;t;)<span class="cstat-no" title="statement not covered" >e="0"+e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r?"-"+e:e}</span>,Fr=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >e.negatives.sort(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i&lt;o?-1:i&gt;o?1:0)</span>,e.positives.sort(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i&lt;o?-1:i&gt;o?1:0)</span>;l</span>et r=<span class="cstat-no" title="statement not covered" >t.capture?"":"?:",</span>n=<span class="cstat-no" title="statement not covered" >"",</span>s=<span class="cstat-no" title="statement not covered" >"",</span>a;<span class="cstat-no" title="statement not covered" >return e.positives.length&amp;&amp;(n=e.positives.join("|")),e.negatives.length&amp;&amp;(s=`-(${r}${e.negatives.join("|")})`),n&amp;&amp;s?a=`${n}|${s}`:a=n||s,t.wrap?`(${r}${a})`:a}</span>,Et=<span class="fstat-no" title="function not covered" >(e</span>,t,r,n)=&gt;{<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >return yt(e,t,B({wrap:!1},n));l</span></span>et s=<span class="cstat-no" title="statement not covered" >String.fromCharCode(e);<span class="cstat-no" title="statement not covered" ></span>if(e===t)<span class="cstat-no" title="statement not covered" >return s;l</span></span>et a=<span class="cstat-no" title="statement not covered" >String.fromCharCode(t);<span class="cstat-no" title="statement not covered" ></span>return`[${s}-${a}]`}</span>,xt=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(Array.isArray(e)){let n=<span class="cstat-no" title="statement not covered" >r.wrap===!0,</span>s=<span class="cstat-no" title="statement not covered" >r.capture?"":"?:";<span class="cstat-no" title="statement not covered" ></span>return n?`(${s}${e.join("|")})`:e.join("|")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn yt(e,t,r)}</span>,Ct=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >new RangeError("Invalid range arguments: "+qr.inspect(...e)),</span>wt=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(r.strictRanges===!0)<span class="cstat-no" title="statement not covered" >throw Ct([e,t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[]}</span>,Qr=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(t.strictRanges===!0)<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected step "${e}" to be a number`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[]}</span>,Xr=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let s=<span class="cstat-no" title="statement not covered" >Number(e),</span>a=<span class="cstat-no" title="statement not covered" >Number(t);<span class="cstat-no" title="statement not covered" ></span>if(!Number.isInteger(s)||!Number.isInteger(a)){<span class="cstat-no" title="statement not covered" >if(n.strictRanges===!0)<span class="cstat-no" title="statement not covered" >throw Ct([e,t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[]}<span class="cstat-no" title="statement not covered" ></span>s</span>===0&amp;&amp;(s=0),a===0&amp;&amp;(a=0);l</span>et i=<span class="cstat-no" title="statement not covered" >s&gt;a,</span>o=<span class="cstat-no" title="statement not covered" >String(e),</span>h=<span class="cstat-no" title="statement not covered" >String(t),</span>g=<span class="cstat-no" title="statement not covered" >String(r);<span class="cstat-no" title="statement not covered" ></span>r=Math.max(Math.abs(r),1);l</span>et f=<span class="cstat-no" title="statement not covered" >Ue(o)||Ue(h)||Ue(g),</span>A=<span class="cstat-no" title="statement not covered" >f?Math.max(o.length,h.length,g.length):0,</span>p=<span class="cstat-no" title="statement not covered" >f===!1&amp;&amp;Wr(e,t,n)===!1,</span>k=<span class="cstat-no" title="statement not covered" >n.transform||Kr(p);<span class="cstat-no" title="statement not covered" ></span>if(n.toRegex&amp;&amp;r===1)<span class="cstat-no" title="statement not covered" >return Et(_t(e,A),_t(t,A),!0,n);l</span></span>et y=<span class="cstat-no" title="statement not covered" >{negatives:[],positives:[]},</span>R=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >T=</span>&gt;<span class="cstat-no" title="statement not covered" >y[T&lt;0?"negatives":"positives"].push(Math.abs(T)),</span></span>_=<span class="cstat-no" title="statement not covered" >[],</span>x=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;i?s&gt;=a:s&lt;=a;)<span class="cstat-no" title="statement not covered" >n.toRegex===!0&amp;&amp;r&gt;1?R(s):_.push(jr(k(s,x),A,p)),s=i?s-r:s+r,x++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.toRegex===!0?r&gt;1?Fr(y,n):xt(_,null,B({wrap:!1},n)):_}</span>,Zr=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!Re(e)&amp;&amp;e.length&gt;1||!Re(t)&amp;&amp;t.length&gt;1)<span class="cstat-no" title="statement not covered" >return wt(e,t,n);l</span></span>et s=<span class="cstat-no" title="statement not covered" >n.transform||(<span class="fstat-no" title="function not covered" >p=</span>&gt;<span class="cstat-no" title="statement not covered" >String.fromCharCode(p))</span>,</span>a=<span class="cstat-no" title="statement not covered" >`${e}`.charCodeAt(0),</span>i=<span class="cstat-no" title="statement not covered" >`${t}`.charCodeAt(0),</span>o=<span class="cstat-no" title="statement not covered" >a&gt;i,</span>h=<span class="cstat-no" title="statement not covered" >Math.min(a,i),</span>g=<span class="cstat-no" title="statement not covered" >Math.max(a,i);<span class="cstat-no" title="statement not covered" ></span>if(n.toRegex&amp;&amp;r===1)<span class="cstat-no" title="statement not covered" >return Et(h,g,!1,n);l</span></span>et f=<span class="cstat-no" title="statement not covered" >[],</span>A=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;o?a&gt;=i:a&lt;=i;)<span class="cstat-no" title="statement not covered" >f.push(s(a,A)),a=o?a-r:a+r,A++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.toRegex===!0?xt(f,null,{wrap:!1,options:n}):f}</span>,Te=<span class="fstat-no" title="function not covered" >(e</span>,t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(t==null&amp;&amp;De(e))<span class="cstat-no" title="statement not covered" >return[e];<span class="cstat-no" title="statement not covered" >i</span></span>f(!De(e)||!De(t))<span class="cstat-no" title="statement not covered" >return wt(e,t,n);<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof r=="function")<span class="cstat-no" title="statement not covered" >return Te(e,t,1,{transform:r});<span class="cstat-no" title="statement not covered" >i</span></span>f(bt(r))<span class="cstat-no" title="statement not covered" >return Te(e,t,0,r);l</span></span>et s=<span class="cstat-no" title="statement not covered" >B({},n);<span class="cstat-no" title="statement not covered" ></span>return s.capture===!0&amp;&amp;(s.wrap=!0),r=r||s.step||1,Re(r)?Re(e)&amp;&amp;Re(t)?Xr(e,t,r,s):Zr(e,t,Math.max(Math.abs(r),1),s):r!=null&amp;&amp;!bt(r)?Qr(r,s):Te(e,t,1,r)}</span>;Rt.exports=Te});var Ht=K((ls,St)=&gt;{"use strict";var Yr=Ge(),vt=$e(),zr=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,s=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let a=<span class="cstat-no" title="statement not covered" >vt.isInvalidBrace(s),</span>i=<span class="cstat-no" title="statement not covered" >n.invalid===!0&amp;&amp;t.escapeInvalid===!0,</span>o=<span class="cstat-no" title="statement not covered" >a===!0||i===!0,</span>h=<span class="cstat-no" title="statement not covered" >t.escapeInvalid===!0?"\\":"",</span>g=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>if(n.isOpen===!0||n.isClose===!0)<span class="cstat-no" title="statement not covered" >return h+n.value;<span class="cstat-no" title="statement not covered" >i</span></span>f(n.type==="open")<span class="cstat-no" title="statement not covered" >return o?h+n.value:"(";<span class="cstat-no" title="statement not covered" >i</span></span>f(n.type==="close")<span class="cstat-no" title="statement not covered" >return o?h+n.value:")";<span class="cstat-no" title="statement not covered" >i</span></span>f(n.type==="comma")<span class="cstat-no" title="statement not covered" >return n.prev.type==="comma"?"":o?n.value:"|";<span class="cstat-no" title="statement not covered" >i</span></span>f(n.value)<span class="cstat-no" title="statement not covered" >return n.value;<span class="cstat-no" title="statement not covered" >i</span></span>f(n.nodes&amp;&amp;n.ranges&gt;0){let f=<span class="cstat-no" title="statement not covered" >vt.reduce(n.nodes),</span>A=<span class="cstat-no" title="statement not covered" >Yr(...f,Q(B({},t),{wrap:!1,toRegex:!0}));<span class="cstat-no" title="statement not covered" ></span>if(A.length!==0)<span class="cstat-no" title="statement not covered" >return f.length&gt;1&amp;&amp;A.length&gt;1?`(${A})`:A}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(n.nodes)<span class="cstat-no" title="statement not covered" >for(let f of n.nodes)<span class="cstat-no" title="statement not covered" >g+=r(f,n);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn g}</span>;<span class="cstat-no" title="statement not covered" ></span>return r(e)}</span>;St.exports=zr});var Tt=K((ps,$t)=&gt;{"use strict";var Vr=Ge(),kt=ke(),he=$e(),fe=<span class="fstat-no" title="function not covered" >(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e=[].concat(e),t=[].concat(t),!t.length)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(!e.length)<span class="cstat-no" title="statement not covered" >return r?he.flatten(t).map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >`{${s}}`)</span>:t;<span class="cstat-no" title="statement not covered" >f</span></span>or(let s of e)<span class="cstat-no" title="statement not covered" >if(Array.isArray(s))<span class="cstat-no" title="statement not covered" >for(let a of s)<span class="cstat-no" title="statement not covered" >n.push(fe(a,t,r));e</span></span>lse <span class="cstat-no" title="statement not covered" >for(let a of t)<span class="cstat-no" title="statement not covered" >r===!0&amp;&amp;typeof a=="string"&amp;&amp;(a=`{${a}}`),n.push(Array.isArray(a)?fe(s,a,r):s+a);<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn he.flatten(n)}</span>,Jr=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >t.rangeLimit===void 0?1e3:t.rangeLimit,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >s.queue=[];l</span>et i=<span class="cstat-no" title="statement not covered" >a,</span>o=<span class="cstat-no" title="statement not covered" >a.queue;<span class="cstat-no" title="statement not covered" ></span>for(;i.type!=="brace"&amp;&amp;i.type!=="root"&amp;&amp;i.parent;)<span class="cstat-no" title="statement not covered" >i=i.parent,o=i.queue;<span class="cstat-no" title="statement not covered" >i</span></span>f(s.invalid||s.dollar){<span class="cstat-no" title="statement not covered" >o.push(fe(o.pop(),kt(s,t)));<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.type==="brace"&amp;&amp;s.invalid!==!0&amp;&amp;s.nodes.length===2){<span class="cstat-no" title="statement not covered" >o.push(fe(o.pop(),["{}"]));<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s.nodes&amp;&amp;s.ranges&gt;0){let A=<span class="cstat-no" title="statement not covered" >he.reduce(s.nodes);<span class="cstat-no" title="statement not covered" ></span>if(he.exceedsLimit(...A,t.step,r))<span class="cstat-no" title="statement not covered" >throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");l</span></span>et p=<span class="cstat-no" title="statement not covered" >Vr(...A,t);<span class="cstat-no" title="statement not covered" ></span>p.length===0&amp;&amp;(p=kt(s,t)),o.push(fe(o.pop(),p)),s.nodes=[];<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>l</span>et h=<span class="cstat-no" title="statement not covered" >he.encloseBrace(s),</span>g=<span class="cstat-no" title="statement not covered" >s.queue,</span>f=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>for(;f.type!=="brace"&amp;&amp;f.type!=="root"&amp;&amp;f.parent;)<span class="cstat-no" title="statement not covered" >f=f.parent,g=f.queue;<span class="cstat-no" title="statement not covered" >f</span></span>or(let A=<span class="cstat-no" title="statement not covered" >0;</span>A&lt;s.nodes.length;A++){let p=<span class="cstat-no" title="statement not covered" >s.nodes[A];<span class="cstat-no" title="statement not covered" ></span>if(p.type==="comma"&amp;&amp;s.type==="brace"){<span class="cstat-no" title="statement not covered" >A===1&amp;&amp;g.push(""),g.push("");<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p.type==="close"){<span class="cstat-no" title="statement not covered" >o.push(fe(o.pop(),g,h));<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p.value&amp;&amp;p.type!=="open"){<span class="cstat-no" title="statement not covered" >g.push(fe(g.pop(),p.value));<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>p</span>.nodes&amp;&amp;n(p,s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn g}</span>;<span class="cstat-no" title="statement not covered" ></span>return he.flatten(n(e))}</span>;$t.exports=Jr});var Ot=K((fs,Lt)=&gt;{"use strict";Lt.exports={MAX_LENGTH:1024*64,CHAR_0:"0",CHAR_9:"9",CHAR_UPPERCASE_A:"A",CHAR_LOWERCASE_A:"a",CHAR_UPPERCASE_Z:"Z",CHAR_LOWERCASE_Z:"z",CHAR_LEFT_PARENTHESES:"(",CHAR_RIGHT_PARENTHESES:")",CHAR_ASTERISK:"*",CHAR_AMPERSAND:"&amp;",CHAR_AT:"@",CHAR_BACKSLASH:"\\",CHAR_BACKTICK:"`",CHAR_CARRIAGE_RETURN:"\r",CHAR_CIRCUMFLEX_ACCENT:"^",CHAR_COLON:":",CHAR_COMMA:",",CHAR_DOLLAR:"$",CHAR_DOT:".",CHAR_DOUBLE_QUOTE:'"',CHAR_EQUAL:"=",CHAR_EXCLAMATION_MARK:"!",CHAR_FORM_FEED:"\f",CHAR_FORWARD_SLASH:"/",CHAR_HASH:"#",CHAR_HYPHEN_MINUS:"-",CHAR_LEFT_ANGLE_BRACKET:"&lt;",CHAR_LEFT_CURLY_BRACE:"{",CHAR_LEFT_SQUARE_BRACKET:"[",CHAR_LINE_FEED:`
`,CHAR_NO_BREAK_SPACE:"\xA0",CHAR_PERCENT:"%",CHAR_PLUS:"+",CHAR_QUESTION_MARK:"?",CHAR_RIGHT_ANGLE_BRACKET:"&gt;",CHAR_RIGHT_CURLY_BRACE:"}",CHAR_RIGHT_SQUARE_BRACKET:"]",CHAR_SEMICOLON:";",CHAR_SINGLE_QUOTE:"'",CHAR_SPACE:" ",CHAR_TAB:"	",CHAR_UNDERSCORE:"_",CHAR_VERTICAL_LINE:"|",CHAR_ZERO_WIDTH_NOBREAK_SPACE:"\uFEFF"}});var Pt=K((hs,Nt)=&gt;{"use strict";var en=ke(),{MAX_LENGTH:It,CHAR_BACKSLASH:qe,CHAR_BACKTICK:tn,CHAR_COMMA:rn,CHAR_DOT:nn,CHAR_LEFT_PARENTHESES:sn,CHAR_RIGHT_PARENTHESES:an,CHAR_LEFT_CURLY_BRACE:on,CHAR_RIGHT_CURLY_BRACE:cn,CHAR_LEFT_SQUARE_BRACKET:Bt,CHAR_RIGHT_SQUARE_BRACKET:Mt,CHAR_DOUBLE_QUOTE:un,CHAR_SINGLE_QUOTE:ln,CHAR_NO_BREAK_SPACE:pn,CHAR_ZERO_WIDTH_NOBREAK_SPACE:fn}=Ot(),hn=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string");l</span></span>et r=<span class="cstat-no" title="statement not covered" >t||{},</span>n=<span class="cstat-no" title="statement not covered" >typeof r.maxLength=="number"?Math.min(It,r.maxLength):It;<span class="cstat-no" title="statement not covered" ></span>if(e.length&gt;n)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(`Input length (${e.length}), exceeds max characters (${n})`);l</span></span>et s=<span class="cstat-no" title="statement not covered" >{type:"root",input:e,nodes:[]},</span>a=<span class="cstat-no" title="statement not covered" >[s],</span>i=<span class="cstat-no" title="statement not covered" >s,</span>o=<span class="cstat-no" title="statement not covered" >s,</span>h=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >e.length,</span>f=<span class="cstat-no" title="statement not covered" >0,</span>A=<span class="cstat-no" title="statement not covered" >0,</span>p,k=<span class="cstat-no" title="statement not covered" >{},</span>y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e[f++],</span></span>R=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >_=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(_.type==="text"&amp;&amp;o.type==="dot"&amp;&amp;(o.type="text"),o&amp;&amp;o.type==="text"&amp;&amp;_.type==="text"){<span class="cstat-no" title="statement not covered" >o.value+=_.value;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.nodes.push(_),_.parent=i,_.prev=o,o=_,_}</span>;<span class="cstat-no" title="statement not covered" ></span>for(R({type:"bos"});f&lt;g;)<span class="cstat-no" title="statement not covered" >if(i=a[a.length-1],p=y(),!(p===fn||p===pn)){<span class="cstat-no" title="statement not covered" >if(p===qe){<span class="cstat-no" title="statement not covered" >R({type:"text",value:(t.keepEscaping?p:"")+y()});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===Mt){<span class="cstat-no" title="statement not covered" >R({type:"text",value:"\\"+p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===Bt){<span class="cstat-no" title="statement not covered" >h++;l</span>et _=<span class="cstat-no" title="statement not covered" >!0,</span>x;<span class="cstat-no" title="statement not covered" >for(;f&lt;g&amp;&amp;(x=y());){<span class="cstat-no" title="statement not covered" >if(p+=x,x===Bt){<span class="cstat-no" title="statement not covered" >h++;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x===qe){<span class="cstat-no" title="statement not covered" >p+=y();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x===Mt&amp;&amp;(h--,h===0))<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>R</span>({type:"text",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===sn){<span class="cstat-no" title="statement not covered" >i=R({type:"paren",nodes:[]}),a.push(i),R({type:"text",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===an){<span class="cstat-no" title="statement not covered" >if(i.type!=="paren"){<span class="cstat-no" title="statement not covered" >R({type:"text",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>=a.pop(),R({type:"text",value:p}),i=a[a.length-1];<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===un||p===ln||p===tn){let _=<span class="cstat-no" title="statement not covered" >p,</span>x;<span class="cstat-no" title="statement not covered" >for(t.keepQuotes!==!0&amp;&amp;(p="");f&lt;g&amp;&amp;(x=y());){<span class="cstat-no" title="statement not covered" >if(x===qe){<span class="cstat-no" title="statement not covered" >p+=x+y();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x===_){<span class="cstat-no" title="statement not covered" >t.keepQuotes===!0&amp;&amp;(p+=x);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>p</span>+=x}<span class="cstat-no" title="statement not covered" ></span>R</span>({type:"text",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===on){<span class="cstat-no" title="statement not covered" >A++;l</span>et _=<span class="cstat-no" title="statement not covered" >o.value&amp;&amp;o.value.slice(-1)==="$"||i.dollar===!0;<span class="cstat-no" title="statement not covered" ></span>i=R({type:"brace",open:!0,close:!1,dollar:_,depth:A,commas:0,ranges:0,nodes:[]}),a.push(i),R({type:"open",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===cn){<span class="cstat-no" title="statement not covered" >if(i.type!=="brace"){<span class="cstat-no" title="statement not covered" >R({type:"text",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et _=<span class="cstat-no" title="statement not covered" >"close";<span class="cstat-no" title="statement not covered" ></span>i=a.pop(),i.close=!0,R({type:_,value:p}),A--,i=a[a.length-1];<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===rn&amp;&amp;A&gt;0){<span class="cstat-no" title="statement not covered" >if(i.ranges&gt;0){<span class="cstat-no" title="statement not covered" >i.ranges=0;l</span>et _=<span class="cstat-no" title="statement not covered" >i.nodes.shift();<span class="cstat-no" title="statement not covered" ></span>i.nodes=[_,{type:"text",value:en(i)}]}<span class="cstat-no" title="statement not covered" ></span>R</span>({type:"comma",value:p}),i.commas++;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(p===nn&amp;&amp;A&gt;0&amp;&amp;i.commas===0){let _=<span class="cstat-no" title="statement not covered" >i.nodes;<span class="cstat-no" title="statement not covered" ></span>if(A===0||_.length===0){<span class="cstat-no" title="statement not covered" >R({type:"text",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o.type==="dot"){<span class="cstat-no" title="statement not covered" >if(i.range=[],o.value+=p,o.type="range",i.nodes.length!==3&amp;&amp;i.nodes.length!==5){<span class="cstat-no" title="statement not covered" >i.invalid=!0,i.ranges=0,o.type="text";<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>.ranges++,i.args=[];<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o.type==="range"){<span class="cstat-no" title="statement not covered" >_.pop();l</span>et x=<span class="cstat-no" title="statement not covered" >_[_.length-1];<span class="cstat-no" title="statement not covered" ></span>x.value+=o.value+p,o=x,i.ranges--;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>R</span>({type:"dot",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>R</span>({type:"text",value:p})}<span class="cstat-no" title="statement not covered" ></span>d</span></span>o <span class="cstat-no" title="statement not covered" >if(i=a.pop(),i.type!=="root"){<span class="cstat-no" title="statement not covered" >i.nodes.forEach(<span class="fstat-no" title="function not covered" >T=</span>&gt;{<span class="cstat-no" title="statement not covered" >T.nodes||(T.type==="open"&amp;&amp;(T.isOpen=!0),T.type==="close"&amp;&amp;(T.isClose=!0),T.nodes||(T.type="text"),T.invalid=!0)}</span>);l</span>et _=<span class="cstat-no" title="statement not covered" >a[a.length-1],</span>x=<span class="cstat-no" title="statement not covered" >_.nodes.indexOf(i);<span class="cstat-no" title="statement not covered" ></span>_.nodes.splice(x,1,...i.nodes)}</span>w</span>hile(a.length&gt;0);<span class="cstat-no" title="statement not covered" >r</span>eturn R({type:"eos"}),s}</span>;Nt.exports=hn});var Gt=K((ds,Dt)=&gt;{"use strict";var Ut=ke(),dn=Ht(),gn=Tt(),mn=Pt(),V=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >for(let n of e){let s=<span class="cstat-no" title="statement not covered" >V.create(n,t);<span class="cstat-no" title="statement not covered" ></span>Array.isArray(s)?r.push(...s):r.push(s)}</span>e</span>lse <span class="cstat-no" title="statement not covered" >r=[].concat(V.create(e,t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t&amp;&amp;t.expand===!0&amp;&amp;t.nodupes===!0&amp;&amp;(r=[...new Set(r)]),r}</span>;V.parse=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >mn(e,t);</span>V.stringify=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >typeof e=="string"?Ut(V.parse(e,t),t):Ut(e,t);</span>V.compile=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;(<span class="cstat-no" title="statement not covered" >typeof e=="string"&amp;&amp;(e=V.parse(e,t)),dn(e,t))</span>;V.expand=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >typeof e=="string"&amp;&amp;(e=V.parse(e,t));l</span>et r=<span class="cstat-no" title="statement not covered" >gn(e,t);<span class="cstat-no" title="statement not covered" ></span>return t.noempty===!0&amp;&amp;(r=r.filter(Boolean)),t.nodupes===!0&amp;&amp;(r=[...new Set(r)]),r}</span>;V.create=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" >e===""||e.length&lt;3?[e]:t.expand!==!0?V.compile(e,t):V.expand(e,t);</span>Dt.exports=V});var ye=K((gs,qt)=&gt;{"use strict";var An=require("path"),ie="\\\\/",Kt=`[^${ie}]`,ce="\\.",Rn="\\+",yn="\\?",Le="\\/",bn="(?=.)",Wt="[^/]",Ke=`(?:${Le}|$)`,jt=`(?:^|${Le})`,We=`${ce}{1,2}${Ke}`,_n=`(?!${ce})`,En=`(?!${jt}${We})`,xn=`(?!${ce}{0,1}${Ke})`,Cn=`(?!${We})`,wn=`[^.${Le}]`,Sn=`${Wt}*?`,Ft={DOT_LITERAL:ce,PLUS_LITERAL:Rn,QMARK_LITERAL:yn,SLASH_LITERAL:Le,ONE_CHAR:bn,QMARK:Wt,END_ANCHOR:Ke,DOTS_SLASH:We,NO_DOT:_n,NO_DOTS:En,NO_DOT_SLASH:xn,NO_DOTS_SLASH:Cn,QMARK_NO_DOT:wn,STAR:Sn,START_ANCHOR:jt},vn=Q(B({},Ft),{SLASH_LITERAL:`[${ie}]`,QMARK:Kt,STAR:`${Kt}*?`,DOTS_SLASH:`${ce}{1,2}(?:[${ie}]|$)`,NO_DOT:`(?!${ce})`,NO_DOTS:`(?!(?:^|[${ie}])${ce}{1,2}(?:[${ie}]|$))`,NO_DOT_SLASH:`(?!${ce}{0,1}(?:[${ie}]|$))`,NO_DOTS_SLASH:`(?!${ce}{1,2}(?:[${ie}]|$))`,QMARK_NO_DOT:`[^.${ie}]`,START_ANCHOR:`(?:^|[${ie}])`,END_ANCHOR:`(?:[${ie}]|$)`}),Hn={alnum:"a-zA-Z0-9",alpha:"a-zA-Z",ascii:"\\x00-\\x7F",blank:" \\t",cntrl:"\\x00-\\x1F\\x7F",digit:"0-9",graph:"\\x21-\\x7E",lower:"a-z",print:"\\x20-\\x7E ",punct:"\\-!\"#$%&amp;'()\\*+,./:;&lt;=&gt;?@[\\]^_`{|}~",space:" \\t\\r\\n\\v\\f",upper:"A-Z",word:"A-Za-z0-9_",xdigit:"A-Fa-f0-9"};qt.exports={MAX_LENGTH:1024*64,POSIX_REGEX_SOURCE:Hn,REGEX_BACKSLASH:/\\(?![*+?^${}(|)[\]])/g,REGEX_NON_SPECIAL_CHARS:/^[^@![\].,$*+?^{}()|\\/]+/,REGEX_SPECIAL_CHARS:/[-*+?.^${}(|)[\]]/,REGEX_SPECIAL_CHARS_BACKREF:/(\\?)((\W)(\3*))/g,REGEX_SPECIAL_CHARS_GLOBAL:/([-*+?.^${}(|)[\]])/g,REGEX_REMOVE_BACKSLASH:/(?:\[.*?[^\\]\]|\\(?=.))/g,REPLACEMENTS:{"***":"*","**/**":"**","**/**/**":"**"},CHAR_0:48,CHAR_9:57,CHAR_UPPERCASE_A:65,CHAR_LOWERCASE_A:97,CHAR_UPPERCASE_Z:90,CHAR_LOWERCASE_Z:122,CHAR_LEFT_PARENTHESES:40,CHAR_RIGHT_PARENTHESES:41,CHAR_ASTERISK:42,CHAR_AMPERSAND:38,CHAR_AT:64,CHAR_BACKWARD_SLASH:92,CHAR_CARRIAGE_RETURN:13,CHAR_CIRCUMFLEX_ACCENT:94,CHAR_COLON:58,CHAR_COMMA:44,CHAR_DOT:46,CHAR_DOUBLE_QUOTE:34,CHAR_EQUAL:61,CHAR_EXCLAMATION_MARK:33,CHAR_FORM_FEED:12,CHAR_FORWARD_SLASH:47,CHAR_GRAVE_ACCENT:96,CHAR_HASH:35,CHAR_HYPHEN_MINUS:45,CHAR_LEFT_ANGLE_BRACKET:60,CHAR_LEFT_CURLY_BRACE:123,CHAR_LEFT_SQUARE_BRACKET:91,CHAR_LINE_FEED:10,CHAR_NO_BREAK_SPACE:160,CHAR_PERCENT:37,CHAR_PLUS:43,CHAR_QUESTION_MARK:63,CHAR_RIGHT_ANGLE_BRACKET:62,CHAR_RIGHT_CURLY_BRACE:125,CHAR_RIGHT_SQUARE_BRACKET:93,CHAR_SEMICOLON:59,CHAR_SINGLE_QUOTE:39,CHAR_SPACE:32,CHAR_TAB:9,CHAR_UNDERSCORE:95,CHAR_VERTICAL_LINE:124,CHAR_ZERO_WIDTH_NOBREAK_SPACE:65279,SEP:An.sep,<span class="fstat-no" title="function not covered" >ex</span>tglobChars(e){<span class="cstat-no" title="statement not covered" >return{"!":{type:"negate",open:"(?:(?!(?:",close:`))${e.STAR})`},"?":{type:"qmark",open:"(?:",close:")?"},"+":{type:"plus",open:"(?:",close:")+"},"*":{type:"star",open:"(?:",close:")*"},"@":{type:"at",open:"(?:",close:")"}}}</span>,<span class="fstat-no" title="function not covered" >gl</span>obChars(e){<span class="cstat-no" title="statement not covered" >return e===!0?vn:Ft}</span>}});var be=K(Z=&gt;{"use strict";var $n=require("path"),kn=process.platform==="win32",{REGEX_BACKSLASH:Tn,REGEX_REMOVE_BACKSLASH:Ln,REGEX_SPECIAL_CHARS:On,REGEX_SPECIAL_CHARS_GLOBAL:Nn}=ye();Z.isObject=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e!==null&amp;&amp;typeof e=="object"&amp;&amp;!Array.isArray(e);</span>Z.hasRegexChars=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >On.test(e);</span>Z.isRegexChar=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.length===1&amp;&amp;Z.hasRegexChars(e);</span>Z.escapeRegex=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.replace(Nn,"\\$1");</span>Z.toPosixSlashes=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.replace(Tn,"/");</span>Z.removeBackslashes=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.replace(Ln,<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t==="\\"?"":t)</span>;</span>Z.supportsLookbehinds=<span class="fstat-no" title="function not covered" >()</span>=&gt;{let e=<span class="cstat-no" title="statement not covered" >process.version.slice(1).split(".").map(Number);<span class="cstat-no" title="statement not covered" ></span>return e.length===3&amp;&amp;e[0]&gt;=9||e[0]===8&amp;&amp;e[1]&gt;=10}</span>;Z.isWindows=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e&amp;&amp;typeof e.windows=="boolean"?e.windows:kn===!0||$n.sep==="\\";</span>Z.escapeLast=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >e.lastIndexOf(t,r);<span class="cstat-no" title="statement not covered" ></span>return n===-1?e:e[n-1]==="\\"?Z.escapeLast(e,t,n-1):`${e.slice(0,n)}\\${e.slice(n)}`}</span>;Z.removePrefix=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return r.startsWith("./")&amp;&amp;(r=r.slice(2),t.prefix="./"),r}</span>;Z.wrapOutput=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let n=<span class="cstat-no" title="statement not covered" >r.contains?"":"^",</span>s=<span class="cstat-no" title="statement not covered" >r.contains?"":"$",</span>a=<span class="cstat-no" title="statement not covered" >`${n}(?:${e})${s}`;<span class="cstat-no" title="statement not covered" ></span>return t.negated===!0&amp;&amp;(a=`(?:^(?!${a}).*$)`),a}</span>});var er=K((As,Qt)=&gt;{"use strict";var Xt=be(),{CHAR_ASTERISK:je,CHAR_AT:In,CHAR_BACKWARD_SLASH:_e,CHAR_COMMA:Bn,CHAR_DOT:Fe,CHAR_EXCLAMATION_MARK:Qe,CHAR_FORWARD_SLASH:Zt,CHAR_LEFT_CURLY_BRACE:Xe,CHAR_LEFT_PARENTHESES:Ze,CHAR_LEFT_SQUARE_BRACKET:Mn,CHAR_PLUS:Pn,CHAR_QUESTION_MARK:Yt,CHAR_RIGHT_CURLY_BRACE:Dn,CHAR_RIGHT_PARENTHESES:zt,CHAR_RIGHT_SQUARE_BRACKET:Un}=ye(),Vt=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e===Zt||e===_e,</span>Jt=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.isPrefix!==!0&amp;&amp;(e.depth=e.isGlobstar?Infinity:1)}</span>,Gn=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >t||{},</span>n=<span class="cstat-no" title="statement not covered" >e.length-1,</span>s=<span class="cstat-no" title="statement not covered" >r.parts===!0||r.scanToEnd===!0,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >e,</span>g=<span class="cstat-no" title="statement not covered" >-1,</span>f=<span class="cstat-no" title="statement not covered" >0,</span>A=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >!1,</span>k=<span class="cstat-no" title="statement not covered" >!1,</span>y=<span class="cstat-no" title="statement not covered" >!1,</span>R=<span class="cstat-no" title="statement not covered" >!1,</span>_=<span class="cstat-no" title="statement not covered" >!1,</span>x=<span class="cstat-no" title="statement not covered" >!1,</span>T=<span class="cstat-no" title="statement not covered" >!1,</span>O=<span class="cstat-no" title="statement not covered" >!1,</span>W=<span class="cstat-no" title="statement not covered" >!1,</span>G=<span class="cstat-no" title="statement not covered" >!1,</span>ne=<span class="cstat-no" title="statement not covered" >0,</span>E,b,C=<span class="cstat-no" title="statement not covered" >{value:"",depth:0,isGlob:!1},</span>M=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >g&gt;=n,</span></span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >h.charCodeAt(g+1),</span></span>H=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >E=b,h.charCodeAt(++g))</span>;<span class="cstat-no" title="statement not covered" ></span>for(;g&lt;n;){<span class="cstat-no" title="statement not covered" >b=H();l</span>et I;<span class="cstat-no" title="statement not covered" >if(b===_e){<span class="cstat-no" title="statement not covered" >T=C.backslashes=!0,b=H(),b===Xe&amp;&amp;(x=!0);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x===!0||b===Xe){<span class="cstat-no" title="statement not covered" >for(ne++;M()!==!0&amp;&amp;(b=H());){<span class="cstat-no" title="statement not covered" >if(b===_e){<span class="cstat-no" title="statement not covered" >T=C.backslashes=!0,H();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b===Xe){<span class="cstat-no" title="statement not covered" >ne++;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x!==!0&amp;&amp;b===Fe&amp;&amp;(b=H())===Fe){<span class="cstat-no" title="statement not covered" >if(p=C.isBrace=!0,y=C.isGlob=!0,G=!0,s===!0)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x!==!0&amp;&amp;b===Bn){<span class="cstat-no" title="statement not covered" >if(p=C.isBrace=!0,y=C.isGlob=!0,G=!0,s===!0)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b===Dn&amp;&amp;(ne--,ne===0)){<span class="cstat-no" title="statement not covered" >x=!1,p=C.isBrace=!0,G=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s===!0)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b===Zt){<span class="cstat-no" title="statement not covered" >if(a.push(g),i.push(C),C={value:"",depth:0,isGlob:!1},G===!0)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(E===Fe&amp;&amp;g===f+1){<span class="cstat-no" title="statement not covered" >f+=2;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>A</span>=g+1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.noext!==!0&amp;&amp;(b===Pn||b===In||b===je||b===Yt||b===Qe)===!0&amp;&amp;l()===Ze){<span class="cstat-no" title="statement not covered" >if(y=C.isGlob=!0,R=C.isExtglob=!0,G=!0,b===Qe&amp;&amp;g===f&amp;&amp;(W=!0),s===!0){<span class="cstat-no" title="statement not covered" >for(;M()!==!0&amp;&amp;(b=H());){<span class="cstat-no" title="statement not covered" >if(b===_e){<span class="cstat-no" title="statement not covered" >T=C.backslashes=!0,b=H();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b===zt){<span class="cstat-no" title="statement not covered" >y=C.isGlob=!0,G=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b===je){<span class="cstat-no" title="statement not covered" >if(E===je&amp;&amp;(_=C.isGlobstar=!0),y=C.isGlob=!0,G=!0,s===!0)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b===Yt){<span class="cstat-no" title="statement not covered" >if(y=C.isGlob=!0,G=!0,s===!0)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b===Mn){<span class="cstat-no" title="statement not covered" >for(;M()!==!0&amp;&amp;(I=H());){<span class="cstat-no" title="statement not covered" >if(I===_e){<span class="cstat-no" title="statement not covered" >T=C.backslashes=!0,H();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(I===Un){<span class="cstat-no" title="statement not covered" >k=C.isBracket=!0,y=C.isGlob=!0,G=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s===!0)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.nonegate!==!0&amp;&amp;b===Qe&amp;&amp;g===f){<span class="cstat-no" title="statement not covered" >O=C.negated=!0,f++;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.noparen!==!0&amp;&amp;b===Ze){<span class="cstat-no" title="statement not covered" >if(y=C.isGlob=!0,s===!0){<span class="cstat-no" title="statement not covered" >for(;M()!==!0&amp;&amp;(b=H());){<span class="cstat-no" title="statement not covered" >if(b===Ze){<span class="cstat-no" title="statement not covered" >T=C.backslashes=!0,b=H();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b===zt){<span class="cstat-no" title="statement not covered" >G=!0;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span>f(y===!0){<span class="cstat-no" title="statement not covered" >if(G=!0,s===!0)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>.noext===!0&amp;&amp;(R=!1,y=!1);l</span>et w=<span class="cstat-no" title="statement not covered" >h,</span>j=<span class="cstat-no" title="statement not covered" >"",</span>c=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>f&gt;0&amp;&amp;(j=h.slice(0,f),h=h.slice(f),A-=f),w&amp;&amp;y===!0&amp;&amp;A&gt;0?(w=h.slice(0,A),c=h.slice(A)):y===!0?(w="",c=h):w=h,w&amp;&amp;w!==""&amp;&amp;w!=="/"&amp;&amp;w!==h&amp;&amp;Vt(w.charCodeAt(w.length-1))&amp;&amp;(w=w.slice(0,-1)),r.unescape===!0&amp;&amp;(c&amp;&amp;(c=Xt.removeBackslashes(c)),w&amp;&amp;T===!0&amp;&amp;(w=Xt.removeBackslashes(w)));l</span>et u=<span class="cstat-no" title="statement not covered" >{prefix:j,input:e,start:f,base:w,glob:c,isBrace:p,isBracket:k,isGlob:y,isExtglob:R,isGlobstar:_,negated:O,negatedExtglob:W};<span class="cstat-no" title="statement not covered" ></span>if(r.tokens===!0&amp;&amp;(u.maxDepth=0,Vt(b)||i.push(C),u.tokens=i),r.parts===!0||r.tokens===!0){let I;<span class="cstat-no" title="statement not covered" >for(let $=<span class="cstat-no" title="statement not covered" >0;</span>$&lt;a.length;$++){let ee=<span class="cstat-no" title="statement not covered" >I?I+1:f,</span>se=<span class="cstat-no" title="statement not covered" >a[$],</span>z=<span class="cstat-no" title="statement not covered" >e.slice(ee,se);<span class="cstat-no" title="statement not covered" ></span>r.tokens&amp;&amp;($===0&amp;&amp;f!==0?(i[$].isPrefix=!0,i[$].value=j):i[$].value=z,Jt(i[$]),u.maxDepth+=i[$].depth),($!==0||z!=="")&amp;&amp;o.push(z),I=se}<span class="cstat-no" title="statement not covered" ></span>i</span>f(I&amp;&amp;I+1&lt;e.length){let $=<span class="cstat-no" title="statement not covered" >e.slice(I+1);<span class="cstat-no" title="statement not covered" ></span>o.push($),r.tokens&amp;&amp;(i[i.length-1].value=$,Jt(i[i.length-1]),u.maxDepth+=i[i.length-1].depth)}<span class="cstat-no" title="statement not covered" ></span>u</span>.slashes=a,u.parts=o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn u}</span>;Qt.exports=Gn});var sr=K((Rs,tr)=&gt;{"use strict";var Oe=ye(),J=be(),{MAX_LENGTH:Ne,POSIX_REGEX_SOURCE:qn,REGEX_NON_SPECIAL_CHARS:Kn,REGEX_SPECIAL_CHARS_BACKREF:Wn,REPLACEMENTS:rr}=Oe,jn=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof t.expandRange=="function")<span class="cstat-no" title="statement not covered" >return t.expandRange(...e,t);<span class="cstat-no" title="statement not covered" >e</span></span>.sort();l</span>et r=<span class="cstat-no" title="statement not covered" >`[${e.join("-")}]`;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >new RegExp(r)}</span>catch(n){<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >J.escapeRegex(s))</span>.join("..")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>,de=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >`Missing ${e}: "${t}" - use "\\\\${t}" to match literal characters`,</span>nr=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string");<span class="cstat-no" title="statement not covered" >e</span></span>=rr[e]||e;l</span>et r=<span class="cstat-no" title="statement not covered" >B({},t),</span>n=<span class="cstat-no" title="statement not covered" >typeof r.maxLength=="number"?Math.min(Ne,r.maxLength):Ne,</span>s=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(s&gt;n)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(`Input length: ${s}, exceeds maximum allowed length: ${n}`);l</span></span>et a=<span class="cstat-no" title="statement not covered" >{type:"bos",value:"",output:r.prepend||""},</span>i=<span class="cstat-no" title="statement not covered" >[a],</span>o=<span class="cstat-no" title="statement not covered" >r.capture?"":"?:",</span>h=<span class="cstat-no" title="statement not covered" >J.isWindows(t),</span>g=<span class="cstat-no" title="statement not covered" >Oe.globChars(h),</span>f=<span class="cstat-no" title="statement not covered" >Oe.extglobChars(g),</span>{DOT_LITERAL:A,PLUS_LITERAL:p,SLASH_LITERAL:k,ONE_CHAR:y,DOTS_SLASH:R,NO_DOT:_,NO_DOT_SLASH:x,NO_DOTS_SLASH:T,QMARK:O,QMARK_NO_DOT:W,STAR:G,START_ANCHOR:ne}=<span class="cstat-no" title="statement not covered" >g,</span>E=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >m=</span>&gt;<span class="cstat-no" title="statement not covered" >`(${o}(?:(?!${ne}${m.dot?R:A}).)*?)`,</span></span>b=<span class="cstat-no" title="statement not covered" >r.dot?"":_,</span>C=<span class="cstat-no" title="statement not covered" >r.dot?O:W,</span>M=<span class="cstat-no" title="statement not covered" >r.bash===!0?E(r):G;<span class="cstat-no" title="statement not covered" ></span>r.capture&amp;&amp;(M=`(${M})`),typeof r.noext=="boolean"&amp;&amp;(r.noextglob=r.noext);l</span>et l=<span class="cstat-no" title="statement not covered" >{input:e,index:-1,start:0,dot:r.dot===!0,consumed:"",output:"",prefix:"",backtrack:!1,negated:!1,brackets:0,braces:0,parens:0,quotes:0,globstar:!1,tokens:i};<span class="cstat-no" title="statement not covered" ></span>e=J.removePrefix(e,l),s=e.length;l</span>et H=<span class="cstat-no" title="statement not covered" >[],</span>w=<span class="cstat-no" title="statement not covered" >[],</span>j=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >a,</span>u,I=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l.index===s-1,</span></span>$=<span class="cstat-no" title="statement not covered" >l.peek=<span class="fstat-no" title="function not covered" >(m</span>=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>=&gt;<span class="cstat-no" title="statement not covered" >e[l.index+m],</span></span>ee=<span class="cstat-no" title="statement not covered" >l.advance=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e[++l.index]||"",</span></span>se=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.slice(l.index+1),</span></span>z=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(m</span>=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>L=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>=&gt;{<span class="cstat-no" title="statement not covered" >l.consumed+=m,l.index+=L}</span>,</span>Ce=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >m=</span>&gt;{<span class="cstat-no" title="statement not covered" >l.output+=m.output!=null?m.output:m.value,z(m.value)}</span>,</span>xr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{let m=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" ></span>for(;$()==="!"&amp;&amp;($(2)!=="("||$(3)==="?");)<span class="cstat-no" title="statement not covered" >ee(),l.start++,m++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn m%2==0?!1:(l.negated=!0,l.start++,!0)}</span>,</span>we=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >m=</span>&gt;{<span class="cstat-no" title="statement not covered" >l[m]++,j.push(m)}</span>,</span>ue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >m=</span>&gt;{<span class="cstat-no" title="statement not covered" >l[m]--,j.pop()}</span>,</span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >m=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(c.type==="globstar"){let L=<span class="cstat-no" title="statement not covered" >l.braces&gt;0&amp;&amp;(m.type==="comma"||m.type==="brace"),</span>d=<span class="cstat-no" title="statement not covered" >m.extglob===!0||H.length&amp;&amp;(m.type==="pipe"||m.type==="paren");<span class="cstat-no" title="statement not covered" ></span>m.type!=="slash"&amp;&amp;m.type!=="paren"&amp;&amp;!L&amp;&amp;!d&amp;&amp;(l.output=l.output.slice(0,-c.output.length),c.type="star",c.value="*",c.output=M,l.output+=c.output)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(H.length&amp;&amp;m.type!=="paren"&amp;&amp;(H[H.length-1].inner+=m.value),(m.value||m.output)&amp;&amp;Ce(m),c&amp;&amp;c.type==="text"&amp;&amp;m.type==="text"){<span class="cstat-no" title="statement not covered" >c.value+=m.value,c.output=(c.output||"")+m.value;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>m</span>.prev=c,i.push(m),c=m}</span>,</span>Se=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(m</span>,L)=&gt;{let d=<span class="cstat-no" title="statement not covered" >Q(B({},f[L]),{conditions:1,inner:""});<span class="cstat-no" title="statement not covered" ></span>d.prev=c,d.parens=l.parens,d.output=l.output;l</span>et S=<span class="cstat-no" title="statement not covered" >(r.capture?"(":"")+d.open;<span class="cstat-no" title="statement not covered" ></span>we("parens"),v({type:m,value:L,output:l.output?"":y}),v({type:"paren",extglob:!0,value:ee(),output:S}),H.push(d)}</span>,</span>Cr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >m=</span>&gt;{let L=<span class="cstat-no" title="statement not covered" >m.close+(r.capture?")":""),</span>d;<span class="cstat-no" title="statement not covered" >if(m.type==="negate"){let S=<span class="cstat-no" title="statement not covered" >M;<span class="cstat-no" title="statement not covered" ></span>m.inner&amp;&amp;m.inner.length&gt;1&amp;&amp;m.inner.includes("/")&amp;&amp;(S=E(r)),(S!==M||I()||/^\)+$/.test(se()))&amp;&amp;(L=m.close=`)$))${S}`),m.inner.includes("*")&amp;&amp;(d=se())&amp;&amp;/^\.[^\\/.]+$/.test(d)&amp;&amp;(L=m.close=`)${d})${S})`),m.prev.type==="bos"&amp;&amp;(l.negatedExtglob=!0)}<span class="cstat-no" title="statement not covered" ></span>v</span>({type:"paren",extglob:!0,value:u,output:L}),ue("parens")}</span>;<span class="cstat-no" title="statement not covered" ></span>if(r.fastpaths!==!1&amp;&amp;!/(^[*!]|[/()[\]{}"])/.test(e)){let m=<span class="cstat-no" title="statement not covered" >!1,</span>L=<span class="cstat-no" title="statement not covered" >e.replace(Wn,<span class="fstat-no" title="function not covered" >(d</span>,S,P,F,q,Me)=&gt;<span class="cstat-no" title="statement not covered" >F==="\\"?(m=!0,d):F==="?"?S?S+F+(q?O.repeat(q.length):""):Me===0?C+(q?O.repeat(q.length):""):O.repeat(P.length):F==="."?A.repeat(P.length):F==="*"?S?S+F+(q?M:""):M:S?d:`\\${d}`)</span>;<span class="cstat-no" title="statement not covered" ></span>return m===!0&amp;&amp;(r.unescape===!0?L=L.replace(/\\/g,""):L=L.replace(/\\+/g,<span class="fstat-no" title="function not covered" >d=</span>&gt;<span class="cstat-no" title="statement not covered" >d.length%2==0?"\\\\":d?"\\":"")</span>),L===e&amp;&amp;r.contains===!0?(l.output=e,l):(l.output=J.wrapOutput(L,l,t),l)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;!I();){<span class="cstat-no" title="statement not covered" >if(u=ee(),u==="\0")<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(u==="\\"){let d=<span class="cstat-no" title="statement not covered" >$();<span class="cstat-no" title="statement not covered" ></span>if(d==="/"&amp;&amp;r.bash!==!0||d==="."||d===";")<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!d){<span class="cstat-no" title="statement not covered" >u+="\\",v({type:"text",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et S=<span class="cstat-no" title="statement not covered" >/^\\+/.exec(se()),</span>P=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(S&amp;&amp;S[0].length&gt;2&amp;&amp;(P=S[0].length,l.index+=P,P%2!=0&amp;&amp;(u+="\\")),r.unescape===!0?u=ee():u+=ee(),l.brackets===0){<span class="cstat-no" title="statement not covered" >v({type:"text",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.brackets&gt;0&amp;&amp;(u!=="]"||c.value==="["||c.value==="[^")){<span class="cstat-no" title="statement not covered" >if(r.posix!==!1&amp;&amp;u===":"){let d=<span class="cstat-no" title="statement not covered" >c.value.slice(1);<span class="cstat-no" title="statement not covered" ></span>if(d.includes("[")&amp;&amp;(c.posix=!0,d.includes(":"))){let S=<span class="cstat-no" title="statement not covered" >c.value.lastIndexOf("["),</span>P=<span class="cstat-no" title="statement not covered" >c.value.slice(0,S),</span>F=<span class="cstat-no" title="statement not covered" >c.value.slice(S+2),</span>q=<span class="cstat-no" title="statement not covered" >qn[F];<span class="cstat-no" title="statement not covered" ></span>if(q){<span class="cstat-no" title="statement not covered" >c.value=P+q,l.backtrack=!0,ee(),!a.output&amp;&amp;i.indexOf(c)===1&amp;&amp;(a.output=y);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>(</span>u==="["&amp;&amp;$()!==":"||u==="-"&amp;&amp;$()==="]")&amp;&amp;(u=`\\${u}`),u==="]"&amp;&amp;(c.value==="["||c.value==="[^")&amp;&amp;(u=`\\${u}`),r.posix===!0&amp;&amp;u==="!"&amp;&amp;c.value==="["&amp;&amp;(u="^"),c.value+=u,Ce({value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.quotes===1&amp;&amp;u!=='"'){<span class="cstat-no" title="statement not covered" >u=J.escapeRegex(u),c.value+=u,Ce({value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==='"'){<span class="cstat-no" title="statement not covered" >l.quotes=l.quotes===1?0:1,r.keepQuotes===!0&amp;&amp;v({type:"text",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="("){<span class="cstat-no" title="statement not covered" >we("parens"),v({type:"paren",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u===")"){<span class="cstat-no" title="statement not covered" >if(l.parens===0&amp;&amp;r.strictBrackets===!0)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(de("opening","("));l</span></span>et d=<span class="cstat-no" title="statement not covered" >H[H.length-1];<span class="cstat-no" title="statement not covered" ></span>if(d&amp;&amp;l.parens===d.parens+1){<span class="cstat-no" title="statement not covered" >Cr(H.pop());<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>v</span>({type:"paren",value:u,output:l.parens?")":"\\)"}),ue("parens");<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="["){<span class="cstat-no" title="statement not covered" >if(r.nobracket===!0||!se().includes("]")){<span class="cstat-no" title="statement not covered" >if(r.nobracket!==!0&amp;&amp;r.strictBrackets===!0)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(de("closing","]"));<span class="cstat-no" title="statement not covered" >u</span></span>=`\\${u}`}</span>else <span class="cstat-no" title="statement not covered" >we("brackets");<span class="cstat-no" title="statement not covered" >v</span></span>({type:"bracket",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="]"){<span class="cstat-no" title="statement not covered" >if(r.nobracket===!0||c&amp;&amp;c.type==="bracket"&amp;&amp;c.value.length===1){<span class="cstat-no" title="statement not covered" >v({type:"text",value:u,output:`\\${u}`});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.brackets===0){<span class="cstat-no" title="statement not covered" >if(r.strictBrackets===!0)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(de("opening","["));<span class="cstat-no" title="statement not covered" >v</span></span>({type:"text",value:u,output:`\\${u}`});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>u</span>e("brackets");l</span>et d=<span class="cstat-no" title="statement not covered" >c.value.slice(1);<span class="cstat-no" title="statement not covered" ></span>if(c.posix!==!0&amp;&amp;d[0]==="^"&amp;&amp;!d.includes("/")&amp;&amp;(u=`/${u}`),c.value+=u,Ce({value:u}),r.literalBrackets===!1||J.hasRegexChars(d))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et S=<span class="cstat-no" title="statement not covered" >J.escapeRegex(c.value);<span class="cstat-no" title="statement not covered" ></span>if(l.output=l.output.slice(0,-c.value.length),r.literalBrackets===!0){<span class="cstat-no" title="statement not covered" >l.output+=S,c.value=S;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>c</span>.value=`(${o}${S}|${c.value})`,l.output+=c.value;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="{"&amp;&amp;r.nobrace!==!0){<span class="cstat-no" title="statement not covered" >we("braces");l</span>et d=<span class="cstat-no" title="statement not covered" >{type:"brace",value:u,output:"(",outputIndex:l.output.length,tokensIndex:l.tokens.length};<span class="cstat-no" title="statement not covered" ></span>w.push(d),v(d);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="}"){let d=<span class="cstat-no" title="statement not covered" >w[w.length-1];<span class="cstat-no" title="statement not covered" ></span>if(r.nobrace===!0||!d){<span class="cstat-no" title="statement not covered" >v({type:"text",value:u,output:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et S=<span class="cstat-no" title="statement not covered" >")";<span class="cstat-no" title="statement not covered" ></span>if(d.dots===!0){let P=<span class="cstat-no" title="statement not covered" >i.slice(),</span>F=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let q=<span class="cstat-no" title="statement not covered" >P.length-1;</span>q&gt;=0&amp;&amp;(i.pop(),P[q].type!=="brace");q--)<span class="cstat-no" title="statement not covered" >P[q].type!=="dots"&amp;&amp;F.unshift(P[q].value);<span class="cstat-no" title="statement not covered" >S</span></span>=jn(F,r),l.backtrack=!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d.comma!==!0&amp;&amp;d.dots!==!0){let P=<span class="cstat-no" title="statement not covered" >l.output.slice(0,d.outputIndex),</span>F=<span class="cstat-no" title="statement not covered" >l.tokens.slice(d.tokensIndex);<span class="cstat-no" title="statement not covered" ></span>d.value=d.output="\\{",u=S="\\}",l.output=P;<span class="cstat-no" title="statement not covered" >f</span>or(let q of F)<span class="cstat-no" title="statement not covered" >l.output+=q.output||q.value}<span class="cstat-no" title="statement not covered" ></span></span>v</span>({type:"brace",value:u,output:S}),ue("braces"),w.pop();<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="|"){<span class="cstat-no" title="statement not covered" >H.length&gt;0&amp;&amp;H[H.length-1].conditions++,v({type:"text",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u===","){let d=<span class="cstat-no" title="statement not covered" >u,</span>S=<span class="cstat-no" title="statement not covered" >w[w.length-1];<span class="cstat-no" title="statement not covered" ></span>S&amp;&amp;j[j.length-1]==="braces"&amp;&amp;(S.comma=!0,d="|"),v({type:"comma",value:u,output:d});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="/"){<span class="cstat-no" title="statement not covered" >if(c.type==="dot"&amp;&amp;l.index===l.start+1){<span class="cstat-no" title="statement not covered" >l.start=l.index+1,l.consumed="",l.output="",i.pop(),c=a;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>v</span>({type:"slash",value:u,output:k});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="."){<span class="cstat-no" title="statement not covered" >if(l.braces&gt;0&amp;&amp;c.type==="dot"){<span class="cstat-no" title="statement not covered" >c.value==="."&amp;&amp;(c.output=A);l</span>et d=<span class="cstat-no" title="statement not covered" >w[w.length-1];<span class="cstat-no" title="statement not covered" ></span>c.type="dots",c.output+=u,c.value+=u,d.dots=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(l.braces+l.parens===0&amp;&amp;c.type!=="bos"&amp;&amp;c.type!=="slash"){<span class="cstat-no" title="statement not covered" >v({type:"text",value:u,output:A});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>v</span>({type:"dot",value:u,output:A});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="?"){<span class="cstat-no" title="statement not covered" >if(!(c&amp;&amp;c.value==="(")&amp;&amp;r.noextglob!==!0&amp;&amp;$()==="("&amp;&amp;$(2)!=="?"){<span class="cstat-no" title="statement not covered" >Se("qmark",u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(c&amp;&amp;c.type==="paren"){let S=<span class="cstat-no" title="statement not covered" >$(),</span>P=<span class="cstat-no" title="statement not covered" >u;<span class="cstat-no" title="statement not covered" ></span>if(S==="&lt;"&amp;&amp;!J.supportsLookbehinds())<span class="cstat-no" title="statement not covered" >throw new Error("Node.js v10 or higher is required for regex lookbehinds");<span class="cstat-no" title="statement not covered" >(</span></span>c.value==="("&amp;&amp;!/[!=&lt;:]/.test(S)||S==="&lt;"&amp;&amp;!/&lt;([!=]|\w+&gt;)/.test(se()))&amp;&amp;(P=`\\${u}`),v({type:"text",value:u,output:P});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.dot!==!0&amp;&amp;(c.type==="slash"||c.type==="bos")){<span class="cstat-no" title="statement not covered" >v({type:"qmark",value:u,output:W});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>v</span>({type:"qmark",value:u,output:O});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="!"){<span class="cstat-no" title="statement not covered" >if(r.noextglob!==!0&amp;&amp;$()==="("&amp;&amp;($(2)!=="?"||!/[!=&lt;:]/.test($(3)))){<span class="cstat-no" title="statement not covered" >Se("negate",u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.nonegate!==!0&amp;&amp;l.index===0){<span class="cstat-no" title="statement not covered" >xr();<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="+"){<span class="cstat-no" title="statement not covered" >if(r.noextglob!==!0&amp;&amp;$()==="("&amp;&amp;$(2)!=="?"){<span class="cstat-no" title="statement not covered" >Se("plus",u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(c&amp;&amp;c.value==="("||r.regex===!1){<span class="cstat-no" title="statement not covered" >v({type:"plus",value:u,output:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(c&amp;&amp;(c.type==="bracket"||c.type==="paren"||c.type==="brace")||l.parens&gt;0){<span class="cstat-no" title="statement not covered" >v({type:"plus",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>v</span>({type:"plus",value:p});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u==="@"){<span class="cstat-no" title="statement not covered" >if(r.noextglob!==!0&amp;&amp;$()==="("&amp;&amp;$(2)!=="?"){<span class="cstat-no" title="statement not covered" >v({type:"at",extglob:!0,value:u,output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>v</span>({type:"text",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(u!=="*"){<span class="cstat-no" title="statement not covered" >(u==="$"||u==="^")&amp;&amp;(u=`\\${u}`);l</span>et d=<span class="cstat-no" title="statement not covered" >Kn.exec(se());<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;(u+=d[0],l.index+=d[0].length),v({type:"text",value:u});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(c&amp;&amp;(c.type==="globstar"||c.star===!0)){<span class="cstat-no" title="statement not covered" >c.type="star",c.star=!0,c.value+=u,c.output=M,l.backtrack=!0,l.globstar=!0,z(u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et m=<span class="cstat-no" title="statement not covered" >se();<span class="cstat-no" title="statement not covered" ></span>if(r.noextglob!==!0&amp;&amp;/^\([^?]/.test(m)){<span class="cstat-no" title="statement not covered" >Se("star",u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(c.type==="star"){<span class="cstat-no" title="statement not covered" >if(r.noglobstar===!0){<span class="cstat-no" title="statement not covered" >z(u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et d=<span class="cstat-no" title="statement not covered" >c.prev,</span>S=<span class="cstat-no" title="statement not covered" >d.prev,</span>P=<span class="cstat-no" title="statement not covered" >d.type==="slash"||d.type==="bos",</span>F=<span class="cstat-no" title="statement not covered" >S&amp;&amp;(S.type==="star"||S.type==="globstar");<span class="cstat-no" title="statement not covered" ></span>if(r.bash===!0&amp;&amp;(!P||m[0]&amp;&amp;m[0]!=="/")){<span class="cstat-no" title="statement not covered" >v({type:"star",value:u,output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et q=<span class="cstat-no" title="statement not covered" >l.braces&gt;0&amp;&amp;(d.type==="comma"||d.type==="brace"),</span>Me=<span class="cstat-no" title="statement not covered" >H.length&amp;&amp;(d.type==="pipe"||d.type==="paren");<span class="cstat-no" title="statement not covered" ></span>if(!P&amp;&amp;d.type!=="paren"&amp;&amp;!q&amp;&amp;!Me){<span class="cstat-no" title="statement not covered" >v({type:"star",value:u,output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;m.slice(0,3)==="/**";){let ve=<span class="cstat-no" title="statement not covered" >e[l.index+4];<span class="cstat-no" title="statement not covered" ></span>if(ve&amp;&amp;ve!=="/")<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >m</span></span>=m.slice(3),z("/**",3)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d.type==="bos"&amp;&amp;I()){<span class="cstat-no" title="statement not covered" >c.type="globstar",c.value+=u,c.output=E(r),l.output=c.output,l.globstar=!0,z(u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d.type==="slash"&amp;&amp;d.prev.type!=="bos"&amp;&amp;!F&amp;&amp;I()){<span class="cstat-no" title="statement not covered" >l.output=l.output.slice(0,-(d.output+c.output).length),d.output=`(?:${d.output}`,c.type="globstar",c.output=E(r)+(r.strictSlashes?")":"|$)"),c.value+=u,l.globstar=!0,l.output+=d.output+c.output,z(u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d.type==="slash"&amp;&amp;d.prev.type!=="bos"&amp;&amp;m[0]==="/"){let ve=<span class="cstat-no" title="statement not covered" >m[1]!==void 0?"|$":"";<span class="cstat-no" title="statement not covered" ></span>l.output=l.output.slice(0,-(d.output+c.output).length),d.output=`(?:${d.output}`,c.type="globstar",c.output=`${E(r)}${k}|${k}${ve})`,c.value+=u,l.output+=d.output+c.output,l.globstar=!0,z(u+ee()),v({type:"slash",value:"/",output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(d.type==="bos"&amp;&amp;m[0]==="/"){<span class="cstat-no" title="statement not covered" >c.type="globstar",c.value+=u,c.output=`(?:^|${k}|${E(r)}${k})`,l.output=c.output,l.globstar=!0,z(u+ee()),v({type:"slash",value:"/",output:""});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>l</span>.output=l.output.slice(0,-c.output.length),c.type="globstar",c.output=E(r),c.value+=u,l.output+=c.output,l.globstar=!0,z(u);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et L=<span class="cstat-no" title="statement not covered" >{type:"star",value:u,output:M};<span class="cstat-no" title="statement not covered" ></span>if(r.bash===!0){<span class="cstat-no" title="statement not covered" >L.output=".*?",(c.type==="bos"||c.type==="slash")&amp;&amp;(L.output=b+L.output),v(L);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span>f(c&amp;&amp;(c.type==="bracket"||c.type==="paren")&amp;&amp;r.regex===!0){<span class="cstat-no" title="statement not covered" >L.output=u,v(L);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>(</span>l.index===l.start||c.type==="slash"||c.type==="dot")&amp;&amp;(c.type==="dot"?(l.output+=x,c.output+=x):r.dot===!0?(l.output+=T,c.output+=T):(l.output+=b,c.output+=b),$()!=="*"&amp;&amp;(l.output+=y,c.output+=y)),v(L)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;l.brackets&gt;0;){<span class="cstat-no" title="statement not covered" >if(r.strictBrackets===!0)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(de("closing","]"));<span class="cstat-no" title="statement not covered" >l</span></span>.output=J.escapeLast(l.output,"["),ue("brackets")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;l.parens&gt;0;){<span class="cstat-no" title="statement not covered" >if(r.strictBrackets===!0)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(de("closing",")"));<span class="cstat-no" title="statement not covered" >l</span></span>.output=J.escapeLast(l.output,"("),ue("parens")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;l.braces&gt;0;){<span class="cstat-no" title="statement not covered" >if(r.strictBrackets===!0)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(de("closing","}"));<span class="cstat-no" title="statement not covered" >l</span></span>.output=J.escapeLast(l.output,"{"),ue("braces")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r.strictSlashes!==!0&amp;&amp;(c.type==="star"||c.type==="bracket")&amp;&amp;v({type:"maybe_slash",value:"",output:`${k}?`}),l.backtrack===!0){<span class="cstat-no" title="statement not covered" >l.output="";<span class="cstat-no" title="statement not covered" >f</span>or(let m of l.tokens)<span class="cstat-no" title="statement not covered" >l.output+=m.output!=null?m.output:m.value,m.suffix&amp;&amp;(l.output+=m.suffix)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn l}</span>;nr.fastpaths=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >B({},t),</span>n=<span class="cstat-no" title="statement not covered" >typeof r.maxLength=="number"?Math.min(Ne,r.maxLength):Ne,</span>s=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(s&gt;n)<span class="cstat-no" title="statement not covered" >throw new SyntaxError(`Input length: ${s}, exceeds maximum allowed length: ${n}`);<span class="cstat-no" title="statement not covered" >e</span></span>=rr[e]||e;l</span>et a=<span class="cstat-no" title="statement not covered" >J.isWindows(t),</span>{DOT_LITERAL:i,SLASH_LITERAL:o,ONE_CHAR:h,DOTS_SLASH:g,NO_DOT:f,NO_DOTS:A,NO_DOTS_SLASH:p,STAR:k,START_ANCHOR:y}=<span class="cstat-no" title="statement not covered" >Oe.globChars(a),</span>R=<span class="cstat-no" title="statement not covered" >r.dot?A:f,</span>_=<span class="cstat-no" title="statement not covered" >r.dot?p:f,</span>x=<span class="cstat-no" title="statement not covered" >r.capture?"":"?:",</span>T=<span class="cstat-no" title="statement not covered" >{negated:!1,prefix:""},</span>O=<span class="cstat-no" title="statement not covered" >r.bash===!0?".*?":k;<span class="cstat-no" title="statement not covered" ></span>r.capture&amp;&amp;(O=`(${O})`);l</span>et W=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >b=</span>&gt;<span class="cstat-no" title="statement not covered" >b.noglobstar===!0?O:`(${x}(?:(?!${y}${b.dot?g:i}).)*?)`,</span></span>G=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >b=</span>&gt;{<span class="cstat-no" title="statement not covered" >switch(b){case"*":<span class="cstat-no" title="statement not covered" >return`${R}${h}${O}`;c</span>ase".*":<span class="cstat-no" title="statement not covered" >return`${i}${h}${O}`;c</span>ase"*.*":<span class="cstat-no" title="statement not covered" >return`${R}${O}${i}${h}${O}`;c</span>ase"*/*":<span class="cstat-no" title="statement not covered" >return`${R}${O}${o}${h}${_}${O}`;c</span>ase"**":<span class="cstat-no" title="statement not covered" >return R+W(r);c</span>ase"**/*":<span class="cstat-no" title="statement not covered" >return`(?:${R}${W(r)}${o})?${_}${h}${O}`;c</span>ase"**/*.*":<span class="cstat-no" title="statement not covered" >return`(?:${R}${W(r)}${o})?${_}${O}${i}${h}${O}`;c</span>ase"**/.*":<span class="cstat-no" title="statement not covered" >return`(?:${R}${W(r)}${o})?${i}${h}${O}`;d</span>efault:{let C=<span class="cstat-no" title="statement not covered" >/^(.*?)\.(\w+)$/.exec(b);<span class="cstat-no" title="statement not covered" ></span>if(!C)<span class="cstat-no" title="statement not covered" >return;l</span></span>et M=<span class="cstat-no" title="statement not covered" >G(C[1]);<span class="cstat-no" title="statement not covered" ></span>return M?M+i+C[2]:void 0}</span>}}</span>,</span>ne=<span class="cstat-no" title="statement not covered" >J.removePrefix(e,T),</span>E=<span class="cstat-no" title="statement not covered" >G(ne);<span class="cstat-no" title="statement not covered" ></span>return E&amp;&amp;r.strictSlashes!==!0&amp;&amp;(E+=`${o}?`),E}</span>;tr.exports=nr});var ir=K((ys,ar)=&gt;{"use strict";var Fn=require("path"),Qn=er(),Ye=sr(),ze=be(),Xn=ye(),Zn=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e&amp;&amp;typeof e=="object"&amp;&amp;!Array.isArray(e),</span>D=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(Array.isArray(e)){let f=<span class="cstat-no" title="statement not covered" >e.map(<span class="fstat-no" title="function not covered" >p=</span>&gt;<span class="cstat-no" title="statement not covered" >D(p,t,r))</span>;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >p=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(let k of f){let y=<span class="cstat-no" title="statement not covered" >k(p);<span class="cstat-no" title="statement not covered" ></span>if(y)<span class="cstat-no" title="statement not covered" >return y}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>}</span>l</span>et n=<span class="cstat-no" title="statement not covered" >Zn(e)&amp;&amp;e.tokens&amp;&amp;e.input;<span class="cstat-no" title="statement not covered" ></span>if(e===""||typeof e!="string"&amp;&amp;!n)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected pattern to be a non-empty string");l</span></span>et s=<span class="cstat-no" title="statement not covered" >t||{},</span>a=<span class="cstat-no" title="statement not covered" >ze.isWindows(t),</span>i=<span class="cstat-no" title="statement not covered" >n?D.compileRe(e,t):D.makeRe(e,t,!1,!0),</span>o=<span class="cstat-no" title="statement not covered" >i.state;<span class="cstat-no" title="statement not covered" ></span>delete i.state;l</span>et h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span></span>if(s.ignore){let f=<span class="cstat-no" title="statement not covered" >Q(B({},t),{ignore:null,onMatch:null,onResult:null});<span class="cstat-no" title="statement not covered" ></span>h=D(s.ignore,f,r)}</span>l</span>et g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(f</span>,A=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{let{isMatch:p,match:k,output:y}=<span class="cstat-no" title="statement not covered" >D.test(f,i,t,{glob:e,posix:a}),</span>R=<span class="cstat-no" title="statement not covered" >{glob:e,state:o,regex:i,posix:a,input:f,output:y,match:k,isMatch:p};<span class="cstat-no" title="statement not covered" ></span>return typeof s.onResult=="function"&amp;&amp;s.onResult(R),p===!1?(R.isMatch=!1,A?R:!1):h(f)?(typeof s.onIgnore=="function"&amp;&amp;s.onIgnore(R),R.isMatch=!1,A?R:!1):(typeof s.onMatch=="function"&amp;&amp;s.onMatch(R),A?R:!0)}</span>;<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(g.state=o),g}</span>;D.test=<span class="fstat-no" title="function not covered" >(e</span>,t,r,{glob:n,posix:s}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected input to be a string");<span class="cstat-no" title="statement not covered" >i</span></span>f(e==="")<span class="cstat-no" title="statement not covered" >return{isMatch:!1,output:""};l</span></span>et a=<span class="cstat-no" title="statement not covered" >r||{},</span>i=<span class="cstat-no" title="statement not covered" >a.format||(s?ze.toPosixSlashes:null),</span>o=<span class="cstat-no" title="statement not covered" >e===n,</span>h=<span class="cstat-no" title="statement not covered" >o&amp;&amp;i?i(e):e;<span class="cstat-no" title="statement not covered" ></span>return o===!1&amp;&amp;(h=i?i(e):e,o=h===n),(o===!1||a.capture===!0)&amp;&amp;(a.matchBase===!0||a.basename===!0?o=D.matchBase(e,t,r,s):o=t.exec(h)),{isMatch:Boolean(o),match:o,output:h}}</span>;D.matchBase=<span class="fstat-no" title="function not covered" >(e</span>,t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >ze.isWindows(r))</span>=&gt;<span class="cstat-no" title="statement not covered" >(t instanceof RegExp?t:D.makeRe(t,r)).test(Fn.basename(e));</span>D.isMatch=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >D(t,r)(e);</span>D.parse=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >Array.isArray(e)?e.map(<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" >D.parse(r,t))</span>:Ye(e,Q(B({},t),{fastpaths:!1}));</span>D.scan=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >Qn(e,t);</span>D.compileRe=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(r===!0)<span class="cstat-no" title="statement not covered" >return e.output;l</span></span>et s=<span class="cstat-no" title="statement not covered" >t||{},</span>a=<span class="cstat-no" title="statement not covered" >s.contains?"":"^",</span>i=<span class="cstat-no" title="statement not covered" >s.contains?"":"$",</span>o=<span class="cstat-no" title="statement not covered" >`${a}(?:${e.output})${i}`;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.negated===!0&amp;&amp;(o=`^(?!${o}).*$`);l</span>et h=<span class="cstat-no" title="statement not covered" >D.toRegex(o,t);<span class="cstat-no" title="statement not covered" ></span>return n===!0&amp;&amp;(h.state=e),h}</span>;D.makeRe=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!e||typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a non-empty string");l</span></span>et s=<span class="cstat-no" title="statement not covered" >{negated:!1,fastpaths:!0};<span class="cstat-no" title="statement not covered" ></span>return t.fastpaths!==!1&amp;&amp;(e[0]==="."||e[0]==="*")&amp;&amp;(s.output=Ye.fastpaths(e,t)),s.output||(s=Ye(e,t)),D.compileRe(s,t,r,n)}</span>;D.toRegex=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >try{let r=<span class="cstat-no" title="statement not covered" >t||{};<span class="cstat-no" title="statement not covered" ></span>return new RegExp(e,r.flags||(r.nocase?"i":""))}</span>catch(r){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;t.debug===!0)<span class="cstat-no" title="statement not covered" >throw r;<span class="cstat-no" title="statement not covered" >r</span></span>eturn/$^/}</span>}</span>;D.constants=Xn;ar.exports=D});var cr=K((bs,or)=&gt;{"use strict";or.exports=ir()});var hr=K((_s,ur)=&gt;{"use strict";var lr=require("util"),pr=Gt(),oe=cr(),Ve=be(),fr=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e===""||e==="./",</span>N=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >t=[].concat(t),e=[].concat(e);l</span>et n=<span class="cstat-no" title="statement not covered" >new Set,</span>s=<span class="cstat-no" title="statement not covered" >new Set,</span>a=<span class="cstat-no" title="statement not covered" >new Set,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >f=</span>&gt;{<span class="cstat-no" title="statement not covered" >a.add(f.output),r&amp;&amp;r.onResult&amp;&amp;r.onResult(f)}</span>;<span class="cstat-no" title="statement not covered" ></span>for(let f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;t.length;f++){let A=<span class="cstat-no" title="statement not covered" >oe(String(t[f]),Q(B({},r),{onResult:o}),!0),</span>p=<span class="cstat-no" title="statement not covered" >A.state.negated||A.state.negatedExtglob;<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;i++;<span class="cstat-no" title="statement not covered" >f</span>or(let k of e){let y=<span class="cstat-no" title="statement not covered" >A(k,!0);<span class="cstat-no" title="statement not covered" ></span>!(p?!y.isMatch:y.isMatch)||(p?n.add(y.output):(n.delete(y.output),s.add(y.output)))}</span>}</span>l</span>et g=<span class="cstat-no" title="statement not covered" >(i===t.length?[...a]:[...s]).filter(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >!n.has(f))</span>;<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;g.length===0){<span class="cstat-no" title="statement not covered" >if(r.failglob===!0)<span class="cstat-no" title="statement not covered" >throw new Error(`No matches found for "${t.join(", ")}"`);<span class="cstat-no" title="statement not covered" >i</span></span>f(r.nonull===!0||r.nullglob===!0)<span class="cstat-no" title="statement not covered" >return r.unescape?t.map(<span class="fstat-no" title="function not covered" >f=</span>&gt;<span class="cstat-no" title="statement not covered" >f.replace(/\\/g,""))</span>:t}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn g}</span>;N.match=N;N.matcher=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >oe(e,t);</span>N.isMatch=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >oe(t,r)(e);</span>N.any=N.isMatch;N.not=<span class="fstat-no" title="function not covered" >(e</span>,t,r=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >t=[].concat(t).map(String);l</span>et n=<span class="cstat-no" title="statement not covered" >new Set,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.onResult&amp;&amp;r.onResult(o),s.push(o.output)}</span>,</span>i=<span class="cstat-no" title="statement not covered" >N(e,t,Q(B({},r),{onResult:a}));<span class="cstat-no" title="statement not covered" ></span>for(let o of s)<span class="cstat-no" title="statement not covered" >i.includes(o)||n.add(o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[...n]}</span>;N.contains=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected a string: "${lr.inspect(e)}"`);<span class="cstat-no" title="statement not covered" >i</span></span>f(Array.isArray(t))<span class="cstat-no" title="statement not covered" >return t.some(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >N.contains(e,n,r))</span>;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof t=="string"){<span class="cstat-no" title="statement not covered" >if(fr(e)||fr(t))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.includes(t)||e.startsWith("./")&amp;&amp;e.slice(2).includes(t))<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn N.isMatch(e,t,Q(B({},r),{contains:!0}))}</span>;N.matchKeys=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(!Ve.isObject(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected the first argument to be an object");l</span></span>et n=<span class="cstat-no" title="statement not covered" >N(Object.keys(e),t,r),</span>s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let a of n)<span class="cstat-no" title="statement not covered" >s[a]=e[a];<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>;N.some=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >[].concat(e);<span class="cstat-no" title="statement not covered" ></span>for(let s of[].concat(t)){let a=<span class="cstat-no" title="statement not covered" >oe(String(s),r);<span class="cstat-no" title="statement not covered" ></span>if(n.some(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >a(i))</span>)<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>;N.every=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >[].concat(e);<span class="cstat-no" title="statement not covered" ></span>for(let s of[].concat(t)){let a=<span class="cstat-no" title="statement not covered" >oe(String(s),r);<span class="cstat-no" title="statement not covered" ></span>if(!n.every(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >a(i))</span>)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}</span>;N.all=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected a string: "${lr.inspect(e)}"`);<span class="cstat-no" title="statement not covered" >r</span></span>eturn[].concat(t).every(<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >oe(n,r)(e))</span>}</span>;N.capture=<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >Ve.isWindows(r),</span>a=<span class="cstat-no" title="statement not covered" >oe.makeRe(String(e),Q(B({},r),{capture:!0})).exec(n?Ve.toPosixSlashes(t):t);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a.slice(1).map(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i===void 0?"":i)</span>}</span></span>;N.makeRe=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >oe.makeRe(...e);</span>N.scan=<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >oe.scan(...e);</span>N.parse=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n of[].concat(e||[]))<span class="cstat-no" title="statement not covered" >for(let s of pr(String(n),t))<span class="cstat-no" title="statement not covered" >r.push(oe.parse(s,t));<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn r}</span>;N.braces=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string");<span class="cstat-no" title="statement not covered" >r</span></span>eturn t&amp;&amp;t.nobrace===!0||!/\{.*\}/.test(e)?[e]:pr(e,t)}</span>;N.braceExpand=<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected a string");<span class="cstat-no" title="statement not covered" >r</span></span>eturn N.braces(e,Q(B({},t),{expand:!0}))}</span>;ur.exports=N});var gr=K((Es,dr)=&gt;{"use strict";dr.exports=<span class="fstat-no" title="function not covered" >(e</span>,...t)=&gt;<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >r(e(...t))}</span>)}</span>);var Ar=K((xs,Je)=&gt;{"use strict";var Yn=gr(),mr=<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e&lt;1)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected `concurrency` to be a number from 1 and up");l</span></span>et t=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r--,t.length&gt;0&amp;&amp;t.shift()()}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(o</span>,h,...g)=&gt;{<span class="cstat-no" title="statement not covered" >r++;l</span>et f=<span class="cstat-no" title="statement not covered" >Yn(o,...g);<span class="cstat-no" title="statement not covered" ></span>h(f),f.then(n,n)}</span>,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(o</span>,h,...g)=&gt;{<span class="cstat-no" title="statement not covered" >r&lt;e?s(o,h,...g):t.push(s.bind(null,o,h,...g))}</span>,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(o</span>,...h)=&gt;<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >g=</span>&gt;<span class="cstat-no" title="statement not covered" >a(o,g,...h))</span>;<span class="cstat-no" title="statement not covered" ></span></span>return Object.defineProperties(i,{activeCount:{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r}</span>,pendingCount:{get:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.length}</span>}),i}</span>;Je.exports=mr;Je.exports.default=mr});var Vn={};Or(Vn,{default:()=&gt;es});var He=X(require("@yarnpkg/cli")),ae=X(require("@yarnpkg/core")),nt=X(require("@yarnpkg/core")),le=X(require("clipanion")),Ae=class extends He.BaseCommand{constructor(){super(...arguments);this.json=le.Option.Boolean("--json",!1,{description:"Format the output as an NDJSON stream"});this.production=le.Option.Boolean("--production",!1,{description:"Only install regular dependencies by omitting dev dependencies"});this.all=le.Option.Boolean("-A,--all",!1,{description:"Install the entire project"});this.workspaces=le.Option.Rest()}<span class="fstat-no" title="function not covered" >as</span>ync execute(){let t=<span class="cstat-no" title="statement not covered" >await ae.Configuration.find(this.context.cwd,this.context.plugins),</span>{project:r,workspace:n}=<span class="cstat-no" title="statement not covered" >await ae.Project.find(t,this.context.cwd),</span>s=<span class="cstat-no" title="statement not covered" >await ae.Cache.find(t);<span class="cstat-no" title="statement not covered" ></span>await r.restoreInstallState({restoreResolutions:!1});l</span>et a;<span class="cstat-no" title="statement not covered" >if(this.all)<span class="cstat-no" title="statement not covered" >a=new Set(r.workspaces);e</span>lse <span class="cstat-no" title="statement not covered" >if(this.workspaces.length===0){<span class="cstat-no" title="statement not covered" >if(!n)<span class="cstat-no" title="statement not covered" >throw new He.WorkspaceRequiredError(r.cwd,this.context.cwd);<span class="cstat-no" title="statement not covered" >a</span></span>=new Set([n])}</span>else <span class="cstat-no" title="statement not covered" >a=new Set(this.workspaces.map(<span class="fstat-no" title="function not covered" >o=</span>&gt;<span class="cstat-no" title="statement not covered" >r.getWorkspaceByIdent(nt.structUtils.parseIdent(o)))</span>);<span class="cstat-no" title="statement not covered" >f</span></span></span>or(let o of a)<span class="cstat-no" title="statement not covered" >for(let h of this.production?["dependencies"]:ae.Manifest.hardDependencies)<span class="cstat-no" title="statement not covered" >for(let g of o.manifest.getForScope(h).values()){let f=<span class="cstat-no" title="statement not covered" >r.tryWorkspaceByDescriptor(g);<span class="cstat-no" title="statement not covered" ></span>f!==null&amp;&amp;a.add(f)}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(let o of r.workspaces)<span class="cstat-no" title="statement not covered" >a.has(o)?this.production&amp;&amp;o.manifest.devDependencies.clear():(o.manifest.installConfig=o.manifest.installConfig||{},o.manifest.installConfig.selfReferences=!1,o.manifest.dependencies.clear(),o.manifest.devDependencies.clear(),o.manifest.peerDependencies.clear(),o.manifest.scripts.clear());<span class="cstat-no" title="statement not covered" >r</span></span>eturn(await ae.StreamReport.start({configuration:t,json:this.json,stdout:this.context.stdout,includeLogs:!0},<span class="fstat-no" title="function not covered" >as</span>ync o=&gt;{<span class="cstat-no" title="statement not covered" >await r.install({cache:s,report:o,persistProject:!1})}</span>)).exitCode()}</span>};Ae.paths=[["workspaces","focus"]],Ae.usage=le.Command.Usage({category:"Workspace-related commands",description:"install a single workspace and its dependencies",details:"\n      This command will run an install as if the specified workspaces (and all other workspaces they depend on) were the only ones in the project. If no workspaces are explicitly listed, the active one will be assumed.\n\n      Note that this command is only very moderately useful when using zero-installs, since the cache will contain all the packages anyway - meaning that the only difference between a full install and a focused install would just be a few extra lines in the `.pnp.cjs` file, at the cost of introducing an extra complexity.\n\n      If the `-A,--all` flag is set, the entire project will be installed. Combine with `--production` to replicate the old `yarn install --production`.\n    "});var st=Ae;var Ie=X(require("@yarnpkg/cli")),ge=X(require("@yarnpkg/core")),Ee=X(require("@yarnpkg/core")),Y=X(require("@yarnpkg/core")),Rr=X(require("@yarnpkg/plugin-git")),U=X(require("clipanion")),Be=X(hr()),yr=X(require("os")),br=X(Ar()),re=X(require("typanion")),xe=class extends Ie.BaseCommand{constructor(){super(...arguments);this.recursive=U.Option.Boolean("-R,--recursive",!1,{description:"Find packages via dependencies/devDependencies instead of using the workspaces field"});this.from=U.Option.Array("--from",[],{description:"An array of glob pattern idents from which to base any recursion"});this.all=U.Option.Boolean("-A,--all",!1,{description:"Run the command on all workspaces of a project"});this.verbose=U.Option.Boolean("-v,--verbose",!1,{description:"Prefix each output line with the name of the originating workspace"});this.parallel=U.Option.Boolean("-p,--parallel",!1,{description:"Run the commands in parallel"});this.interlaced=U.Option.Boolean("-i,--interlaced",!1,{description:"Print the output of commands in real-time instead of buffering it"});this.jobs=U.Option.String("-j,--jobs",{description:"The maximum number of parallel tasks that the execution will be limited to; or `unlimited`",validator:re.isOneOf([re.isEnum(["unlimited"]),re.applyCascade(re.isNumber(),[re.isInteger(),re.isAtLeast(1)])])});this.topological=U.Option.Boolean("-t,--topological",!1,{description:"Run the command after all workspaces it depends on (regular) have finished"});this.topologicalDev=U.Option.Boolean("--topological-dev",!1,{description:"Run the command after all workspaces it depends on (regular + dev) have finished"});this.include=U.Option.Array("--include",[],{description:"An array of glob pattern idents; only matching workspaces will be traversed"});this.exclude=U.Option.Array("--exclude",[],{description:"An array of glob pattern idents; matching workspaces won't be traversed"});this.publicOnly=U.Option.Boolean("--no-private",{description:"Avoid running the command on private workspaces"});this.since=U.Option.String("--since",{description:"Only include workspaces that have been changed since the specified ref.",tolerateBoolean:!0});this.commandName=U.Option.String();this.args=U.Option.Proxy()}<span class="fstat-no" title="function not covered" >as</span>ync execute(){let t=<span class="cstat-no" title="statement not covered" >await ge.Configuration.find(this.context.cwd,this.context.plugins),</span>{project:r,workspace:n}=<span class="cstat-no" title="statement not covered" >await ge.Project.find(t,this.context.cwd);<span class="cstat-no" title="statement not covered" ></span>if(!this.all&amp;&amp;!n)<span class="cstat-no" title="statement not covered" >throw new Ie.WorkspaceRequiredError(r.cwd,this.context.cwd);<span class="cstat-no" title="statement not covered" >a</span></span>wait r.restoreInstallState();l</span>et s=<span class="cstat-no" title="statement not covered" >this.cli.process([this.commandName,...this.args]),</span>a=<span class="cstat-no" title="statement not covered" >s.path.length===1&amp;&amp;s.path[0]==="run"&amp;&amp;typeof s.scriptName!="undefined"?s.scriptName:null;<span class="cstat-no" title="statement not covered" ></span>if(s.path.length===0)<span class="cstat-no" title="statement not covered" >throw new U.UsageError("Invalid subcommand name for iteration - use the 'run' keyword if you wish to execute a script");l</span></span>et i=<span class="cstat-no" title="statement not covered" >this.all?r.topLevelWorkspace:n,</span>o=<span class="cstat-no" title="statement not covered" >this.since?Array.from(await Rr.gitUtils.fetchChangedWorkspaces({ref:this.since,project:r})):[i,...this.from.length&gt;0?i.getRecursiveWorkspaceChildren():[]],</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >E=</span>&gt;<span class="cstat-no" title="statement not covered" >Be.default.isMatch(Y.structUtils.stringifyIdent(E.locator),this.from),</span></span>g=<span class="cstat-no" title="statement not covered" >this.from.length&gt;0?o.filter(h):o,</span>f=<span class="cstat-no" title="statement not covered" >new Set([...g,...g.map(<span class="fstat-no" title="function not covered" >E=</span>&gt;<span class="cstat-no" title="statement not covered" >[...this.recursive?this.since?E.getRecursiveWorkspaceDependents():E.getRecursiveWorkspaceDependencies():E.getRecursiveWorkspaceChildren()])</span>.flat()]),</span>A=<span class="cstat-no" title="statement not covered" >[],</span>p=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(a==null?void 0:a.includes(":")){<span class="cstat-no" title="statement not covered" >for(let E of r.workspaces)<span class="cstat-no" title="statement not covered" >if(E.manifest.scripts.has(a)&amp;&amp;(p=!p,p===!1))<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span></span>f</span>or(let E of f)<span class="cstat-no" title="statement not covered" >a&amp;&amp;!E.manifest.scripts.has(a)&amp;&amp;!p&amp;&amp;!(await ge.scriptUtils.getWorkspaceAccessibleBinaries(E)).has(a)||a===process.env.npm_lifecycle_event&amp;&amp;E.cwd===n.cwd||this.include.length&gt;0&amp;&amp;!Be.default.isMatch(Y.structUtils.stringifyIdent(E.locator),this.include)||this.exclude.length&gt;0&amp;&amp;Be.default.isMatch(Y.structUtils.stringifyIdent(E.locator),this.exclude)||this.publicOnly&amp;&amp;E.manifest.private===!0||A.push(E);l</span></span>et k=<span class="cstat-no" title="statement not covered" >this.parallel?this.jobs==="unlimited"?Infinity:this.jobs||Math.max(1,(0,yr.cpus)().length/2):1,</span>y=<span class="cstat-no" title="statement not covered" >k===1?!1:this.parallel,</span>R=<span class="cstat-no" title="statement not covered" >y?this.interlaced:!0,</span>_=<span class="cstat-no" title="statement not covered" >(0,br.default)(k),</span>x=<span class="cstat-no" title="statement not covered" >new Map,</span>T=<span class="cstat-no" title="statement not covered" >new Set,</span>O=<span class="cstat-no" title="statement not covered" >0,</span>W=<span class="cstat-no" title="statement not covered" >null,</span>G=<span class="cstat-no" title="statement not covered" >!1,</span>ne=<span class="cstat-no" title="statement not covered" >await Ee.StreamReport.start({configuration:t,stdout:this.context.stdout},<span class="fstat-no" title="function not covered" >as</span>ync E=&gt;{let b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >as</span>ync(C,{commandIndex:M})=&gt;{<span class="cstat-no" title="statement not covered" >if(G)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >!</span></span>y&amp;&amp;this.verbose&amp;&amp;M&gt;1&amp;&amp;E.reportSeparator();l</span>et l=<span class="cstat-no" title="statement not covered" >zn(C,{configuration:t,verbose:this.verbose,commandIndex:M}),</span>[H,w]=<span class="cstat-no" title="statement not covered" >_r(E,{prefix:l,interlaced:R}),</span>[j,c]=<span class="cstat-no" title="statement not covered" >_r(E,{prefix:l,interlaced:R});<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >this.verbose&amp;&amp;E.reportInfo(null,`${l} Process started`);l</span>et u=<span class="cstat-no" title="statement not covered" >Date.now(),</span>I=<span class="cstat-no" title="statement not covered" >await this.cli.run([this.commandName,...this.args],{cwd:C.cwd,stdout:H,stderr:j})||0;<span class="cstat-no" title="statement not covered" ></span>H.end(),j.end(),await w,await c;l</span>et $=<span class="cstat-no" title="statement not covered" >Date.now();<span class="cstat-no" title="statement not covered" ></span>if(this.verbose){let ee=<span class="cstat-no" title="statement not covered" >t.get("enableTimers")?`, completed in ${Y.formatUtils.pretty(t,$-u,Y.formatUtils.Type.DURATION)}`:"";<span class="cstat-no" title="statement not covered" ></span>E.reportInfo(null,`${l} Process exited (exit code ${I})${ee}`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn I===130&amp;&amp;(G=!0,W=I),I}</span>catch(u){<span class="cstat-no" title="statement not covered" >throw H.end(),j.end(),await w,await c,u}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>for(let C of A)<span class="cstat-no" title="statement not covered" >x.set(C.anchoredLocator.locatorHash,C);<span class="cstat-no" title="statement not covered" >f</span></span>or(;x.size&gt;0&amp;&amp;!E.hasErrors();){let C=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let[H,w]of x){<span class="cstat-no" title="statement not covered" >if(T.has(w.anchoredDescriptor.descriptorHash))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et j=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>if(this.topological||this.topologicalDev){let c=<span class="cstat-no" title="statement not covered" >this.topologicalDev?new Map([...w.manifest.dependencies,...w.manifest.devDependencies]):w.manifest.dependencies;<span class="cstat-no" title="statement not covered" ></span>for(let u of c.values()){let I=<span class="cstat-no" title="statement not covered" >r.tryWorkspaceByDescriptor(u);<span class="cstat-no" title="statement not covered" ></span>if(j=I===null||!x.has(I.anchoredLocator.locatorHash),!j)<span class="cstat-no" title="statement not covered" >break}</span></span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(!!j&amp;&amp;(T.add(w.anchoredDescriptor.descriptorHash),C.push(_(<span class="fstat-no" title="function not covered" >as</span>ync()=&gt;{let c=<span class="cstat-no" title="statement not covered" >await b(w,{commandIndex:++O});<span class="cstat-no" title="statement not covered" ></span>return x.delete(H),T.delete(w.anchoredDescriptor.descriptorHash),c}</span>)),!y))<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(C.length===0){let H=<span class="cstat-no" title="statement not covered" >Array.from(x.values()).map(<span class="fstat-no" title="function not covered" >w=</span>&gt;<span class="cstat-no" title="statement not covered" >Y.structUtils.prettyLocator(t,w.anchoredLocator))</span>.join(", ");<span class="cstat-no" title="statement not covered" ></span>E.reportError(Ee.MessageName.CYCLIC_DEPENDENCIES,`Dependency cycle detected (${H})`);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>l</span>et l=<span class="cstat-no" title="statement not covered" >(await Promise.all(C)).find(<span class="fstat-no" title="function not covered" >H=</span>&gt;<span class="cstat-no" title="statement not covered" >H!==0)</span>;<span class="cstat-no" title="statement not covered" ></span>W===null&amp;&amp;(W=typeof l!="undefined"?1:W),(this.topological||this.topologicalDev)&amp;&amp;typeof l!="undefined"&amp;&amp;E.reportError(Ee.MessageName.UNNAMED,"The command failed for workspaces that are depended upon by other workspaces; can't satisfy the dependency graph")}</span>}</span>);<span class="cstat-no" title="statement not covered" ></span>return W!==null?W:ne.exitCode()}</span>};xe.paths=[["workspaces","foreach"]],xe.usage=U.Command.Usage({category:"Workspace-related commands",description:"run a command on all workspaces",details:"\n      This command will run a given sub-command on current and all its descendant workspaces. Various flags can alter the exact behavior of the command:\n\n      - If `-p,--parallel` is set, the commands will be ran in parallel; they'll by default be limited to a number of parallel tasks roughly equal to half your core number, but that can be overridden via `-j,--jobs`, or disabled by setting `-j unlimited`.\n\n      - If `-p,--parallel` and `-i,--interlaced` are both set, Yarn will print the lines from the output as it receives them. If `-i,--interlaced` wasn't set, it would instead buffer the output from each process and print the resulting buffers only after their source processes have exited.\n\n      - If `-t,--topological` is set, Yarn will only run the command after all workspaces that it depends on through the `dependencies` field have successfully finished executing. If `--topological-dev` is set, both the `dependencies` and `devDependencies` fields will be considered when figuring out the wait points.\n\n      - If `-A,--all` is set, Yarn will run the command on all the workspaces of a project. By default yarn runs the command only on current and all its descendant workspaces.\n\n      - If `-R,--recursive` is set, Yarn will find workspaces to run the command on by recursively evaluating `dependencies` and `devDependencies` fields, instead of looking at the `workspaces` fields.\n\n      - If `--from` is set, Yarn will use the packages matching the 'from' glob as the starting point for any recursive search.\n\n      - If `--since` is set, Yarn will only run the command on workspaces that have been modified since the specified ref. By default Yarn will use the refs specified by the `changesetBaseRefs` configuration option.\n\n      - The command may apply to only some workspaces through the use of `--include` which acts as a whitelist. The `--exclude` flag will do the opposite and will be a list of packages that mustn't execute the script. Both flags accept glob patterns (if valid Idents and supported by [micromatch](https://github.com/micromatch/micromatch)). Make sure to escape the patterns, to prevent your own shell from trying to expand them.\n\n      Adding the `-v,--verbose` flag will cause Yarn to print more information; in particular the name of the workspace that generated the output will be printed at the front of each line.\n\n      If the command is `run` and the script being run does not exist the child workspace will be skipped without error.\n    ",examples:[["Publish current and all descendant packages","yarn workspaces foreach npm publish --tolerate-republish"],["Run build script on current and all descendant packages","yarn workspaces foreach run build"],["Run build script on current and all descendant packages in parallel, building package dependencies first","yarn workspaces foreach -pt run build"],["Run build script on several packages and all their dependencies, building dependencies first","yarn workspaces foreach -ptR --from '{workspace-a,workspace-b}' run build"]]});var Er=xe;function <span class="fstat-no" title="function not covered" >_r(</span>e,{prefix:t,interlaced:r}){let n=<span class="cstat-no" title="statement not covered" >e.createStreamReporter(t),</span>s=<span class="cstat-no" title="statement not covered" >new Y.miscUtils.DefaultStream;<span class="cstat-no" title="statement not covered" ></span>s.pipe(n,{end:!1}),s.on("finish",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n.end()}</span>);l</span>et a=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >o=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.on("finish",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o(s.active)}</span>)}</span>);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return[s,a];l</span></span>et i=<span class="cstat-no" title="statement not covered" >new Y.miscUtils.BufferStream;<span class="cstat-no" title="statement not covered" ></span>return i.pipe(s,{end:!1}),i.on("finish",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s.end()}</span>),[i,a]}</span>function <span class="fstat-no" title="function not covered" >zn(</span>e,{configuration:t,commandIndex:r,verbose:n}){<span class="cstat-no" title="statement not covered" >if(!n)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et s=<span class="cstat-no" title="statement not covered" >Y.structUtils.convertToIdent(e.locator),</span>i=<span class="cstat-no" title="statement not covered" >`[${Y.structUtils.stringifyIdent(s)}]:`,</span>o=<span class="cstat-no" title="statement not covered" >["#2E86AB","#A23B72","#F18F01","#C73E1D","#CCE2A3"],</span>h=<span class="cstat-no" title="statement not covered" >o[r%o.length];<span class="cstat-no" title="statement not covered" ></span>return Y.formatUtils.pretty(t,i,h)}</span>var Jn={commands:[st,Er]},es=Jn;return Vn;})();
/*!
 * fill-range &lt;https://github.com/jonschlinkert/fill-range&gt;
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-number &lt;https://github.com/jonschlinkert/is-number&gt;
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * to-regex-range &lt;https://github.com/micromatch/to-regex-range&gt;
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
return plugin;
}
};
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2023-05-16T10:35:10.742Z
            </div>
        <script src="../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../sorter.js"></script>
        <script src="../../block-navigation.js"></script>
    </body>
</html>
    